git reflog |  awk '{ print $1 }' | xargs gitk

git log --pretty=format:"%h - %an, %ar : %s"

7-11;14-18;19-22/11

220923/9-14;16-18;19-22/10h: sys_fork

220925/19-26/7h: schedule;sys_waitpid/sys_pause/sleep_on/interruptible_sleep_on;wake_up;sys_exit

220926/8-12/4h: sleep库函数

220927/12-16;18-20/6h: sleep函数是glibc库函数实现的，内核实现的定时是nanosleep，这两个sleep实现方式不一样;

220929/9-12;16-10/6h: 基于内核栈的内核线程切换

220930/14-18/4h: 基于内核栈的内核线程切换；信号量

221001/9-11/2h: 信号量

221002/9-15/6h: 信号量，c语言数据类型的实现，后端优化方向

**力扣刷题笔记**

[笔记1](https://books.halfrost.com/leetcode/)

**书籍-后端**

[很全的仓库](https://github.com/forthespada/CS-Books)

[结构很好](https://xie.infoq.cn/article/207aab244ae44b9fc5c71a059)

[github仓库1](https://github.com/7-sevens/Developer-Books)

[仓库2](https://github.com/jobbole/awesome-programming-books)

[外网私货](https://github.com/programthink/books)

**书籍-人工智能**

[机器学习面试](https://github.com/murufeng/Awesome-AI-algorithm)

[AI项目](https://github.com/cbamls/AI_Tutorial)

[AI找工作成长路线](https://github.com/amusi/AI-Job-Notes)

[AI网安工作成长路线](https://github.com/0xMJ/AI-Security-Learning)

[AI不同领域的论文](https://github.com/BINPIPE/learning-resources/blob/master/ai.md#DL)

[AI应用领域](https://github.com/romanlutz/ResponsibleAI)

[中文资料](https://github.com/wx-chevalier/AI-Series)

[外文资料](https://github.com/ahmedbahaaeldin/From-0-to-Research-Scientist-resources-guide)

[外文资料](https://github.com/owainlewis/awesome-artificial-intelligence)

[资料](https://github.com/foochane/books)

[比较喜欢的仓库-人工智能](https://github.com/ruanyf/free-books)

[人工智能](https://github.com/fengdu78/deeplearning_ai_books)

[大数据](https://github.com/justjavac/free-programming-books-zh_CN#%E5%A4%A7%E6%95%B0%E6%8D%AE)

**面试问题**

[资料](https://github.com/huihut/interview#os)

[电子书网站](https://www.book123.info/)

# 自我介绍和实习项目相关

项目整体介绍、难点、亮点、针对某点进行提问，如果要xxx，你要怎么解决（10分钟）

## Java项目

[廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744/1282383921807393)

# 操作系统相关

**书籍**

[操作系统设计与实现](C:\Users\cheng\Desktop\JavaBackend\书籍\操作系统\操作系统设计与实现(第三版上册).pdf)

[Linux内核设计与实现](C:\Users\cheng\Desktop\JavaBackend\书籍\操作系统\Linux内核设计与实现（第三版）.pdf)

**视频材料**

[哈工大李志军操作系统](https://www.bilibili.com/video/BV1d4411v7u7?p=2&spm_id_from=pageDriver)

**高级语言转汇编**

[在线高级语言转低级语言](https://godbolt.org/)

> **C/C++转汇编**
>
> gcc -E b.c -o b.i
> gcc -S b.i -o b.s

> **Python字节码**
>
> python -m dis a.py

> **Java使用hstdis和JITWatch查看字节码和汇编代码**
>
> https://blog.csdn.net/wo1901446409/article/details/98500024
>
> Java字节码javap

> **Go语言转汇编**
>
> go tool compile -N -l -S hello.go
>
> go tool objdump hello.o > hello.asm

**CPU上下文 进程上下文**

[参考](https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8F%9B/4842616)

进程上下文指的是进程保存在PCB里面用于切换CPU的寄存器和程序计数器的那些数据，CPU上下文值得是保存在CPU寄存器和程序计数器的数据。CPU上下文和进程上下文实际上是一个东西。

CPU上下文切换实际上是进程切换过程中修改CPU寄存器和程序计数器的过程。

**计算机组成原理-CPU工作过程**

```
50: mov ax,[100]
51: mov bx,[101]
52: add ax,bx

执行上面程序首先设置PC为50，CPU在地址总线传50获得命令并且存放到IR寄存器，然后解释执行这个指令，他的opcode为mov，会把100放到地址总线从内存中读到数值放到ax寄存器；然后PC自增到51，取指令把101号内存数值放到bx；然后PC自增到52，将ax和bx相加并将相加结果存放到ax，在bx保存是否溢出。
```

用汇编语言编写操作系统引导程序bootsect.s的原因，因为汇编严格操纵代码段，数据段和程序变量在内存中的位置，而高级语言你不能明确指定变量的位置。

计算机硬件包括CPU（计算机和控制器）、存储器（高速缓存Cache、主存、辅存-外存）、输入输出设备

冯诺依曼体系结构：把程序载入内存，然后CPU取指令执行（PC寄存器指向内存指令地址，指令读取到IR指令寄存器，指令包括操作码，操作寄存器和操作数，执行程序把操作寄存器赋值位操作数在内存中的地址的数值。

每个CPU都有自己的指令集（CPU架构），常用的比如RISCV架构指令集，CPU指令是CPU原语，对应一个机器语言，机器语言是二进制的代码，它包括操作码和操作数两个部分，一个机器语言有位数的限制，对应CPU寄存器的长度，比如32位指令集的机器语言对应的CPU寄存器大小是32位。汇编语言和机器语言很类似，他像是把机器语言的操作码操作数分别用指令如load和变量var等替换得到的汇编指令，因此汇编语言是和机器语言相关的低级语言，可以从编译得到的汇编语言直接翻译出对应的机器语言。高级语言的指令更加面向逻辑而不是跟CPU指令集相关，比如i=i+1，在实际机器语言中包括三个指令，从主存读i到寄存器read i，将立即数1放入寄存器，然后执行加法操作add，之后把add的结果送到主存i地址。

电脑加电启动的时候，计算机各个部分初始化，CPU初始化自己的各个寄存器，CPU的PC寄存器初始化为0指向内存的第一个位置，那是一个代码区，存放各种指令；内存中存放着指令和数据，指令和数据没有任何区分，他们都是32位的数字，只是被CPU访问方式不同。CPU通过指令寄存器PC访问到内存的32位被当成指令处理，而在处理指令过程中在操作数段的访问内存的地址的访问会被当成数据处理。

CPU执行程序的时候，他的PC寄存器指向被执行的指令，并且执行完成后自动指向下一条要被执行的语句（默认自增1，如果遇到跳转指令会修改成跳转的指令的地址）。当执行到加法运算时，根据操作数的地址访问内存获取操作数（这个过程需要地址转换），然后运算将运算结果送回到对应的内存地址；如果执行的是跳转指令，会修改PC寄存器指向跳转的指令的地址（汇编语言的goto 1）

**计算机学习层次**

- 应用程序层次，通过高级编程语言（C++，C，Java，Python）等编写代码，每个代码实际会产生系统调用，去调用操作系统用机器语言实现的方法。我们编写应用程序的时候只是关注业务逻辑，而不去关心操作系统怎么实现调用裸机的指令集完成操作

  高级语言的方法（JDK的调用函数，C++的方法）都是调用操作系统系统调用方法接口实现的，应用程序调用高级语言方法，会接着调用系统调用方法，之后系统调用方法调用机器语言指令，最终编译的时候会把高级语言翻译成机器语言，放到机器内存执行。

  高级语言如C等封装操作系统提供的系统调用，并且这些接口函数可以被用户程序调用

- 操作系统层面，操作系统封装了调用裸机暴露的指令集接口的程序，完成一个完整的逻辑功能的程序，并向上封装成系统调用，供高级语言调用。操作系统层面使用的机器指令，编写的是各个部件的驱动，并将它们联合起来组成一个完成的业务程序，比如高级语言的print方法会调用操作系统的系统调用print方法，系统调用的print方法是由计算机底层机器语言指令集写成的驱动程序

  操作系统封装机器语言指令形成完整逻辑，并且向上提供系统调用

- 计算机硬件层面，计算机硬件提供了驱动计算机硬件的指令集，可以用这些指令集编写程序驱动硬件的各个部分。实际上就是嵌入式开发。操作系统实际上就是嵌入式系统，他是用计算机提供的驱动计算机硬件的指令集编写的。

  设计CPU指令集，设计CPU，设计硬件系统，硬件系统的连接和驱动开发，向上暴露调用的接口和驱动。

  计算机硬件向上提供机器语言指令

**X86计算机操作系统启动过程**

操作系统放在磁盘的0扇区

启动时，使用BIOS的bootsect.s将操作系统的setup.s加载到内存；setup.s把操作系统核心代码System加载到内存0地址并进入保护模式；System的第一个程序是head.s会跳转到c函数main.c执行设备初始化，main.c初始化的设备包括内存、中断、外部设备、CPU、时钟等，初始化内存会调用memory.c中的mem_init()函数，mem_init()函数会把内存中不是操作系统的区域初始化为0. 操作系统启动时操作系统第一步，他把操作系统从磁盘0地址读取到内存0地址。初始化好的数据结构有GDT表、IDT表、位图mem_map管理内存的数据结构。这些数据结构都时保存在内存开头的那些位置，之后的位置是应用程序可以使用的内存。

- 加电CPU初始化各个寄存器，进入16位实模式，用CS：IP两个寄存器组合指向BIOS的启动程序bootsect.s(一个汇编代码)，bootsect.s会加载操作系统的setup.s程序（操作系统保存的在启动的时候选择启动方式时会把他的内存地址送到对应的初始化时的寄存器）执行。

- settup.s功能是建立数据结构把计算机硬件信息放到内存里面（比如内存大小，光标位置），然后加载操作系统到内存0地址，然后setup.s将CPU切换到32位保护模式，CS:IP跳转到内存0地址继续执行操作系统核心模块System

- System的第一个程序是head.s，head.s进一步初始化硬件设备。head.s会调用linux的main.c（一个C函数）执行初始化，main.c对计算机每一个硬件设备执行初始化，比如初始化内存设备memory.c里面有一个mem_init()函数，main函数会调用这个设备的mem_init()方法从而把内存memory设备初始化，初始化内存实际上会使用setup.s时期建立的内存大小的计算机信息，用它来标记应该被初始化的内存的大小，这里的初始化内存的大小是减去了操作系统代码大小的内存大小。

  main.c初始化的设备包括内存，中断，外部设备，时钟，CPU等设备。

**应用程序调用操作系统执行过程-系统调用，操作系统接口**

1. **操作系统程序执行方式**

   - **使用命令行执行程序的过程**

     shell是一个c语言编写的程序，他一直while循环并读取命令行，当我们使用gcc 编译我们的程序，他会fork一个进程执行cmd指令（cmd就是命令行输入的指令gcc -o output output.c)

   - **使用图形界面执行程序-给无界面的Linux系统编写图形界面**

     硬件输入（点击鼠标、键盘输入）会被放入系统消息队列，操作系统会读取这个消息并且执行对应的用户程序

2.  **系统调用标准**

   POSIX是一个系统调用标准，它规定了操作系统向上层提供的系统调用接口，Potable Operating System Interface of Unix

   常用系统调用接口

   操作系统接口是系统调用，是操作系统向上提供的接口，调用系统调用会让程序进入内核态执行操作系统的系统调用程序

   | 分类     | POSIX系统调用接口 | 功能描述             |
   | -------- | ----------------- | -------------------- |
   | 任务管理 | fork              | 创建一个进程         |
   |          | execl             | 运行一个可执行程序   |
   |          | pthread_create    | 创建一个线程         |
   | 文件系统 | open              | 打开一个文件或目录   |
   |          | EACCES            | 返回值，表示没有权限 |
   |          | mode_t和st_mode   | 文件头结构和文件属性 |

3. 系统调用如何实现

- 为什么要使用系统调用而不是直接用户程序访问操作系统程序和数据

  系统调用函数和数据保存在操作系统的内存区，用户函数不能直接调用操作系统函数，也就是用户程序不能执行跳转指令直接跳转到操作系统函数位置。为什么用户程序不能直接访问操作系统函数和数据，主要是为了安全。如果用户程序能够直接访问操作系统数据，那么用户程序可能直接获得root密码，第三方用户执行操作系统时留在操作系统缓冲的数据可以被当前用户直接访问看到。

- 怎么实现用户程序不能直接访问操作系统程序和数据，怎么实现用户程序和内核程序隔离

  答案是使用硬件检查

  执行在用户态的程序的PC是CS：IP寄存器组合的，CS的最低两位是CPL，代表当前指令所在的内存段的特权级别，用户段的特权级别是3；在操作系统内核代码被setup从磁盘0地址加载到内存0地址的时候，会创建一个GDT表，这个表保存了内核段的CS的DPL是0，也就是目标段的特权级别是0，表示这个CS是内核段（操作系统保存的内存）。当一个用户程序的CS：IP要跳转到新的段的时候，他会检查目标段的DPL是否>=当前段的CPL，如果目标段的特权级别大于等于当前段的特权级别才能跳转。

  当用户段跳转到内核段的时候，会执行一个检查查看目标段的隔离级别DPL是否大于等于当前段的CPL隔离级别，如果大于才能跳转，否则是不能跳转的。因为用户段特权级别是3，而内核段的特权级别是0，所以跳转时检查不能通过，就不能从用户段跳转到内核段，也就是用户段不能直接访问内核段程序和数据。

- 不让用户程序直接调用操作系统程序和数据，那用户程序怎么想用操作系统服务

  **以printf为例解释应用程序如何执行系统调用**

  - 用户程序执行C语言库行数printf，输入参数

  - C语言库函数整理和添加部分需要的参数（对printf要添加字符大小等参数），调用系统调用

    _syscall3(int, write, int, fd, const char* buf, off_t, count) 

    实际上的系统调用是

    int write(int fd, const char* buf, off_t count)

  - 系统调用_syscall3包含嵌入汇编代码 int 0x80

    当执行int 0x80的时候，程序还处于用户态，在之后会陷入内核态。在head.s的时候调用main.c进行初始化的时候有一个sched_init()初始化函数，他会设置中断函数入口。sched_init()函数会设置GDT[0x80]的DPL=3，同时设置IDT[0x80]的高四位为8，第四位为system_call的中断函数入口地址的偏移量。这样可以通过CS：IP=8:system_call的偏移获得中断函数地址。当执行int 0x80的时候会检查到GDT[0x80].DPL>CPL，从而int 0x80可以被执行，然后int 0x80获取到IDT[0x80]的高四位和第四位组成8:system_call偏移得到中断函数地址，发生跳转。这个时候因为CS=0，造成当前CPL=0，从而当前程序会进入内核态执行。

    C语言库函数printf封装了一个包含int 0x80的嵌入汇编代码，这个嵌入汇编代码是在内核态执行的，他在执行第一个嵌入汇编代码的时候就陷入内核态了

    这个嵌入汇编代码主要内容

    ```
    int 0x80
    : %a(_res)              //执行int 0x80的返回，把eax赋值给_res，_res是C语言定义的返回变量
    : ""(_NR_NAME)          //_NR_NAME在print调用里会变成_NR_WRITE，而_NR_WRITE是系统调用号，_NR_WRITE=4，
    						//本行代码会把系统调用号送到eax寄存器
      ...                   //其他寄存器的赋值
    ```

  - 系统陷入内核后执行中断处理函数，其中系统调用号是4. system_call函数主要内容是通过系统调用号从_sys_call_table表中获取系统调用函数，从而调用这个系统调用函数执行。

    ```
    call _sys_call_table(,%eax, 4) //系统调用处理函数入口为_sys_call_table+4*%eax，调用这个处理函数,4代表函数指针								   //大小
    
    其中_sys_call_table是系统调用表，是一个全局变量，他是一个方法指针数组
    fn_ptr sys_call_table[]={
    	sys_setup, sys_exit, sys_fork, sys_read, sys_write,...
    }
    
    在我们的print函数中，他会使用系统调用表的第4项，也就是sys_write
    那么call _sys_call_table(,%eax, 4)实际上就是call sys_write
    这样就会调用系统调用函数sys_write继续执行
    ```

4. 计算机操作系统五个模块

   CPU管理（进程调度）

   内存管理

   IO管理

   磁盘管理

   文件管理

   **操作系统怎么管理不同设备各个模块**

   在操作系统初始化的时候会建立各个设备的初始化数据结构，比如管理内存的Mem_map；然后使用shell等待用户程序调用系统调用使用设备。

**操作系统实验**

- [Linux操作系统源码和实验环境配置](https://blog.csdn.net/qq_42518941/article/details/119756521)

- 缺失动态链接库的库文件查找方法

  ```
  sudo apt-file search libstdc++.so.6
  使用apt-file查找到动态链接库的库文件名称
  然后
  sudo apt-get install libstdc++6:i386
  安装，其中:i386表示是32位版本号的库文件libstdc++6
  ```

- [哈工大Linux操作系统实验详细注释](https://hoverwinter.gitbooks.io/hit-oslab-manual/content/sy1_boot.html)

- 课程大纲

  ```
  操作系统之基础
  L1 什么是操作系统
  L2 开始揭开钢琴的盖子
  L3 操作系统启动
  L4 操作系统接口
  L5 系统调用的实现
  L6 操作系统概述
  L7 操作系统历史
  L8 我们的任务
   
  操作系统之进程与线程
  L9 多进程图像
  L11 用户级线程
  L12 核心级线程
  L13 核心级线程实现实例
  L14 CPU调度策略
  L15 一个实际的schedule函数
  L16 进程同步与信号量
  L17 对信号量的临界区保护
  L18 信号量的代码实现
  L19 死锁处理
  
  操作系统之内存管理
  L20 内存使用与分段
  L21 内存分区与分页
  L22 段页结合的实际内存管理
  L23 请求调页内存换入
  L24 内存换出
  
  操作系统之外设与文件系统
  L25 IO与显示器
  L26 键盘
  L27 生磁盘的使用
  L28 用文件使用磁盘
  L29目录与文件系统
  L30 目录解析代码实现
  ```

- 资料

  [操作系统实验手册](https://hoverwinter.gitbooks.io/hit-oslab-manual/content/sy1_boot.html)

  [操作系统实验手册](https://blog.csdn.net/leoabcd12/article/details/122268321)

  [王道考研]([王道考研操作系统复习笔记_壹～的博客-CSDN博客_操作系统王道考研笔记](https://blog.csdn.net/weixin_45604295/article/details/122858800?utm_source=app&app_version=5.0.1&code=app_1562916241&uLinkId=usr1mkqgl919blen))

  [添加Linux系统调用]([【Linux内核源码分析】操作系统实验 ：向Linux内核增加一个系统调用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/435297367))

  [Linux内核解析]([Linux0.11内核剖析–内核体系结构 - 走向全栈的MasterHan - 博客园 (cnblogs.com)](https://www.cnblogs.com/HanBlogs/p/5858895.html))

  [Linux课程]([操作系统原理与实践_Linux - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/courses/115))

## 汇编实验

### 基础知识

1. 每一个微处理器CPU都有自己的机器语言，他是01字符串，汇编语言是机器语言的助记符，汇编程序编程机器语言程序要经过编译器编译和链接器链接得到机器语言程序。

2. 存储器的最小存储单元是字节，一个字节由8位二进制位，用两个十六进制数表示。存储单元从0开始编号

3. CPU管脚和总线连接，CPU总线有三种，一种是地址总线，决定CPU寻址能力，CPU寻址大小是 
   $$
   2^N B
   $$
   也就是2的N次幂那么多的字节，每个存储单元是一个字节。8086CPU的地址总线宽度是20，他可以寻址1MB内存，他的地址空间大小是1MB。

   CPU的数据总线决定了CPU与其他组件交换数据时一次传输数据量的大小，CPU总线是8的倍数，因为一次传输数据量是以一个存储单元为单位，一个存储单元的大小是一个字节，是8位。8086CPU数据总线是16位，也就是他的数据寄存器大小是一个字，是2个字节，是两个存储单元，用4个16进制数表示。

   CPU的控制总线决定了CPU对系统中其他器件的控制能力。

4. 基础知识题目

   1. 一个CPU寻址能力是8KB，也就是
      $$
      2^3*2^{10}=2^{12} B
      $$
      

      也就是他的地址总线宽度是12

   2. 1KB的存储器有1024个存储单元，编号从0到1023，有1024x8个bit，有1024个Byte

   3. 数据和指令都是以二进制数的形式存储在RAM或者ROM中，用16进制表示。

   4. 一个存储单元大小是一个字节，有8位，用两个16进制数表示。

      一个字是16位，两个字节，两个存储单元，用4个16进制表示

5. CPU通过地址总线、数据总线和控制总线和其他器件相连，CPU在控制他们的时候都把他们当成内存来控制。CPU地址空间被划分为主存RAM地址空间、BIOS ROM地址空间、显存ROM地址空间和显存RAM地址空间、万卡地址空间等。鼠标键盘等通过接口连接到CPU的地址空间，接口号也是一个地址空间。每个外部设备都占据CPU的一段地址空间，CPU通过读写这些地址空间从而控制这些期间活动。当然这些地址空间被读写之后需要被扩展插槽上的接口卡程序处理。

6. 8086CPU给出物理地址的方法

   8086CPU地址总线是20，有1MB寻址空间能力，他的寄存期宽度是16，他寻址需要两个寄存器，一个是段寄存器，一个是段内偏移寄存器CS：IP，8086CPU要寻物理地址，先将CS：IP送到地址加法器相加得到一个20位的地址，然后这个20位地址被送入地址总线寻址。CPU把CS：IP指向的物理空间的数据当成命令处理

   一个物理地址可以通过不同的CS：IP合并而成，地址加法器的运算规则是**物理地址=段基址*16+段偏移**，相当于把段基址左移四位之后加上段偏移。8086CPU物理地址有20位，用5个16进制数表示。

   内存并没有分段，分段来自CPU，段的大小不固定，最大是2的16次方，也就是8KB

7. 关于CPU分段的题目

   8086CPU给定段地址0001H，仅仅变化偏移地址寻址，则CPU寻址范围是0001Hx16+0=00010H到0001Hx16+FFFFH=00010+FFFF=1000FH

   8086CPU寻址20000H存储单元，给出的CS最小是CS*16+FFFF=20000H，也就是10001右移一位，向上取大变成1001；给出的CS最大时CS\*16+0=20000H，CS=2000H
   
8. 寄存器的高位存放的在内存高地址空间，也就是B8 22 66中数据时6622H，66在内存高地址空间。

9. CPU通过主板的扩展插槽连接其他期间，包括内存条（主存）、磁盘（外存）、网卡、鼠标键盘等。每个设备都有对应的接口卡程序来处理CPU写入的数据，或者返回数据，或者处理CPU写入的数据。

10. 进制转换

   > 十六进制转十进制
   > $$
   > 1001H=2^0*2^{12}+2^0*2^0
   > $$
   > 二进制转十六进制
   > $$
   > 0001 0000 0000 0001 = 1001H
   > $$
   > 十进制转十六进制
   > $$
   > 1024=2^{10}=2^2*2^8=400H
   > $$
   > 

11. 十六进制加减

    > $$
    > 123B9H-123B0H+1=10
    > $$
    >
    > 

12. 机器语言编程是直接面向CPU寄存器和CPU地址空间编程，直接处理计算机底层的寄存器和存储资源。汇编语言、机器语言更加高效的原因在于他们直接面对寄存器和内存编程，减少了很多高级语言的特性，比如Java和GO语言的垃圾回收机制，需要额外的复杂度取检查和清除垃圾，而这在汇编语言不存在垃圾清除，用户自己在心中构建内存结构并且读写，而不需要程序来控制内存结构的。

13. Debug的使用

    >r：查看、改变寄存器的值
    >
    >d: 查看内存内容     e: 改变内存内容
    >
    >u: 将内存机器指令翻译成汇编指令
    >
    >t: 执行一条机器指令   a: 用汇编的格式向内存写入一条机器指令
    >
    >
    >
    >r cx  查看寄存器cx
    >
    >d 1000:0001 000f 查看10001到1000f的存储单元，如果缺失000f就显示从10001开始的128个存储单元
    >
    >e 1000:0001 修改10001号存储单元数值，如果时ROM修改不成功
    >
    >t 执行一条指令，首先要r cs和r ip修改cs:ip指向的地址
    >
    >a 1000:1 从10001开始写汇编指令
    >
    >
    >
    >8086CPU 分配给ROM存放ROM生产日期的内存地址在fff0:00f5到fff0:00fc，这个日期使用e无法修改
    >
    >

​		debug的d指令显示内存数据，只能显示ASCII字符，如果不是ASCII字		符，那么就会显示一个点	

  	  8086CPU 主存地址空间分配00000到9FFFF的640K，显存地址空间从		A0000到BFFFF的128K地址空间

​        内存存放数据，搞位在低地址单元，低位在低地址单元

14. 使用汇编语言编写和执行程序的过程

    > 找一块地址空间输入数据（例如 e 0：0），并且记住每个数据的地址
    >
    > 找一块地址空间输入指令（例如 a 0：0），注意指令空间和数据空间不要重合，注意地址空间应该是主存空间，而不是显存空间或者ROM空间。注意要在指令中使用mov ds, ax来修改数据段的地址，以此来指定数据段
    >
    > 修改指令寄存器（rcs和rip）指向指令空间的第一个地址
    >
    > 使用t一条指令执行

15. 8086CPU将程序划分3个段，这三个段时代码段、数据段和栈段，每个段使用响应的寄存器进行标记。

    > CS:IP指向代码段，debug可以通过rcs和rip更改CS和IP，汇编程序可以通过jmp 1000:0更改CS:IP或者jmp ax更改IP而不改变CS
    >
    > DS:[立即数] 指向数据段，可以通过mov、add、sub操作内存数据
    >
    > SS:SP 指向栈段，是栈的栈顶地址，可以通过pop和push操作SP

16. 操作的数据的长度
    - 有寄存器的指令，寄存器长度确定数据长度，如add ax,10
    - 没有寄存器的指令需要用word ptr或者byte ptr给定数据的长度，比如mov word ptr [bx],10
17. 8086CPU数据长度只有两种，字节db或者字dw，有一个编译器使用的伪指令双字dd

### 寄存器

8086CPU地址总线宽度20，可以寻址1MB内存，地址空间大小1MB；数据总线16位，决定了他的寄存器宽度是16位，也就是一个字，也就是2个字节，也就是一次传输1个字，2个字节，用4位16进制数表示。8086CPU有14个寄存器，其中，

**通用寄存器**是AX、BX、CX、DX，用来存储一般数据，每个通用寄存器都可以分为两个8位小的寄存器，分为高八位和低八位寄存器，AH/AL，BH/BL，CH/CL，DH/DL

**段寄存器**包括CS、DS、SS、ES。其中CS是指令段，他结合IP寄存器得到指令的地址；DS是数据段，他结合偏移[0]获得数据地址；SS是栈段地址，他结合SP指向栈的栈顶地址；ES是空闲的段地址

#### 赋值指令(修改寄存器的值)

- 通用寄存器赋值

  ```
  mov ax,8   //立即数赋值给ax寄存器
  mov ax,bx  //寄存器bx的数值赋值给ax寄存器
  ```

- 段寄存器赋值

  ```
  //8086CPU读取数据和读取指令使用的不同寄存器
  
  //指令段寄存器CS，结合偏移IP给出指令的内存地址
  jmp 2AE3:3 //执行之后CS=2AE3, IP=0003
  jmp ax, //只会修改IP寄存器数据为ax的值，而CS不变化
  
  //数据段寄存器DS，结合偏移[0]给出数据的内存地址
  mov bx,0000
  mov ds,bx
  mov ax,[0] //读取0:0号字
  mov [0],ax //将ax数据存入0:0号字
  
  //栈段寄存器SS，结合SP给除栈顶地址
  mov ax,1000
  mov ss,ax
  ```
  

#### mov add sub 指令

```
mov/add/sub 寄存器，数据
mov/add/sub 寄存器，寄存器
mov/add/sub 寄存器，内存单元
mov/add/sub 内存单元，寄存器
mov 段寄存器，寄存器
```

#### 栈操作pop和push

```
push/pop 通用寄存器/段寄存器/内存单元
```

8086CPU没有检查是否栈溢出的机制，需要用户程序自己检查是否栈溢出。栈溢出包括空栈使用pop或者满栈使用push。

```
push操作过程
1. sp=sp-2
2. 写入数据
push操作数据向低地址空间增长

pop操作过程
1. sp=sp+2
2. 写入数据
pop操作数据向高地址空间增长

8086CPU没有栈溢出检测机制，需要用户自己检查是否栈溢出，这显示出操作系统的作用，省去了用户程序自己检查是否栈溢出的内存管理

使用10000到1000F这16个字节8个字作为栈，初始化SS=1000，初始化栈顶SP=10，因为没有元素的栈顶是10，而有一个元素的栈顶是E。满栈的时候SP=0.每次出栈和入栈的时候操作的是一个字。

任何时刻，SS:SP指向栈顶元素

8086CPU只能改变栈顶指针SP，所以栈的大小最多是64KB
```

**使用栈交换寄存器值的程序**

```
//使用1000:0到1000:F作为栈空间，则空栈SP=10，满栈SP=0
mov ax,1000
mov ss, ax 
mov sp, 10  //构造栈顶指针用三句话
mov ax,10
mov bx,20
push ax
push bx
pop ax
pop bx
```

**使用栈逆序将内存中的数据保存到另外一个内存块**

```
//数据段在1000:0 01 00 02 00 03 00
//栈段在2000:0到2000:F，设置SP=10
//代码段在3000:0开始的地方

mov ax,1000
mov ds,ax //构造数据段
mov ax,2000
mov ss,ax
mov sp,10 //构造栈段和栈顶地址，在执行mov ss,ax的时候mov sp,10跟				着被执行
push [0]
push [2]
push [4]
pop [0]
pop [2]
pop [4]
//从上面程序我们看出，汇编语言没有类型的概念，那么也就没有数据类型不同位的概念，汇编里面只有字节和字的概念，所有数据都是一样的字节或者字，那么对于不同类型的数据的支持，就需要我们使用高级语言如C上面构造类型，然后不同类型使用不同的指令完成类型操作，比如要入栈一个long类型，他是在16位寄存器是4个字节数据，也就是两个字，那么要存储一个int数据，就需要push或者pop两次，或者在内存中mov两次
```

### 汇编程序编写和执行过程

1. 编写成源程序

   源程序伪指令，用于编译器编译的一些代码

   - code segment 和code ends，标记一个代码段开始和结束，code这个段后面编译连接成为一个地址，标记段的开始
   - end，标记整个汇编程序结束
   - assume，将段和CPU段寄存器关联

2. 编译和连接成exe可执行程序，里面包括数据和代码，以及程序描述信息

3. 操作系统（DOS的shell程序）将exe程序加载到内存并且设置cs:ip执行程序（这时shell程序失去CPU）

   使用debug temp.exe可以让debug加载temp程序到内存

   ![屏幕截图 2022-05-10 194207](C:\Users\cheng\Desktop\JavaBackend\屏幕截图 2022-05-10 194207.png)

   其中，cx保存代码长度，自动分配代码段在076A:0000，自动分配数据段在075A，自动分配栈段在0769:0000

   debug装载程序，从SA开始加载256K的PSP程序，然后在SA*16+0+256=SA+10H:0开始的地方加载用户程序

   注意在debug中要用p指令执行int 21，而不是t指令

   在debug的汇编程序中，mov ax,[0]中0会被单程ds的偏移地址ds:0

   而在masm中，mov ax,[0]的0会被当成数字，也就是ax=0

   如果要在masm中实现[0]被当成地址，只有使用寄存器bx=0,mov ax,[bx]

#### Loop指令（循环）

loop指令使用cx寄存器保存循环的次数。

**执行2*3**

```
// 执行2*3
assume cs:codeseg
codeseg segment
	mov ax,0H

	mov cx,3H
s:     add ax,2H
	loop s
	
	mov ax,4c00H
	int 21H
codeseg ends
end
```

**执行在2000:0开始的64个字节写入0到64**

```
//执行在2000:0开始的64个字节写入0到64
assume cs:codeseg
codeseg segment
	mov ax,2000H
	mov ds,ax

	mov cx,64
	mov bx,0
s:  	mov ds:[bx],bl
	inc bx
	loop s	

	mov ax,4c00H
	int 21H
codeseg ends
end
```

使用g cs:e 可以直接执行到指定的行，而不用t单步执行

#### 具有数据段、栈段、代码段的完整程序

**反转数组**

```
assume ds:dataseg,ss:stackseg,cs:codeseg

dataseg segment
	dw 1234H,4567H,6789H
dataseg ends

stackseg segment
	dw 0,0,0
stackseg ends

codeseg segment
start:	mov ax,dataseg		;start标记主程序地址入口
	mov ds,ax			;构造数据段地址

	mov ax,stackseg
	mov ss,ax
	mov sp,10H			;构造栈段地址

	mov cx,3
	mov bx,0
s0:	push [bx]
	add bx,2
	loop s0			;入栈
	
	mov cx,3
	mov bx,0
s1:	pop [bx]
	add bx,2
	loop s1			;弹栈

	mov ax,4c00H
	int 21H
codeseg ends

end start				;end start可以标记主程序入口地址
```

#### 多维数组的寻址方式

bx、si、di和立即数都可以用来多维数组寻址，他们可以相互组合[bx+si+立即数]

当处理多维数组需要嵌套循环的时候，因为循环只有cx可以当作计数器，所以我们要保存外部循环的cx，保存外部循环的cx一种方式是在内存中自己找一块空间，另外一种是使用栈来保存cx，推荐用栈，因为这样减少出错可能。

> 8086CPU只有四种寄存器bx、bp、si、di可以放到方括号里面进行内存寻址
>
> 其中组合方式也是固定的，只有下面的几种方式
>
> 1. 立即数寻址，数据段地址ds给出
>
>    [立即数]
>
> 2. 寄存器间接寻址，数据段地址ds给出
>
>    [bx]
>
>    [bp]
>
>    [si]
>
>    [di]
>
> 3. 寄存器相对寻址
>
>    - 用于结构体[bx].idata，一维数组idata[bx]，二维数组\[bx][idata]，数据段地址ds给出
>
>      [bx+立即数]
>
>      [si+立即数]
>
>      [di+立即数]
>
>    - 段地址ss给出
>
>      [bp+立即数]
>
> 4. 基址变址寻址
>
>    - 用于二维数组\[bx][si]，数据段地址ds给出
>
>      [bx+si]
>
>      [bx+di]
>
>    - 短地址栈段地址给出ss
>
>      [bp+si]
>
>      [bp+di]
>
> 5. 相对基址变址寻址
>
>    - 用于包含结构体的二维数组[bx].idata[si]，短地址ds给出
>
>      [bx+si+立即数]
>
>      [bx+di+立即数]
>
>      [bp+si+立即数]
>
>    - 短地址ss给出
>
>      [bp+di+立即数]

**将二维数组的字符串改成大写**

```
assume cs:codeseg,ds:dataseg,ss:stackseg

dataseg segment
	db 'abcd'
	db 'efgh'
	db 'igkl'
dataseg ends

stackseg segment
stackseg ends

codeseg segment
start:mov ax,dataseg
	mov ds,ax

	mov ax,stackseg
	mov ss,ax
	mov sp,16

	mov cx,3
	mov bx,0  		; for(bx=0;bx<3;...)
s0:	push cx
	mov cx,4		; for(si=0;si<3;...)
	mov si,0
	
s1:	mov al,[bx+si]
	and al,11011111B	;将小写转成大写用这个命令，将大写转成小写用
				;or al,00100000B
	mov [bx+si],al
	add si,1		; si+1，这里就是加一
	loop s1

	pop cx		;外层循环的cx保存在栈里面
	add bx,4		; bx+1,加一实际加的是数组的长度
	loop s0

	mov ax,4c00H
	int 21H
	
codeseg ends

end start
```

#### 使用结构体

```
assume cs:codeseg,ds:dataseg

dataseg segment
	db 3 dup(0,'abc',0)
dataseg ends

codeseg segment
start:mov ax,dataseg
	mov ds,ax
	
	mov cx,3
	mov bx,0

s0:	mov si,1
	mov al,[bx+si+1]
	and al,11011111B
	mov [bx+si+1], al ;修改结构体的第二项的第二个字符

	add bx,5
	loop s0

	mov ax,4c00H
	int 21H
codeseg ends

end start
```

### 转移程序

8086CPU转移指令有五类

- 无条件转移指令（jmp）
- 条件转移指令
- 循环指令（loop）
- 过程（函数调用）
- 中断

#### 转移指令原理

**转移行为有两种**

- 只修改IP，成为段内转移
  - 段内段转移，IP修改范围-128到127，也就是8位数据
  - 段内近转移，IP修改范围-32768到32767，也就是16位数据
- 同时修改CS和IP，称为段间转移

**段内转移原理**

- 段内短转移jmp short 标号

  程序执行到jmp short 标号过程

  1. IP指向jmp short 标号指令，传入指令寄存器IR
  2. IP加上IR指令长度，从而指向下一条指令
  3. CPU执行IR内指令，跳转到标号的位置，执行标号位置的指令

  上述的过程jmp short 标号指令被编译器编译的时候没有给出标号的目的地址，而是给出了标号到**jmp short 标号**这条指令的下一条指令地址的偏移量，这个偏移量范围是8位数据，计算这个偏移量的过程是编译器完成的。比如编译器编译得到EB03，03表示的就是偏移量。

- 段内近转移jmp near ptr 标号

  同上述一样，段内近转移的区别在于偏移量范围是16位数据

**段间转移原理**

段间转移的转移指令会直接给出目的地址

- jmp dword ptr ds:[0]

  ds:[0]字单元给出转移偏移地址IP

  ds:[2]字单元给出转移段地址CS

- jmp far ptr 标号

  转移的段地址和偏移地址是标号所在的段地址和偏移地址

**段间转移题目**

- 使用loop实现循环

  loop时段内短转移

```
assume cs:codeseg

codeseg segment
start:mov cx,3
	mov ax,0
s0:	add ax,1
	loop s0

	mov ax,4c00H
	int 21H
codeseg ends

end start
```

- 使用jmp far ptr 标号实现循环

  ```
  assume cs:codeseg
  
  codeseg segment
  start:mov ax,0
  s0:	add ax,1
  	jmp far ptr s0
  
  	mov ax,4c00H
  	int 21H
  codeseg ends
  
  end start
  ```

- 使用jmp dword ptr ds:[0]实现循环

  ```
  assume cs:codeseg, ds:dataseg
  
  dataseg segment
  	dd	0
  dataseg ends
  
  codeseg segment
  start:
  	mov ax, dataseg
  	mov ds, ax		;构造数据段
  	mov ax, offset s0	;伪指令offset获得标号在代码段的偏移
  	mov ds:[0], ax  	;偏移
  	mov ds:[2], cs	;代码段段地址
  	
  	mov cx,3
  	mov ax,0
  s0:	add ax,1
  	
  	jcxz ok		; jcxz是段内段转移，他表示cx=0时跳转到标号位置
  	jmp dword ptr ds:[0]
  
  ok:	mov ax,4c00H
  	int 21H
  codeseg ends
  
  end start
  
  ```

**注意事项**

编译器会对转移偏移越界报错，如果loop，jcxz，jmp short发生标号超过范围，将会报编译器错误。

### 8086CPU显示器的地址空间

8086CPU显示器地址空间在B8000H到BFFFFFH这32KB的空间。

一共时25行，每行80个字符，每个字符包含ASCII码和字符属性，25x80x2=4000B。一共有8页，显示器可以显示任意一页，一般显示低0页，也就是地址在B8000H到B8F9FH这个地址空间。

**向显示器缓冲区输入的程序**

```
assume cs:codeseg, ds:dataseg

dataseg segment
	db 160 dup(41H,11001010B)	;41H是字符A，caH是字符属性，红底								 绿字闪烁
dataseg ends

codeseg segment
start:
	mov ax,0B800H	;要加0才能识别16进制，显示器缓冲区的段地址
	mov es,ax
	mov ax,dataseg
	mov ds,ax

	mov cx,160
	mov bx,0
s:	mov ax,ds:[bx+0]
	mov es:[bx+0],ax
	add bx,2
	loop s

	mov ax,4c00H
	int 21H
codeseg ends

end start
```

###  汇编调用子程序设计（模块化程序设计）

#### call指令

**call 标号**

push ip

jmp near ptr 标号

**call far ptr 标号**

push cs

push ip

jmp far ptr 标号

**call 16位reg**

push ip

jmp 16位reg

**call word ptr 内存单元**

push ip

jmp word ptr 内存单元

**call dword ptr 内存单元**

push cs 

push ip

jmp dword ptr 内存单元

#### ret指令

**ret指令相当于执行了**

pop ip

**retf指令相当于执行了**

pop ip

pop cs

**使用栈实现call和ret指令**

```
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
assume cs:codeseg, ds:dataseg, ss:stackseg

dataseg segment
	db 160 dup(41H,11001010B)
dataseg ends

stackseg segment
	db 16 dup(0)
stackseg ends

; 实现2x3
codeseg segment

main:	mov ax,dataseg
	mov ds,ax
	mov ax,stackseg
	mov ss,ax
	mov sp,16

	mov ax,2
	mov cx,3
	call s

	mov ax,4c00H
	int 21H

s:	add ax,2
	loop s
	ret				;子程序结果保存在ax寄存器

codeseg ends

end main


;;;;;;;;;;;;;;;;;;;使用栈实现

assume cs:codeseg, ds:dataseg, ss:stackseg

dataseg segment
	db 160 dup(41H,11001010B)
dataseg ends

stackseg segment
	db 16 dup(0)
stackseg ends

; 实现2x3
codeseg segment

main:	mov ax,dataseg
	mov ds,ax
	mov ax,stackseg
	mov ss,ax
	mov sp,16

	mov ax,2
	mov cx,3
	
	;使用栈实现call
	push cs
	mov bx,offset ip	;ip为call执行的下一条指令入栈
	push bx
	jmp far ptr s

ip:	mov ax,4c00H
	int 21H

s:	add ax,2
	loop s

	mov dx,ss
	mov ds,dx
	mov bx,sp
	jmp dword ptr ds:[bx]  ;按双字跳转

codeseg ends

end main
```

#### 参数传递

1. 寄存器传递
2. 内存传递（使用ds段指向传递的内存地址）
3. 栈传递（使用ss指向传递的参数的栈），此外，栈还用于保存调用子程序的主程序的参数。

**二维字符串转大写**

- 使用cx和jcxz遍历字符串
- 保存主程序寄存器cx到栈

```
assume cs:codeseg, ds:dataseg, ss:stackseg

dataseg segment
	db	'abcd',0
	db	'cdef',0
dataseg ends

stackseg segment
	db 16 dup(0)
stackseg ends

codeseg segment
main:	mov ax,dataseg
	mov ds, ax
	mov ax, stackseg
	mov ss, ax
	mov sp, 16
	
	mov cx,2
	mov bx,0

loops:	
	call change
	add bx,5
	loop loops
	
	mov ax,4c00h
	int 21h

change:
	push cx		;保存主程序变量cx

	mov si,0
changeLoop:
	mov ch,0
	mov cl,ds:[bx+si]
	jcxz changeReturn
	mov al, ds:[bx+si]
	and al,11011111B
	mov ds:[bx+si],al
	add si,1
	jmp changeLoop

changeReturn:
	pop cx
	ret
	
	
codeseg ends

end main
```

#### 调用子程序输出到显示缓冲区

```
assume cs:codeseg, ds:dataseg

dataseg segment
	db 'Welcom to China',0	;
dataseg ends

codeseg segment
start:
	mov ax,0B800H	;要加0才能识别16进制，显示器缓冲区的段地址
	mov es,ax		;显示缓冲区地址
	mov ax,dataseg
	mov ds,ax
	call show

	mov ax,4c00h
	int 21h

show:	
	mov bx,0
	
	mov si,0
showLoop:
	mov ch,0
	mov cl,ds:[si]
	add si,1
	jcxz showReturn
	mov es:[bx+1124],cl
	mov byte ptr es:[bx+1+1124],11001010B
	add bx,2
	loop showLoop	

showReturn:
	ret
codeseg ends

end start
```

#### 将12306输出到屏幕

```
assume cs:codeseg,ss:stackseg,ds:dataseg

dataseg segment
	db 10 dup(0)
dataseg ends

stackseg segment
	db 16 dup(0)
stackseg ends

;将12306输出到屏幕
;首先获取12306的十进制数数字的编码，再加上30H得到十进制数的字符的编码
;然后把十进制数字的字符输出到屏幕
codeseg segment
start:	
	mov ax, stackseg
	mov ss, ax
	mov sp, 16

	mov ax, dataseg
	mov ds, ax

	mov word ptr ds:[0], 10

	mov bx,0
	call divtrans	;调用获取12306的每位字符保存到栈，
				;寄存器传递参数，
				;包括数字bx=12306，栈ss:sp，记录字符个数bx
				;返回数据
				;包括bx表示记录字符个数，栈指针ss:sp
	mov ax,4c00H
	int 21H

divtrans:
	mov ax,12306
	mov dx,0

divtransLoop:
	div word ptr ds:[0]
	
	add dx,30H  ;加上30H是把十进制数字符变成数字字符
	push dx
	add bx,1
	mov cx,ax
	jcxz divtransReturn
	mov dx,0

	jmp divtransLoop

divtransReturn:

;show显示，传递参数栈，计数bx
show:	
	mov ax,0B800H	;要加0才能识别16进制，显示器缓冲区的段地址
	mov es,ax		;显示缓冲区地址

	mov cx,bx
	mov bx,0
showLoop:
	pop ax
	mov es:[bx+1124],al
	mov byte ptr es:[bx+1+1124],11001010B
	add bx,2
	loop showLoop


	ret
	

codeseg ends

end start
```

#### 标志寄存器

- ZF，零标志位，判断算术指令或者逻辑指令结果是否为0，如果为0，则ZF=1，否则，ZF=0.算术指令和逻辑指令包括sub\add\mul\div\inc\or\and等，传送指令mov\push\pop不影响ZF
- PF，奇偶标志位，判断运算结果中1的个数是否为奇数
- SF，符号标志位，表示数字的正负
- CF，进位标志位
- OF，溢出标志位

**标志寄存器的作用-用于条件转移指令**

比如cmp 8,3; 则ZF=0，CF=0等，条件操作影响标志位

**cmp配合指令完成条件转移**

| 指令 | 含义                     | 检测标志位 |
| ---- | ------------------------ | ---------- |
| je   | 等于就跳转               | zf=1       |
| jne  | 不等于就跳转             | zf=0       |
| jb   | 小于就跳转               | cf=1       |
| jnb  | 不小于就跳转（大于等于） | cf=0       |
| ja   | 大于就跳转               | cf=0且zf=0 |
| jna  | 不大于就跳转（小于等于） | cf=1或zf=1 |

- DF，方向标志位，串传送指令控制si和di增长的方向，配合rep movsb或者rep movsw使用

  - 当DF=0，正向增长，如果是rep movsb，那么si+1,di+1,如果rep movsw，那么si+2,di+2
  - 当DF=1，福祥增长，如果是rep movsb，那么si-1,di-1, 如果是rep movsw，那么si-2,di-2

  **使用方向标标志位复制字符串**

  ```
  assume cs:codeseg, ds:dataseg
  
  dataseg segment
  	db 'Welcom to China'
  	db 15 dup(0)
  dataseg ends
  
  ; cld 设置df=0
  ; std设置df=1
  codeseg segment
  start:	
  	mov ax, dataseg
  	mov ds, ax
  	mov si,0
  	mov es, ax
  	mov di,15		;将ds:si处的字符复制到es:di处，DF控制增长方向
  	mov cx,15		;复制字符个数
  	cld
  	rep movsb
  
  	mov ax,4c00H
  	int 21h
  codeseg ends
  
  end start
  ```

- pushf和popf，将标志寄存器压栈和弹栈

### 内中断

中断时CPU执行过程中因为系统发生了某些时间而不得不暂停当前程序转而执行其他程序的过程。

中断类型码标识中断来源，中断处理程序是发生中断时执行的处理程序，中断类型码和中断处理程序通过中断向量表进行映射。中断向量表按双字保存了中断处理程序的段地址和偏移地址CS:IP，中断类型码是字节型数据，有256种来源，每个有4个字节两个字标识一个中断处理程序起始地址，那么中断向量表大小
$$
2^8*2^2=2^{10}=1KB
$$
8086CPU中断向量表大小1KB

**中断过程**

- 取得中断类型码N

- pushf标志寄存器入栈

- TF=0，IF=0，设置标志寄存器的TF和IF位

- push cs

- push ip

- mov ip, 0:[4*N], 

  mov cs, 0:[4*N+2]

**Debug单步中断**

Debug使用了8086CPU的单步中断，8086CPU当TF=1时会发生单步中断，单步中断中断类型码是1。使用t触发单步中断，但是进入的时候要设置TF=0，否则中断处理程序执行完成之后返回主程序发现TF=1就会又触发中断

**不响应中断的情况**

一些情况需要原子操作，比如mov ss,ax, mov sp,16，这两个指令要一起操作指向栈顶，不能分开，这样在执行这两个指令的时候不会响应中断。

**编写一个中断**

编写函数使用call ret两个指令，编写中断使用int iret执行

int过程：

- pushf
- TF=0,IF=0
- push cs
- push ip
- 重新设置cs和ip

iret过程

- pop ip
- pop cs
- popf

编写一个中断主要包括三个方面的内容

- 将中断处理程序加载到内存模块
- 设置中断向量表模块（8086CPU中断向量表时0起始1KB的内存空间）
- 编写中断处理程序（一个普通程序）

使用中断int iret可以从栈中获得陷入中断的主程序入口地址

**编写一个中断8c，中断处理程序保存在0:200H开始的位置**

- 使用了串传送指令

```

;编写一个中断8c，中断处理程序保存在0:200H开始的位置。
;
assume cs:codeseg	

codeseg segment

;装载中断处理程序到内存
;设置中断向量表
main:
	mov ax,0
	mov es,ax
	mov di,200H
	
	mov ax,cs
	mov ds,ax
	mov si,offset int0

	mov cx,offset int0End-offset int0
	rep movsb		;上面的程序用来装载中断处理程序到0:200开始的位置

	mov bx,0230H
	mov ax,0
	mov es,ax
	mov word ptr es:[bx+2],0H
	mov word ptr es:[bx+0],0200H	;设置中断向量表，中断号为0230H/4=140=8cH,中断入口程序地址0:0200H

	mov ax,4c00H
	int 21H


int0:	jmp int0Start	;中断处理程序

data:	
	db 'W',11001010B
	db 'e',11001010B
	db 'l',11001010B
	db 'c',11001010B
	db 'o',11001010B
	db 'm',11001010B
	db 'e',11001010B

int0Start:
	mov ax,0B800H
	mov es,ax
	mov di,1124		;设置es:di

	mov ax,cs		;这个cs将会在设置中断向量表和装载中断处理程序中给出，都是cs
	mov ds,ax
	mov si,200H+offset data-offset int0		;设置ds:si,计算si就是数据段的偏移，200H是整个中断处理程序偏移，
											;offset data-offset int0是数据段相对200H偏移
	
	mov cx,7
	rep movsw

	iret
int0End:
	nop

codeseg ends

end main
```

### BIOS启动过程

- 计算机加电时CS:IP自动指向FFFF:0，执行BIOS的系统监测和初始化程序
- BIOS的系统检测和初始化程序会将BIOS的中断例程登记到内存中断向量表中（8086中断向量表在内存0地址处1KB的内存）。BIOS的中断例程不用被加载到内存，因为ROM本身就是内存一部分，但是操作系统在磁盘上，不是内存一部分，需要被加载到内存。
- BIOS系统检测和初始化程序执行完之后，会调用int 19hBIOS中断进行操作系统引导（操作系统存放在磁盘的0地址处，是一个image文件，操作系统引导会提醒选择操作系统的引导项）。
- 启动DOS后，DOS会将操作系统中断例程DOS中断例程加载到内存，并且登记到中断向量表。

#### BIOS中断例程的应用   

BIOS的中断例程包含多个子程序，int 10h时BIOS设置光标的中断

**使用BIOS中断例程设置光标并且在光标处显示字符的程序**

```
assume cs:codeseg	

codeseg segment
main:
	mov ah,2	;ah用来标记10h号中断例程使用的子程序，这里是第二号，第二号子程序设置光标位置
	mov bh,0	;bh用来标记显示的是哪一页，8086CPU显存分为8页，每页是25*80的字符=2000个字符=4000个字节
	mov dh,5	;dh存放行号
	mov dl,12	;dl设置光标列号
	int 10h

	mov ah,9	;9号中断例程子程序是在光标处显示字符的子程序
	mov al,'a'	;显示的字符
	mov bl,11001010b ;设置显示字符的属性
	mov bh,0	;存放页号
	mov cx,3	;字符重复个数
	int 10h		;调用中断处理程序需要使用寄存器或者内存传递参数

	mov ax,4c00h
	int 21h
codeseg ends

end main
```

#### DOS中断例程的应用

**使用DOS中断例程在光标处显示字符串，实现printf**

```
assume cs:codeseg	


dataseg segment
	db 'Welcome to China', '$'	;$在DOS的21h号中断例程的第9个子程序中标记字符串结束
dataseg ends

codeseg segment
main:
	mov ah,2	;BIOS的10号中断例程的2号子程序
	mov bh,0	;传递0页
	mov dh,24	;行号
	mov dl,0	;列号
	int 10h

	mov ax,dataseg
	mov ds,ax
	mov dx,0	;ds:dx指向字符串首地址
	mov ah,9	;DOS的21号中断例程的第9个子程序
	int 21h	;DOS的21号中断例程

	mov ax,4c00h
	int 21h
	
codeseg ends

end main
```

### 端口

8086CPU通过总线（地址总线、控制总线、数据总线）连接存储器，存储器占用CPU内存地址空间，存储器包括主存RAM、ROM、cache、各种器件的RAM和ROM

8086CPU通过总线还连接外部器件的寄存器，这些外部器件寄存器被称为**端口**，CPU也对这些端口进行编址，形成端口地址空间。端口地址空间大小是64KB

读写存储器的命令是mov, push, pop，而读写端口的命令是in, out；读写端口的结果保存到al或者ax寄存器（只有这两个，如果读取8位端口，使用al；如果读取16位端口，使用ax）

**in al, 60h执行过程**

这是一条读取60h号端口的命令，读取的数据存放到al寄存器。

- CPU向地址总线发出60h
- CPU向控制总线发出**端口读**指令，选中60h端口所在寄存器通知他读数据
- 端口所在芯片把数据通过数据总线送入CPU

**mov al, [60h]执行过程**

- CPU像地址总线发出60h
- CPU向控制总线发出**内存读**指令，选中60h所在的存储器并通知他读数据
- 存储器把数据通过数据总线送入CPU

**读取CMOS系统信息端口**

CMOS芯片是主板上芯片，存放系统信息，包括时钟信息，他包含一个128B的存储单元RAM。70h传递访问的RAM地址，71h传递数据，注意不要修改RAM信息，这样会产生系统错误。

**读取月份**

```
assume cs:codeseg	

codeseg segment
main:
	mov al,8	;8号CMOS地址单元存放月份，al的前四个位是月份十位BCD码，后四位是月份个位BCD码
	out 70h,al	;al传递读写端口的数据
	in al,71h	;CPU写入CMOS的70h端口之后CMOS芯片会在71h端口写入数据

	mov ah,al
	mov cl,4
	shr ah,cl	;取al的前四位保存到ah
	and al,00001111b	;取al的后四位保存到al

	add ah,30h
	add al,30h	;十进制BCD码转字符ASCII码是加上30h

	mov bx,0b800h
	mov es,bx
	mov byte ptr es:[24*80*2+0],ah
	mov byte ptr es:[24*80*2+2],al

	mov ax,4c00h
	int 21h

codeseg ends

end main
```

**读取年月日 时分秒**

```
;使用栈传递参数注意事项
;主程序压入传递参数，调用call函数，会把主函数ip或者cs:ip压入栈（根据jmp near或者jmp far确定）
;函数内先把cs:ip或者ip弹出保存到内存，然后按照参数压栈的反向顺序弹出栈，同时保存主程序的一些今存其参数，这些参数在ret之前弹出ip或者cs:ip之前需要恢复。

;这个过程（函数调用过程）的切换实际上很接近进程切换了，函数切换只需要改变cs:ip指向，不改变ds和ss等寄存器指向，也就是函数调用不切换数据段和栈段，一定切换cs:ip，可能改变其他寄存器的数值，因为新程序要用到现在的寄存器，那么就会改变主程序的寄存器数值。用户线程切换只是切换了栈，需要保存栈ss:ip到内存地址


assume cs:codeseg,ds:dataseg,ss:stackseg

stackseg segment
	dw 8 dup(0)
stackseg ends

dataseg segment
	a db 9,8,7,4,2,0
	b dw 2 dup(0)
dataseg ends

codeseg segment

main:
	mov ax,stackseg
	mov ss,ax
	mov sp,16
	
	mov ax,dataseg
	mov ds,ax

	mov cx,6
	mov si,0
s:	mov al,a[si]
	mov ah,0
	push ax
	push si			;使用栈传递参数si和a[si]

	call disp
	add si,1
	loop s

	mov ax,4c00h
	int 21h	

disp:	
	pop word ptr b[0]	;保存程序返回地址，程序ret前重新压栈

	pop si				;传递的参数
	pop ax			

	push cx				;保留主程序寄存器参数，在程序ret压入ip之前要恢复cx

	out 70h,al	;al传递读写端口的数据
	in al,71h	;CPU写入CMOS的70h端口之后CMOS芯片会在71h端口写入数据

	mov ah,al
	mov cl,4
	shr ah,cl	;取al的前四位保存到ah
	and al,00001111b	;取al的后四位保存到al

	add ah,30h
	add al,30h	;十进制BCD码转字符ASCII码是加上30h

	mov bx,0b800h
	mov es,bx

	mov bx,0
	add bx,si
	add bx,si
	add bx,si
	add bx,si

	mov byte ptr es:[24*80*2+bx+0],ah
	mov byte ptr es:[24*80*2+bx+2],al

	pop cx

	push b[0]
	ret

codeseg ends

end main
```

### 外中断

输入输出设备的接口芯片控制输入输出设备的工作，CPU的端口是CPU用来标识输入输出设备接口芯片的寄存器的地址（端口地址空间），CPU和输入输出设备通过端口进行联系。CPU和输入输出设备通过总线（地址总线、控制总线、数据总线）进行连接。

内中断时CPU执行程序引发的，比如int 21h，中断类型码从CPU执行程序内部给出；外中断时外部器件产生的，中断类型码通过数据总线传给CPU。CPU在执行指令之前会检查是否发生中断，如果发生中断，就会跳转到中断处理程序执行。跳转的过程

- 内中断

  从中断源获取中断类型码N

  pushf

  TF=0,IF=0 ，其中TF=0标识CPU处于连续工作状态，而不是单步工作状态，单步工作状态执行一条指令之后会显示寄存器信息并且等待给出下一条地址；IF表示中断处理程序是否可以被中断，sti设置if=1，cli设置if=0.

  push cs， push ip

  设置ip=(N\*4) cs=(N\*4+2)

- 外中断

  外中断分为可屏蔽中断和不可屏蔽中断，根据中断类型码来区分，不可屏蔽中断类型码固定位2

  - 可屏蔽外中断

    可屏蔽中断时CPU可以不响应的中断，几乎所有的外设中断都是可屏蔽中断

    可屏蔽中断执行过程和内中断差不多，只是他的中断类型吗是外设通过数据总线传递的，而不是从程序执行过程获得的

    其次，如果要设置一个中断可以被中断，也就是执行完一条指令之后就跳转到其他中断，那么这个中断处理程序需要设置sti令if=1，那么这个中断处理程序就可以被中断。

  - 不可屏蔽中断

    不可屏蔽中断类型码固定位2，它不需要获取中断类型码。一般时系统紧急时间才会使用不可屏蔽中断，当中断看到一个不可屏蔽中断，那么他必须跳转。而不用关是否if=0

**外中断引发过程，以键盘输入为例**

- 外设输入送入端口。按下键盘，产生扫描码送入端口
- 外设向CPU传递中断信息，引发中断，包括中断类型码。键盘向CPU传递int 9h中断。int 9h中断是BIOS提供的用于处理键盘输入的中断
- CPU在执行一条指令之前检查是否有中断，如果发生中断并且IF=1，那么CPU跳转到中断处理程序执行。设置IF=0实际就是关中断，除非中断处理程序执行完成，否则不会响应中断，除非遇到不可屏蔽中断2h。设置IF使用sti和cli指令

**编写int 9h中断处理键盘输入，引发int 9h中断是由硬件产生的，我们能做的是中断处理程序实现，下面的程序根据输入的F1键更改窗口显示的背景色**

```
;
assume cs:code

stack segment
	db 128 dup(0)
stack ends

code segment
start:
	mov ax, stack
	mov ss,ax
	mov sp,128
	
	push cs
	pop ds

	mov ax,0
	mov es,ax

	mov si,offset int9
	mov di,204h
	mov cx,offset int9end-offset int9
	cld		;设置movsb的增长方向
	rep movsb

;保存int 9h的原来的中断程序的入口地址
	push es:[4*9]
	pop es:[200h]
	push es:[4*9+2]
	pop es:[202h]
	
;原子操作实现修改新的int 9h中断程序入口地址
	cli
	mov word ptr es:[4*9],204h
	mov word ptr es:[4*9+2],0
	sti					;使用cli和sti实现原子操作，通过关中断实现原子操作

	mov ax,4c00h
	int 21h

int9:
	push ax
	push bx
	push cx
	push es

	in al,60h
	
	pushf
	call dword ptr cs:[200h]

	cmp al,3bh
	jne int9ret

	mov ax,0b800h
	mov es,ax
	mov bx,1
	mov cx,2000
s:
	inc byte ptr es:[bx]
	add bx,2
	loop s

int9ret:
	pop es
	pop cx
	pop bx
	pop ax
	iret

int9end:
	nop

code ends
end start
```



**使用栈模拟int 和iret 指令，同理可以模拟call和ret指令**

### 8086CPU指令

#### 数据传送指令

mov,push,pop,pushf,popf

#### 算术运算指令

add,sub,adc,sbb,inc,dec,cmp,imul,idiv,aaa，实现寄存器和内存算术运算，结果影响标志寄存器sf,zf,of,cf,pf,af

#### 逻辑指令

and,or,not,xor,test,shl,shr,sal,sar,rol,ror,rcl,rcr，影响标志位

#### 转移指令

- 无条件转移，jmp
- 条件转移，jcxz，je，jb，ja，jnb，jna
- 循环指令，loop
- 过程，call，ret，retf
- 中断，int，iret

#### 处理机控制指令

设置标志寄存器或者其他CPU状态的指令，cld，std，cli，sti，nop，clc，cmc，stc，hlt，wait，esc，lock

#### 串处理指令

批量处理内存数据，movsh，movsw，cmps，scas，lods，stos，需要结合rep，repe，repne等指令执行串处理



### int 9h和int 16h处理键盘输入

BIOS处理键盘输入指令有两个，一个是int 9h负责把数据存放到键盘缓冲区，键盘缓冲区是BIOS的9h号中断处理程序使用的内存，有16个字单元，可以存放15个按键扫描码和对应的ASCII码。当按下一个键，int 9h中断获取扫描码，检查状态字节，把扫描码转换成相应的ACSII码，然后把扫描码存放到高位，ASCII码存放到低位。

int 16h负责从键盘缓冲区中读取数据，如果键盘缓冲区有数据，那么就读取到ax，其中ah存放扫描码，al存放ASCII码，然后从键盘缓冲区删除这个数据。

int 9h和int 16h配合使用实现键盘输入和处理

**int 16h处理键盘输入**

```
;根据输入r g b来改变背景颜色
;int 16h如果键盘缓冲区为空会忙等待循环直到有数据输出到ax寄存器，然后返回
assume cs:code

code segment
start:
	mov ah,0
	int 16h

	mov ah,1
	cmp al,'r'
	je red
	cmp al,'g'
	je green
	cmp al,'b'
	je blue
	jmp short sret

red:
	shl ah,1
green:
	shl ah,1
blue:
	mov bx,0b800h
	mov es,bx
	mov bx,1
	mov cx,2000
s:
	and byte ptr es:[bx],11111000b
	or es:[bx],ah
	add bx,2
	loop s

sret:
	mov ax,4c00h
	int 21h

code ends
end start
```



**int 16h处理键盘输入**

```
assume cs:codeseg


codeseg segment

charstack: 
	jmp short charstart

table	dw charpush,charpop,charshow	;子程序地址表，保存子程序CS:IP
top	dw 0								;栈顶指针，使用默认ds和si定义空栈栈顶，top表示添加元素之后偏移，加上ds:												;[si+top]之后得到真正内存栈顶指针。用内存top实现一个栈。这个栈要和ss:sp栈区别
										;这个内存栈空间无限大，但是ss:sp栈大小只有16位个字节

charstart:								;根据功能号ah从子程序地址表找到功能程序入口地址执行
	push bx
	push dx
	push di
	push es

	cmp ah,2
	ja sret
	mov bl,ah
	mov bh,0
	add bx,bx
	jmp word ptr table[bx]

charpush:								;压入数据到内存栈
	mov bx,top
	mov [si][bx],al
	inc top
	jmp sret

charpop:								;从内存站弹出
	cmp top,0
	je sret
	dec top
	mov bx,top
	mov al,[si][bx]
	jmp sret

charshow:								;显示内存站数据
	mov bx,0b800h
	mov es,bx
	mov al,160
	mov ah,0
	mul dh
	mov di,ax
	add dl,dl
	mov dh,0
	add di,dx

	mov bx,0

charshows:
	cmp bx,top
	jne noempty
	mov byte ptr es:[di],' '
	jmp sret
noempty:
	mov al,[si][bx]
	mov es:[di],al
	mov byte ptr es:[di+2],' '
	inc bx
	add di,2
	jmp charshows

sret:
	pop es
	pop di
	pop dx
	pop bx
	ret

getstr:
	push ax

getstrs:							;使用int 16h读取键盘缓冲区数据，根据读入char执行对应功能号程序
	mov ah,0
	int 16h
	cmp al,20h
	jb nochar
	mov ah,0
	call charstack
	mov ah,2
	call charstack
	jmp getstrs

nochar:
	cmp ah,0eh
	je backspace
	cmp ah,1ch
	je enter
	jmp getstrs
backspace :
	mov ah,1
	call charstack	
	mov ah,2
	call charstack	
	jmp getstrs

enter:
	mov al,0
	mov ah,0
	call charstack
	mov ah,2
	call charstack
	pop ax
	ret


main:
	call getstr
	
	mov ax,4c00h
	int 21h
codeseg ends
end main
```

### int 13h指令对磁盘读写

3.5英寸磁盘分为上下两面，每面有80个磁道，么个磁道有18个扇区，每个扇区有512B，则3.5英寸磁盘总字节数是
$$
2*80*18*512
$$
BIOS提供int 13h中断例程对磁盘进行读写，要向磁盘控制器传入寄存器参数，包括磁面号、磁道号、扇区号、扇区数、驱动器号等，磁面号、磁道号、驱动器号从0开始编址，扇区号从1开始编址。

**读写磁盘**

```
assume cs:codeseg


codeseg segment
;把内存es:bx处1个扇区写入到磁盘0面0道1扇区开始的地方
main:
	mov ax,0b800h
	mov es,ax
	mov bx,0
	
	mov al,1
	mov ch,0
	mov cl,1
	mov dl,0
	mov dh,0
	mov ah,3	;功能号，写磁盘
	int 13h

;从磁盘读1个扇区到内存es:bx处
	mov ax,0
	mov es,ax
	mov bx,200h	;es:bx指向接收从磁盘写入到内存的内存地址

	mov al,1	;al向磁盘控制器程序传递扇区数
	mov ch,0	;磁道号
	mov cl,1	;扇区号
	mov dl,0	;驱动器号
	mov dh,0	;磁头号（磁面号）
	mov ah,2	;功能号，读磁盘
	int 13h

	mov ax,4c00h
	int 21h

codeseg ends
end main
```

**实现磁盘逻辑地址空间**

使用int 13读写磁盘需要传递面号、磁道号、扇区号、驱动器号、扇区数等，考虑实现磁盘逻辑地址空间，使得传递的不是面号、磁道号、扇区号，而是逻辑地址
$$
逻辑地址=(磁面号*80+磁道号)*18+扇区号-1
$$

### 编写系统引导程序

BIOS启动过程

- 计算机加电后CS:IP指向FFFF:0，执行一条跳转指令，转移到BIOS硬件系统检测和初始化程序，这个过程会将BIOS的中断登记到中断向量表（内存0开始的1KB内存）
- 系统检测和初始化程序执行结束后调用int 19h进行操作系统引导，int 19h使用0号软驱，将磁盘0面0道1扇区的512B复制到0:7c00开始的地方，设置CS:IP=0:7c00，从此执行操作系统引导程序。（这个过程中直到设置0:7c00，都不是我们能够控制的范围，我们可以控制的是将我们的系统引导程序写入到0:7c00开始的地方，然后设置cs:7c00重新执行系统引导程序。

**从0:7c00h开始启动系统引导程序**

```
assume cs:codeseg

;Boot
;装载程序将Boot放到0:7c00
;设置cs:ip到0:7c00，模拟引导操作系统

codeseg segment

main:
	mov ax,0
	mov es,ax
	mov di,7c00H
	
	mov ax,cs
	mov ds,ax
	mov si, offset Boot
	
	mov cx,offset Boot0 - offset Boot
	rep movsb						;Boot程序装载到0:7c00

	mov bx, 0
	push bx
	mov bx, 7c00h
	push bx
	retf

	mov ax,4c00h
	int 21h

Boot:
	jmp BootStart

scr0	dw 2000 dup(0)
str	db 'W',11001010B
	db 'e',11001010B
	db 'l',11001010B
	db 'c',11001010B
	db 'o',11001010B
	db 'm',11001010B
	db 'e',11001010B

BootStart:
	;初始化界面
	;显示需要的字符串
	call initScreen
	call showStr

	mov ax,4c00h
	int 21h

initScreen:
	mov ax,0B800h
	mov es,ax
	mov di,0						;屏幕0地址

	mov ax,cs
	mov ds,ax
	mov si, 7c00h +offset scr0-offset Boot				
								;scr0起始地址偏移
								;7c00h是程序装载的位置
	
	mov cx, offset str- offset scr0
	rep movsb
	
	ret

showStr:
	mov ax,0B800h
	mov es,ax
	mov di,12*80*2+40*2				;屏幕0地址

	mov ax,cs
	mov ds,ax
	mov si, 7c00h +offset str-offset Boot				
								;str起始地址偏移
								;7c00h是程序装载的位置
	
	mov cx, offset BootStart- offset str
	rep movsb
	
	ret

Boot0:
	nop

codeseg ends

end main
```

**将上面的系统引导程序写入软盘0面0道1扇区，从FFFF:0开始BIOS引导**

```
assume cs:codeseg

;Boot
;装载程序将Boot放到0:7c00
;设置cs:ip到0:7c00，模拟引导操作系统

codeseg segment

main:
	mov ax,cx
	mov es,ax
	mov bx,offset Boot
	
	mov al,1	;扇区数
	mov ch,0	;磁道
	mov cl,1	;扇区
	mov dl,0	;驱动器
	mov dh,0	;磁面
	mov ah,3	;功能号，写磁盘
	int 13h						;将系统引导程序写入磁盘0面0道1扇区

	mov bx, 0FFFFH
	push bx
	mov bx, 0h
	push bx
	retf

	mov ax,4c00h
	int 21h

Boot:
	jmp BootStart

scr0	dw 2000 dup(0)
str	db 'W',11001010B
	db 'e',11001010B
	db 'l',11001010B
	db 'c',11001010B
	db 'o',11001010B
	db 'm',11001010B
	db 'e',11001010B

BootStart:
	;初始化界面
	;显示需要的字符串
	call initScreen
	call showStr

	mov ax,4c00h
	int 21h

initScreen:
	mov ax,0B800h
	mov es,ax
	mov di,0						;屏幕0地址

	mov ax,cs
	mov ds,ax
	mov si, 7c00h +offset scr0-offset Boot				
								;scr0起始地址偏移
								;7c00h是程序装载的位置
	
	mov cx, offset str- offset scr0
	rep movsb
	
	ret

showStr:
	mov ax,0B800h
	mov es,ax
	mov di,12*80*2+40*2				;屏幕0地址

	mov ax,cs
	mov ds,ax
	mov si, 7c00h +offset str-offset Boot				
								;str起始地址偏移
								;7c00h是程序装载的位置
	
	mov cx, offset BootStart- offset str
	rep movsb
	
	ret

Boot0:
	nop

codeseg ends

end main
```

### 基于汇编开发高级语言

**怀疑的方向，怀疑三问**

- 都在用就非得用吗
- 规定了就只能遵守吗
- 司空见惯我们就不怀疑了吗

高级语言特性就是编译器的东西，是编译原理的东西，高级语言的程序会被编译连接成汇编语言可执行程序。C语言规定，使用变量（内存空间）、使用main函数、参数传递方式等规定都是可以通过编译器改变，比如使用内存存储变量，可以使用寄存器存储变量，内存变量mov ds:[0],1 实际上在编译的时候就已经分配了内存，这个内存不是实际的物理内存，只是逻辑内存，对应的使用的是编译器编译得到的一个变量的偏移，在实际运行时，可以使用DOS默认分配的或者自己手动填写的物理地址基址ds:0开始实际将数据写入或者初始化道物理内存。

**使用Turbo将.c程序转成8086CPU汇编程序命令**

- 启动DOS

  ```
  mount c d:\asm
  c:
  tcc -S -ml b.c
  ```

[masm link tcc安装包](C:\Users\cheng\Desktop\JavaBackend\书籍\操作系统\masm,link,tcc安装包)

#### C语言转汇编语言-变量和参数传递

- C程序

```
#include "include/stdarg.h"

void add(int a, int b, int c){
	c=a+b ;
	printf("in add %d",c);
}
int main(){
	int a=1;
	int b=2;
	int c=0;

	add(a,b,c);
	c++ ;
	printf("in main %d", c);
}
```



- 对应的8086CPU汇编程序

```
_add	proc	far
	push	bp
	mov	bp,sp
;	?debug	L 4				
	mov	ax,word ptr [bp+6]			;变量a所在位置bp+6，前面包含bp,ip,cs
									;从而bp时加上6
	add	ax,word ptr [bp+8]			;变量b所在位置bp+8
	mov	word ptr [bp+10],ax			;变量c所在位置bp+10


;	?debug	L 5
	push	word ptr [bp+10]		;用栈传递参数，保存调用的内存地址
	push	ds
	mov	ax,offset DGROUP:s@
	push	ax
	call	far ptr _printf			;printf函数
	mov	sp,bp						;因为sp会被改变，所以用bp暂存sp恢复
@1:
;	?debug	L 6
	pop	bp
	ret	
_add	endp
;	?debug	L 7
_main	proc	far
	push	bp
	mov	bp,sp
	sub	sp,2
	push	si
	push	di
;	?debug	L 8
	mov	di,1
;	?debug	L 9
	mov	word ptr [bp-2],2
;	?debug	L 10
	xor	si,si
;	?debug	L 12
	push	si						; c=0，寄存器实现变量
	push	word ptr [bp-2]			; b=2，内存实现变量
	push	di						; a=1，寄存器实现变量
	push	cs
	call	near ptr _add
	add	sp,6
;	?debug	L 13
	inc	si			; c++

;	?debug	L 14
	push	si
	push	ds
	mov	ax,offset DGROUP:s@+10
	push	ax
	call	far ptr _printf	; printf函数
	add	sp,6
@2:
;	?debug	L 15
	pop	di
	pop	si
	mov	sp,bp
	pop	bp							;恢复调用main程序的程序的寄存器
	ret	
_main	endp

```

- C语言转汇编栈的作用
  - 用来传递参数，这个参数是值传递，先申请的变量保存在sp的低地址，后压栈
  - 用来保存函数调用的返回地址，也就是call指令的下一条指令的CS:IP地址，用于调用程序返回ret使用
  - 用来保存被调用函数的寄存器，调用函数使用的寄存器都要保存，返回的时候恢复被调用函数的寄存器数据
- C语言转汇编变量在哪里
  - 变量保存在内存
  - 变量保存在寄存器

#### 循环

**C代码**

```
#include "include/stdarg.h"

int main(){
	int i;
	for(i=0;i<10;i++){
		printf("%d\n",i);
	}
}
```



**汇编代码**

```
_main	proc	far
	push	si
;	?debug	L 5
	xor	si,si						;变量i用寄存器保存
	jmp	short @5
@4:									;printf函数调用
;	?debug	L 6
	push	si
	push	ds
	mov	ax,offset DGROUP:s@
	push	ax
	call	far ptr _printf
	add	sp,6						;丢弃调用printf压入的三个参数si,ds,ax
@3:
	inc	si							;i++
@5:									;判断i<10
	cmp	si,10
	jl	@4
@2:
@1:
;	?debug	L 8
	pop	si
	ret	
_main	endp

```

#### 全局变量和局部变量

全局变量在内存中保存，局部变量用寄存器di/si或者内存保存，优先使用si/di/内存保存变量

**C代码**

```
#include "include/stdarg.h"


int a=1;
int b=2;

int main(){
	int c=a+b;
	printf("%d\n",c);

}
```



**汇编代码**

```
_DATA	segment word public 'DATA'
_a	label	word					; int a=1,变量声明给出变量类型int，变量内存地址，变量初始化赋值三个数据可以确定变量
	dw	1
_b	label	word					; int b=2
	dw	2
_DATA	ends
B_TEXT	segment	byte public 'CODE'
;	?debug	L 7
_main	proc	far
	push	si						
;	?debug	L 8
	mov	si,word ptr DGROUP:_a		; int c=a
	add	si,word ptr DGROUP:_b		; c+ b
	
;	?debug	L 9
	push	si
	push	ds
	mov	ax,offset DGROUP:s@
	push	ax
	call	far ptr _printf
	add	sp,6						;prinf
@1:
;	?debug	L 11
	pop	si
	ret	
_main	endp

```

#### 数组和栈

**C语言**

```
#include "include/stdarg.h"


int stack[16]={0};
int tmp ;

void push(int val){
	if( stack[0] <= 1){
		printf("stack is full\n");
		return ;
	}
	stack[0]-- ;
	stack[ stack[0] ] = val ;
}

int pop(){
	if( stack[0]>=16 ){
		printf("stack is empty");
		return -1;
	}

	tmp = stack[ stack[0] ] ;
	stack[0]++ ;
	return tmp ;
}

int main(){
	stack[0]=16 ;

	push(1);
	push(2);
	push(3);

	printf("%d\n",pop());
	printf("%d\n",pop());
	printf("%d\n",pop()) ;

	printf("%d\n",pop()) ;
}
```

**汇编**

```
_DATA	segment word public 'DATA'
_stack	label	word					;数组和栈位全局变量，在内存分配
	dw	0
	db	30 dup (0)
_DATA	ends
B_TEXT	segment	byte public 'CODE'
;	?debug	L 7
_push	proc	far
	push	bp
	mov	bp,sp
;	?debug	L 8
	cmp	word ptr DGROUP:_stack,1
	jg	@2
;	?debug	L 9
	push	ds
	mov	ax,offset DGROUP:s@
	push	ax
	call	far ptr _printf
	mov	sp,bp
	jmp	short @1
@2:
;	?debug	L 12
	dec	word ptr DGROUP:_stack
;	?debug	L 13
	mov	ax,word ptr [bp+6]
	mov	bx,word ptr DGROUP:_stack
	shl	bx,1
	mov	word ptr DGROUP:_stack[bx],ax
@1:
;	?debug	L 14
	pop	bp
	ret	
_push	endp
;	?debug	L 16
_pop	proc	far
;	?debug	L 17
	cmp	word ptr DGROUP:_stack,16
	jl	@4
;	?debug	L 18
	push	ds
	mov	ax,offset DGROUP:s@+15
	push	ax
	call	far ptr _printf
	pop	cx
	pop	cx
;	?debug	L 19
	mov	ax,-1
	jmp	short @3
@4:
;	?debug	L 22
	mov	bx,word ptr DGROUP:_stack
	shl	bx,1
	mov	ax,word ptr DGROUP:_stack[bx]
	mov	word ptr DGROUP:_tmp,ax
;	?debug	L 23
	inc	word ptr DGROUP:_stack
;	?debug	L 24
	mov	ax,word ptr DGROUP:_tmp
	jmp	short @3
@3:
;	?debug	L 25
	ret	
_pop	endp
;	?debug	L 27
_main	proc	far
;	?debug	L 28
	mov	word ptr DGROUP:_stack,16
;	?debug	L 30
	mov	ax,1
	push	ax
	push	cs
	call	near ptr _push
	pop	cx
;	?debug	L 31
	mov	ax,2
	push	ax
	push	cs
	call	near ptr _push
	pop	cx
;	?debug	L 32
	mov	ax,3
	push	ax
	push	cs
	call	near ptr _push
	pop	cx
;	?debug	L 34
	push	cs
	call	near ptr _pop
	push	ax
	push	ds
	mov	ax,offset DGROUP:s@+30
	push	ax
	call	far ptr _printf
	add	sp,6
;	?debug	L 35
	push	cs
	call	near ptr _pop
	push	ax
	push	ds
	mov	ax,offset DGROUP:s@+34
	push	ax
	call	far ptr _printf
	add	sp,6
;	?debug	L 36
	push	cs
	call	near ptr _pop
	push	ax
	push	ds
	mov	ax,offset DGROUP:s@+38
	push	ax
	call	far ptr _printf
	add	sp,6
;	?debug	L 38
	push	cs
	call	near ptr _pop
	push	ax
	push	ds
	mov	ax,offset DGROUP:s@+42
	push	ax
	call	far ptr _printf
	add	sp,6
@5:
;	?debug	L 39
	ret	
_main	endp
B_TEXT	ends
_BSS	segment word public 'BSS'
_tmp	label	word				;tmp变量在内存分配
	db	2 dup (?)
_BSS	ends

```

## 操作系统实验

### 实验1-修改系统启动

计算机启动的时候，CPU首先初始化CS:IP=FFFF:0h，执行一个跳转指令，执行BIOS系统检测和初始化程序，这个程序会将BIOS中断例程注册道中断向量表（0地址处），执行完成之后执行int 19h的BIOS例程引导操作系统，将操作系统从软盘0面0道1扇区读到内存0:7c00h处，然后设置CS:IP指向0:7c00h,这样开始执行操作系统程序

Linux 0.11 是在80x86CPU上运行的，8086CPU是早期CPU，只能在16位实模式下运行，一个时刻只能执行一个任务，而80x86包括80386、80486等，是8086的增强型，提供了32位保护模式，32位保护模式支持多任务、支持4G物理内存和64TB虚拟内存、支持虚拟内存、支持段页式内存管理、支持特权级。Linux 0.11是80836CPU上运行的

**VMware适合应用程序开发，Bochs适合底层如操作系统或编译器开发**

Bochs仿真了80x86CPU的所有内部环境和外围设备，而VMware只仿真了IO流，其他的部分直接交给实际80x86CPU直接执行

**80386的32位保护模式**

80386默认工作在实模式下，实模式只支持单任务，类似8086CPU的实模式，8086CPU实模式支持1M内存空间寻址

- 内存管理寄存器，使用4个寄存器用于分段内存管理

  - GDTR寄存器，指向全局描述符表
  - LDTR寄存器，指向局部描述符表，和上面一样都是段描述符表，保护模式下的段地址ds给出的是全局描述符表或者局部描述符表的表项的偏移，而不是实模式下的直接的段地址，为什么要这么做，因为32位保护模式下段有多重属性，比如段的特权级、段所处在局部描述符表还是全局描述符表，段的真实段地址。
  - IDTR寄存器，指向中断向量表，中断向量表存放所有中断处理程序的入口地址
  - TR寄存器，指向进程控制块，当前进程的描述信息

- 控制寄存器

  有四个32位控制寄存器CR0,CR1,CR2,CR3

  - CR0控制和指示CPU工作的整个系统的运行状态和条件
    - PE，保护模式开启位，第0位比特，PE=1表示运行在保护模式
    - MP，协处理器存在标志，第1位比特，控制WAIT指令的功能能，以配合协处理器运行
    - EM，仿真控制，比特位2，只是是否需要仿真协处理器的功能
    - TS，任务切换，比特位3，每当任务切换处理器时设置整个位
    - ET，扩展类型，比特位4，指出是那种协处理器，80287或者80387
    - PG，分页操作，比特位31，使用页表将虚拟地址转换成物理地址
  - CR2，在PG=1时使用，保存缺页中断时的地址
  - CR3，在PG=1时使用，保存页表基地址

**C语言数据类型**

https://www.runoob.com/cprogramming/c-data-types.html

- 整型
  - char 1B
  - short 2B
  - int 4B
  - long 4B
  - long long 8B
- 浮点型
  - float 4B
  - double 8B
  - long double 16B
- 构造类型
  - 数组
  - 结构体
- void类型
- 指针类型

**段式存储器和寻址过程**

> 80386以上CPU支持段页式存储器，物理内存4G。80386CPU和8086CPU寻址方式不一样，8086CPU给出的段基址不是实际的物理地址，这个段基址左移4位加上偏移值16位组合得到20位物理地址。而80386寻址需要使用段寄存器、描述符表和偏移值，段寄存器给出的数值是描述符表的表项的偏移，描述符表寄存器会给出描述符表的实际的物理地址，这个实际物理地址加上段寄存器的索引值*8得到真正的段物理地址，也就是说段描述保存了真正的物理地址32位，而不是像8086CPU一样要用段基址\*16才能得到实际的段的物理地址
>
> **段寄存器**(CS,DS,SS,ES等)，包括显示部分16位和隐藏部分8个字节64位，隐藏部分是缓存显示部分的段描述符，以减少访问内存获得段描述符的操作。段寄存器内容RPL（2位，表示特权级别，0表示内核态，3表示用户态）、TI（1位，表示使用的描述符表，0表示GDT表，1表示LDT表）、索引值（13位，用于查找描述符表中的段描述符，索引值13位左移3位得到16位+描述符寄存器中基地址得到描述符表中的一个表项段描述符，描述符寄存器GDTR或者LDTR中的基地址就是一个内存线性地址，是物理地址，代表物理内存大小4G，索引值13位代表描述符表表项最多2的13次方，左移3位是因为一个表项段描述符是8个字节）
>
> **描述符表寄存器**GDTR和LDTR，段寄存器中TI位指定使用哪一个描述符表寄存器，TI=0使用GDTR，TI=1使用LDTR。描述符表寄存器有六个字节48位，前两个字节十六位指定表限长，其中只有低13位用于表限长，这个位数和段寄存器的索引值一样，表示最多有2的13次方个索引值；描述符表寄存器的后四个字节32位指示描述符表的线性地址，这是一个实际的物理地址，这个基地址+索引值*8得到段描述符地址
>
> **段描述符**一个有8个字节64位，其中**基地址**三个部分组合成一个32位的基地址；**段限长**三个部分组合成一个20位的段限长（这个段限长和偏移地址一样都是20位；**颗粒度**G位定义了段限长的单位，如果G=1表示4K，那么段限长左移12位变成32位，如果G=0那么代表字节；**类型Type**4位用于区分描述符类型；**段存在位P**位为1表示这个描述符项无效，那么在访问这个描述符项并且加载到段寄存器的隐藏位时将发生CPU异常信号；**描述符特权级DPL**定义段描述符的特权级别，0表示内核态，3表示用户态；**访问位A=1**代表CPU访问过这个描述符项。描述符项是由编译器、连接器、加载器、操作系统创建的，操作系统给用户程序或者内核模块分配内存时建立描述符项
>
> **偏移值**用来和段基地址相加得到实际的代码或者数据的物理地址
>
> **段存储器**寻址方式，段寄存器给出13位索引值，描述符寄存器的基地址32位给出描述符表基地址，32位基地址+13位索引*8 得到段描述符表中的段描述符物理地址，从段描述符获得实际的段物理地址；这个物理地址加上20为或者32位偏移值得到实际的代码或者数据物理地址；这个物理地址就是一个线性地址，如果没有开启32位保护模式CRO的p位位1，那么这个线性地址就是实际的物理地址32位，如果时32位保护模式，那么这个线性地址只是一个虚地址，还需要经过页变换获得实际的物理地址。

**页式存储器和寻址过程**

> 开启了CPU控制寄存器CR0的PG位32位保护模式后，段式存储器得到的线性地址就不是实际的物理地址，还需要叶变换获得实际的物理地址。
>
> 80386地址总线32位，数据总线32位，物理内存4GB，一次传输数据4个字节，寄存器是32位
>
> 80386CPU支持两级页表，页目录表、页表和页框，段式存储器给出的虚拟地址被划分位三个部分，前10位是页目录表偏移（页目录号）、中间十位是页表偏移（页号）、后十二位是页框偏移（页框号）。80386CPU把分页存储器把4G内存划分为每4KB为一个单元，数据和程序被放到磁盘中，以512B单元存储，给出磁面（磁头号）、磁道、扇面定位一个磁盘单元。80386CPU总是以4K读取磁盘，每次读取8个磁盘单元。一个页框大小被CPU固定分配位4KB大小。
>
> CPU的CR3控制寄存器保存页目录表实际物理地址，页表的一个页表项前20位保存下一级页表的物理地址的前20位，因为一个页表项的后12位总是为0（因为一个页表项单位是4KB，所以在32为寻址中，前二十位就可以定位下一级页表的物理地址）。页表项的后十二位因为全为0，就被用来保存页表项的属性，比如p位属性表示这个页表项是否可用，这在虚拟内存分配的时候很有用，在shell加载程序的时候会创建页表，这个时候不需要填充页表，让所有的页表项的p位位0，我们只需要用操作系统设置好程序在磁盘的起始地址，设置好程序使用的段地址，然后转到段地址处执行，段寄存器通过GDT表获得段基址，加上偏移值得到虚拟地址，这个虚拟地址页号指向的页表项的p位位0，那么就是这个页框号不在内存中，发生缺页中断，缺页被CPU放到CR2控制寄存器，CPU转到缺页中断执行，将缺失页页号减去初始分配的页号得到实际偏移的页号，这样就可以获取一个页放到内存中，然后设置页表指向内存中的这个页地址，设置p=1，重新跳转到寻址执行执行，就能获得要求的指令。
>
> **使用TLB加快访问页表**
>
> TLB使用CPU高速缓存Cache来保存一个页表
>
> **两级页表一次指令执行需要访问内存3次**
>
> 

**任务切换**

80386CPU提供了TSS（任务状态段）来实现进程PCB保存的进程信息，TR寄存器（任务寄存器）是一个选择符，TSS是一个链表结构，他最后一个部分是下一个任务的TSS描述符，TSS的描述符只能保存在GDT表中，被TR寄存器指向GDT表中TSS描述符。

Linux不适用TSS机制实现任务切换，而是使用进程PCB实现进程切换

**中断和异常**

中断寄存器IDTR是一个指向IDT表的寄存器，是6字节寄存器，前两个字节是段限长、后四个字节是物理地址

中断描述符表IDT保存的中断描述符记录了中断的起始地址，其中段选择符会返回到GDT表中获得段基地址，其中20位偏移值会作位偏移值加到段基地址中

Linux没有使用80386的任务门切换机制TSS

**Linux操作系统启动**

- 80386CPU启动，CPU指向FFFF:0执行跳转，跳转到BIOS自检和初始化程序，这个程序会把BIOS中断注册到内存0地址处中断向量表1K大小，然后执行int 19h把磁盘0面0道1扇区的512B字节加载到内存0:7c00处，然后跳转到0:7c00执行操作系统启动项bootsect.s
- bootsect.s
  - 将自己移动到0x90000处，
  - 加载setup.s到0x92000处，
  - 将system模块加载到0x10000处，
  - 然后交给setup.s执行
- setup.s
  - 利用ROM BIOS中断读取计算机参数存放到0x90000处，覆盖bootsect.s代码
  - 把system模块移动到0x00000处，head.s处于0x00000处
  - 加载描述符表到描述符表寄存器
  - 重新设置中断控制硬件
  - 通过控制寄存器CR0跳转到system模块的head.s处执行
- head.s
  - 初始化中断描述符表INT各个表项位哑中断
  - 检查A20地址线是否开启
  - 测试系统是否含有数学协处理器
  - 初始化内存页目录表
  - 跳转到system模块的init/main.c执行

**GCC编译C语言库文件查找路径**

[参考文献](https://blog.csdn.net/yang_chen_shi_wo/article/details/46416093)

> gcc -I mylocal/include -L mylocal/lib a.c -lworld -static

其中，-I指定用户自己编译a.c使用的头文件，-L是用户使用的链接库文件，-lworld表示在mylocal/lib查找动态链接库库.so，-static表示在mylocal/lib查找静态链接库.a。虽然用户指定了inlude，但是编译器还是用了标准路径下面的include，在linux环境这个标准路径是user/local/include和user/include两个，而使用的lib的标准路径包括两个user/lib和user/local/lib

**C语言使用#include<stdio.h>和#include"stdio.h"的区别**

使用尖括号会直接在标准路径下面的include文件夹查找stdio.h，不会关本地的include文件，而使用冒号会优先在本地include查找，如果找不到才到标准路径下面查找

**编写C语言库函数并且调用-实现printf函数**

参考文献

http://c.biancheng.net/view/8030.html

https://zhuanlan.zhihu.com/p/438805348

https://wenku.baidu.com/view/d50a5fb1de88d0d233d4b14e852458fb760b3857.html

https://blog.csdn.net/wtl1992/article/details/122654203

https://blog.csdn.net/liuxiao723846/article/details/97617681

- 开始编写文件结构

  > main.c
  >
  > include
  >
  > ​		----mystdio.h
  >
  > lib 
  >
  > ​		----mystdio.c

- 文件内容

  - main.c

    > #include "mystdio.h"
    >
    > int main(){
    > 	int a = my_printf("%d\n", 1);
    > }

  - mystdio.h

    > #ifndef _MYSTDIO_H
    > #define _MYSTDIO_H 
    >
    > extern int my_printf(char* str, ...);  //声明外部函数，使用extern声明外部变量
    >
    > #endif

  -  mystdio.c

    > #include <stdio.h>
    > #include<stdarg.h>
    >
    > int my_printf(char* str, ...){
    > 	int n ;
    > 	va_list list;								// va_list va_start va_end 是宏，vprintf是c库函数
    > 	va_start(list,str);
    > 	n = vprintf(str,list);
    > 	va_end(list);
    > 	return n ;
    > }

- 编译成库

  cd 到lib文件夹，编译动态链接库

  > gcc -o mystdio.o -c mystdio.c -fPIC
  >
  > gcc -shared -o libmystdio.so mystdio.o     //可以添加多个.o文件

- 将动态链接库添加到gcc查找路径

  > export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/cheng/Desktop/gcc/lib

- 编译执行main函数

  > gcc -o main main.c -Iinclude -Llib -lmystdio
  >
  > ./main

- 添加库头文件到Linux默认gcc查找路径

  把.h文件添加到usr/include或者usr/local/include

  把.so添加到usr/lib或者usr/local/include

  这样使用编译main的时候旧可以直接用-lmystdio而不用-Iinclude和-Llib编译的时候指出编译使用的头文件和库文件

**64位计算机指的是寄存器位数64位，64位操作系统是指令长度64位**

**如何使用操作系统调用**

Linux上使用操作系统系统调用的方式主要是三种。总之最后实际上汇集到第三种，本质上是使用内联汇编把系统调用号传递给寄存器eax，再使用int 0x80中断进行处理。GCC内联汇编实现C语言变量和汇编寄存器内存之间相互传递。

[参考文献](https://www.cnblogs.com/hazir/p/three_methods_of_syscall.html)

- 使用C语言库函数

  ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <errno.h>
  #include <stdio.h>
  
  int main()
  {
          int rc;
  
          rc = chmod("/etc/passwd", 0444);
          if (rc == -1)
                  fprintf(stderr, "chmod failed, errno = %d\n", errno);
          else
                  printf("chmod success!\n");
          return 0;
  }
  ```

- 直到系统调用号后使用c库函数syscall，适合新加入的系统调用而c库函数没有对应的函数，下面的例程SYS_chmod是系统调用号，他在sys/syscall.h定义

  ```c
  #include <stdio.h>
  #include <unistd.h>
  #include <sys/syscall.h>
  #include <errno.h>
  
  int main()
  {
          int rc;
          rc = syscall(SYS_chmod, "/etc/passwd", 0444);
  
          if (rc == -1)
                  fprintf(stderr, "chmod failed, errno = %d\n", errno);
          else
                  printf("chmod succeess!\n");
          return 0;
  }
  ```

- 直到系统调用号直接使用内联汇编进行中断处理，这个函数使用eax寄存器传递系统调用号

  ```c
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/syscall.h>
  #include <errno.h>
  
  int main()
  {
          long rc;
          char *file_name = "/etc/passwd";
          unsigned short mode = 0444;
  
          asm(
                  "int $0x80"
                  : "=a" (rc)
                  : "0" (SYS_chmod), "b" ((long)file_name), "c" ((long)mode)
          );
  
          if ((unsigned long)rc >= (unsigned long)-132) {
                  errno = -rc;
                  rc = -1;
          }
  
          if (rc == -1)
                  fprintf(stderr, "chmode failed, errno = %d\n", errno);
          else
                  printf("success!\n");
  
          return 0;
  }
  
  ```

**内联汇编实例**

https://www.jianshu.com/p/1782e14a0766

[内联汇编书籍](https://bbs.pku.edu.cn/attach/ca/dd/cadde373e533b3ea/chapter2.pdf)

- 实现变量赋值

  ``` c
  #include <stdio.h>
  
  int main()
  {
  	long  a=1;
  	long  b=0;
  	printf("%p\n",&a);
  	asm volatile(
  		"movl %%eax, %%ebx ;"	//asm function
  	
  		:"=b"(b) 	//return value to c variable b
  		:"a"(a)		//push parameter to asm function
  	); 
  	printf("%ld\n",a);
  	printf("%ld\n", b) ;
  }
  ```

**C语言使用  open/read/write/用户缓冲空间buffer  复制文件**

https://blog.csdn.net/ly52352148/article/details/52873819

```c
//copy file in.txt to out.txt


#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>


const char *pathName = "out.txt" ;

int main(){
	int in, out, num;
	char buffer[1024] ;

	in = open("in.txt", O_RDONLY, S_IRUSR) ; //open file in.txt, in is file describer
	printf("in file describer:%d\n", in) ;
	if( in == -1 ){
		return -1 ;
	}

	out = open(pathName, O_WRONLY|O_CREAT);
	printf("out file describer:%d\n", out) ;
	if( out == -1){
		return -1;
	}
	
	while((num=read(in, buffer, 1024))>0){
		write( out, buffer, num) ;
	}
	close(in);
	close(out);

	return 0;
}
```

**sizeof 获取字节数**

```cassandra
#include<stdio.h>

int main(){
	//get number of bytes of a type
	printf("bytes of char: %lu\n", sizeof(char) ) ;   //lu for unsigned_int
	printf("bytes of int: %lu\n", sizeof(int) )	;
	printf("bytes of short: %lu\n", sizeof(short) )	;
	printf("bytes of long: %lu\n", sizeof(long) )	;
	printf("bytes of long long: %lu\n", sizeof(long long) )	;

	printf("bytes of float: %lu\n", sizeof(float) ) ;
	printf("bytes of double: %lu\n", sizeof(double) ) ;


	//get number of elements of an array
	int a[] = {1,2,3} ;
	printf("number of elements of array: %lu\n", sizeof(a)/sizeof(a[0]) ) ;
	return 0;
}
```

**文件描述符**

https://xzchsia.github.io/2020/03/03/file-descriptor/

https://www.ruanyifeng.com/blog/2011/12/inode.html

文件句柄是File*，也就是一个File结构体指针，包括缓冲区（各种类型的数组）和一个文件描述符。文件描述符是进程文件描述符表的偏移，进程PCB中有一个文件描述符表，文件描述符表就是他的偏移；操作系统维护了一个打开文件表，文件描述符和一个打开文件表的表项相关联，打开文件表描述了进程打开文件的属性，比如open使用的flag或者打开模式，除此以外，操作系统维护了一个i-node表，维护了文件的固有属性，比如文件读写权限、创建用户等，还包括一个inode号码，这个号码唯一标记一个i-node表项。

**修改操作系统启动 实验结果**

实验文件保存在(\实验\操作系统实验\实验一 操作系统启动\)

![屏幕截图 2022-05-20 233607](C:\Users\cheng\Desktop\JavaBackend\实验\操作系统实验\实验一 操作系统启动\实验截图\屏幕截图 2022-05-20 233607.png)



### 实验2-系统调用

**外部变量声明，头文件的作用**

https://blog.csdn.net/zqixiao_09/article/details/49913523

使用extern实现外部变量声明，主要用于模块化程序设计，一般声明变量定义在头文件中，在使用的文件中使用extern来声明这个变量就可以使用这个变量了。

头文件保存变量数组函数的声明，作用是保存变量方便开发、提供外部接口、使函数作用域从函数声明的位置开始而不是定义的位置开始（这需要使用extern声明变量从而使得作用域从extern声明的位置开始）

**使用gcc编译c文件位汇编文件s**

```c
//将b.c编译成.s文件汇编文件
gcc -E b.c -o b.i
gcc -S b.i -o b.s
    
//使用gcc编译.o .s .c 文件为可执行程序，c语言函数调用参数传递使用栈来传递的，
//而参数类型将决定传递参数所占用的字节数量，因此从sp开始把参数从右往左压栈，
gcc -o a a.c b.s
```

**函数指针的地址指向函数开始的地址**

```c
//打印函数指针地址

#include<stdio.h>

extern int add(int, int) ;

int main(){
	printf("asdfb\n") ;
	printf("%d\n",add(1,2) );

	printf("%p\n", &add ) ;
	printf("%p\n", &main) ;
}
```

**C语言的main.c文件使用另外一个文件A.c的函数**

需要再main.c函数中使用export来关联到A里面的函数，这样main.c才能使用这个函数

**GCC的C语言库函数和Linux内核库函数区别**

GCC编译器可以同时使用C语言库函数和Linux内核库函数编译成汇编语言，进而形成可执行文件。C语言库函数大都是运行再用户空间的程序，当他们想要使用内核服务比如申请内存或者读写外部设备，那么他就要调用Linux内核库函数，这个提供给C语言库函数调用的Linux库函数是一个系统调用。因此，C语言库函数可以是封装了底层系统调用的函数，也可以是独立的处理用户空间的函数，两者没有完全的依赖关系。实际上，可以不适用C语言库函数而自己独立写一个库函数实现替代C语言库函数，当要使用Linux内核服务区分配内存或者读写外部设备的时候我们自己使用系统调用_sys_call 加上系统调用号和参数实现调用系统调用。系统调用就是Linux内核提供的一个函数而已。

在编写内核函数的时候可以调用的是内核函数，内核函数的最基本的实现是用汇编语言编写的，比如Linux内核函数strcpy就是用汇编语言编写的复制字符串，他在linux/include/string.h定义和实现。不过这个函数不是系统调用，不能直接在我们编写的用户程序上直接调用，我们调用的strcpy是在C语言库函数gcc/include/string.h中定义和在gcc/string/strcpy.c实现的，这里strcpy完全是C语言编写的

**添加系统调用实现用户程序使用系统调用向内核空间写入字符串和从内核空间读取字符串**

- 定义系统调用号，在linux-0.11/include/unistd.h添加两行

  ```
  #define __NR_whoami 	72
  #define __NR_iam 		73
  ```

- 定义系统调用函数，在linux-0.11/include/linux/sys.h添加

  ```
  extern int sys_whoami() ;
  extern int sys_iam() ;
  ```

  

  ![屏幕截图 2022-05-22 023610](C:\Users\cheng\Desktop\JavaBackend\实验\操作系统实验\实验二 系统调用\实验截图\屏幕截图 2022-05-22 023610.png)

  在系统调用表中添加

  ```
  sys_whoami, sys_iam
  ```

  ![屏幕截图 2022-05-22 023804](C:\Users\cheng\Desktop\JavaBackend\实验\操作系统实验\实验二 系统调用\实验截图\屏幕截图 2022-05-22 023804.png)

  注释，在用户程序使用系统调用号调用syscall宏函数的时候，系统调用号实际上是系统调用表sys_call_table中的表项，他从系统调用表中获取到系统调用函数的地址，转而去执行对应的系统调用函数

- 实现系统调用函数，在linux-0.11/kernel下建立C文件who.c，其中内容是

  ```c
  #include<asm/segment.h>
  #include<errno.h>
  #include<string.h>
  
  
  char _myname[24] ;
  
  int sys_iam(const char* name){
  	char str[25] ;
  	int i =0;
  
  	do{
  		str[i] = get_fs_byte(name+i) ; 
  	}while(i<=25 && str[i++] != '\0' ) ;
  
  	if( i>24){
  		errno = EINVAL ;
  		i=-1 ;
  	}
  	else{
  		strcpy(_myname, str) ;
  	}
  	return i ;
  }
  
  int sys_whoami(char* name, unsigned int size){
  	int length = strlen(_myname) ;
  	printk("%s\n",_myname) ;
  
  	if( size < length){
  		errno = EINVAL ;
  		length = -1;	
  	}
  	else{
  		int i=0;
  		for( i=0;i<length;i++){
  			put_fs_byte(_myname[i], name+i) ;
  		}
  	}
  	return length ;
  }
  ```

- 修改linux-0.11/kernel/system_call.s 将nr_system_calls = 72 改成nr_system_calls = 74，也就是总的系统调用数量

- 修改linux-0.11/kernel/Makefile编译

  - OBJ添加who.o

    ![屏幕截图 2022-05-22 024543](C:\Users\cheng\Desktop\JavaBackend\实验\操作系统实验\实验二 系统调用\实验截图\屏幕截图 2022-05-22 024543.png)

  - Dependencies添加

    ```
    whos.s who.o :who.c ../include/linux/kernel.h ../include/unistd.h
    ```

    ![屏幕截图 2022-05-22 024739](C:\Users\cheng\Desktop\JavaBackend\实验\操作系统实验\实验二 系统调用\实验截图\屏幕截图 2022-05-22 024739.png)

  - 之后编译make all执行操作系统

- 编写用户程序调用系统调用

  ![屏幕截图 2022-05-22 025011](C:\Users\cheng\Desktop\JavaBackend\实验\操作系统实验\实验二 系统调用\实验截图\屏幕截图 2022-05-22 025011.png)

  - whoami.c

    ```c
    #define __LIBRARY__
    
    #include <unistd.h>
    #include<errno.h>
    #include<asm/segment.h>
    #include<linux/kernel.h>
    #include<stdio.h>
    
    _syscall2(int, whoami, char*, name, unsigned int, size) ;
    
    int main(int argc, char* argv[]){
    	char username[64] = {0} ;
    	whoami(username, 24) ;
    	printf("%s\n", username) ;
    	return 0 ;
    }
    ```

  - iam.c

    ```c
    #define __LIBRARY__
    
    
    #include<unistd.h>
    #include<errno.h>
    #include<asm/segment.h>
    #include<linux/kernel.h>
    
    
    _syscall1(int, iam, const char*, name) ;
    
    int main(int argc, char* argv[]){
    	iam(argv[1]) ;
    	return 0 ;
    }
    ```

- 将用户程序文件挂载到Linux-0.11的/usr/root目录，之后执行./run运行操作系统可以在usr/root看到两个.c文件

  ![屏幕截图 2022-05-22 025647](实验\操作系统实验\实验二 系统调用\实验截图\屏幕截图 2022-05-22 025647.png)

- 编译运行用户程序

  ![屏幕截图 2022-05-22 025847](实验\操作系统实验\实验二 系统调用\实验截图\屏幕截图 2022-05-22 025847.png)

  这个过程可能gcc编译的时候没有系统调用错误，需要在usr/include/unistd.h添加系统调用号

  ```
  #define __NR_whoami 	72
  #define __NR_iam 		73
  ```

**==========================================================总结**================================================

**系统调用**

系统调用是一个中断处理函数，中断号是0x80，函数名是system_call。系统调用这个中断实在init/main.c的sched_init函数中设置的，这个函数将系统中断函数system_call的地址注册到中断向量表IDT表0x80的位置。system_call中断函数判断使用的中断处理子函数的语句是call sys_call_table(,%eax,4)，这句话实际跳转到sys_call_table+4*%eax的位置。sys_call_table是系统调用表，他是一个存放了系统调用子程序的一个数组。

**系统调用API**

系统调用这个中断处理函数有许多子函数，用系统调用号标记，__NR_XXX这个宏定义了系统调用号。用户程序可以直接使用中断处理程序，因为可以直接用内联汇编调用int 0x80中断处理函数就行，在这个过程中，我们要为EAX寄存器存入系统调用号，这样就能调用我们需要的中断处理函数的子程序了。另外一种调用中断处理函数的方式是使用系统调用API，这个系统调用API实际是内联汇编的一个宏，sys_call1等来声明的一个函数，本质再用户程序展开之后也就是对应前面所说的在用户程序中嵌入汇编调用中断处理函数的方法，这种方式的好处是节省了写内联汇编的代码，提取到公共的一个宏sys_call1。

**编写系统调用**

首先编写一个系统调用处理函数，命名为sys_xxx，把这个sys_xxx，添加到include/unistd中注册一个系统调用号__NR_XXX。在include/linux/sys.h中的sys_call_table中添加系统调用sys_xxx。在kernel/system_call.s中修改系统调用总数。

**include尖括号和双引号的区别**

尖括号会优先从系统目录usr/include中寻找声明文件.h，而双引号会优先从本地目录寻找.h文件。

**头文件的作用**

[头文件的作用 - 百度文库 (baidu.com)](https://wenku.baidu.com/view/e6b62e5c312b3169a451a466.html?fr=aladdin664466&ind=1)

- 方便提供给用户使用。因为保密性不方便提供源程序，提供给用户的总是头文件和链接库，这样用户可以通过头文件了解程序功能，通过链接库提取需要的函数。
- 编译器类型检查。在遇到一个函数的时候需要了解函数的声明来检查用户程序是否按照声明的方法来使用的，而在每个文件中都声明是冗余的，那么使用头文件可以方便把函数声明都集中起来。
- 提高程序的可读性。

**头文件的书写**

- 如果程序需要内敛函数，需要在头文件中定义一个内联函数的宏，因为内联函数总是被在用户程序中展开，而不是函数调用。
- 头文件结构
  - 头文件注释（功能描述，版本声明）
  - #ifndef/#define
  - #include其他头文件
  - 外部变量和全局变量声明
  - 常量和红底应
  - 类型定义和声明
  - 全局变量原型和内联函数定义
  - endif
  - 文件版本修订说明

### 实验3-进程运行轨迹的跟踪与统计

进程从创建（Linux下调用fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行

**Linux参数**

https://blog.csdn.net/gatieme/article/details/51058797

https://cloud.tencent.com/developer/article/1122484

```
//查看进程状态
top //实时显示进程状态
px aux | grep   //显示当前时刻的进程状态
```

进程从创建（Linux 下调用 fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出 CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……

内核空间：操作系统内核态使用的空间，保存操作系统程序和操作系统内核函数执行使用的空间。操作系统内核程序执行使用的空间在内核空间，这是用户程序不能使用的空间，用户程序使用的空间是用户空间。

**调度算法的评价指标**

https://blog.csdn.net/weixin_45990326/article/details/119861173

CPU利用率：CPU执行时间占总时间比例，总时间包括CPU执行时间和IO时间

系统吞吐量：总共完成作业的数量除以总共花费的时间

周转时间：作业被提交给系统开始到作业完成为止的时间，等于作业完成时间-作业提交时间，包括作业在外存后备队列的等待时间和、就绪队列的等待时间、CPU执行时间、IO时间，后面三项组成进程周转时间。

- 平均周转时间：所有作业的周转时间/作业数
- 带权周转时间：作业周转时间/CPU时间
- 平均带权周转时间：所有带权周转时间/作业数

等待时间：作业在外存后备队列的等待时间+就绪队列的等待时间。IO时间也是被服务的状态，不计入等待时间

响应时间：作业从提交到首次被执行的时间。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e9f2852d49ed41e78d7000d52bf0cc43.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk5MDMyNg==,size_16,color_FFFFFF,t_70)

**进程调度算法**

https://cloud.tencent.com/developer/article/1882760

先来先服务：

短作业优先：

时间片轮转：

优先级调度（静态优先级和动态优先级）

多级反馈队列：

**fork系统调用**

fork系统创建一个子进程，将父进程的数据段和堆栈段复制，将父进程的代码段从fork后面的一句开始复制（因为前面的代码已经执行过了，他的数据已经被反映到数据段和堆栈段上了，就不用再执行他们了，也就不用复制他们了）。在父进程的pid_t pid中返回子进程pid，也就是pid=子进程pid；在子进程的pid_t pid中返回0，也就是pid=0；如果fork出错，那么返回一个负数。fork出错有两个原因，一个是内存不足，一个是创建进程数量超过限制。可以通过pid返回值确定执行的进程是父进程或者子进程，并且通过分支判断来执行父进程和子进程的任务。

**文件描述符0、1、2**

https://blog.csdn.net/qq_45831156/article/details/107469716

https://blog.51cto.com/u_15315240/5096978

https://blog.csdn.net/silent123go/article/details/71108501

Linux所有设备被当成文件处理，当打开或者创建一个文件的时候将返回一个文件描述符。一个文件描述符关联一个文件设备，使用tty可以查看本console使用的文件描述符对应的设备的地址。dev/tty是系统终端，dev/tty0是当前使用的终端，dev/tty1是虚拟终端，他是系统终端tty衍生的。

- **Linux读写文件过程**

​	open系统调用打开一个文件设备并返回文件描述符，之后使用read系统调用根据这个文件描述符读取数据到内核空间，再拷贝到用户空间（拷贝到用户程序定义的数组或	变量，也就是=的复制操作会在内核态把内核数据拷贝到用户变量）。write系统调用会把用户空间的数据拷贝到内核空间，然后写入到标准输出设备1或者标准错误输出设	备2里面。0、1、2分别对应标准输入、标准输出、标准错误输出设备。这种内核空间	和用户空间的数据会让在用户空间对数据的修改和原打开的在外存中的文件内容不一	致。为什么不直接进行外存设备的修改？主要是外存设备是块设备，每次只能读写一个内存块512B，并且不能支持随机存取，而内存可以支持随机访问，他的粒度可以是字节。对文件write完成之后，需要使用close系统调用关闭文件，这样才会把用户空间的修改的文件数据覆盖到外存文件设备中。

- **dup作用**

  创建一个新的文件描述符（文件描述符号是当前进程文件描述符最大的+1），并且这个文件描述符指向前一个文件描述符打开的文件

**实验三log文件要在main.c进程move_to_user后接着打开**

main.c进程是Linux初始化进程0进程，在move_to_user之后从内核态进入用户态，创建一个子进程init进程1进程，init进程打开了三个文件描述符，标准输入输出和错误输出。这三个文件描述符通过创建子进程被init这个1进程的子进程全部继承，因此所有的其他的进程因为是init进程的子进程或者孙进程就都包含了标准输入和输出和错误输出文件。这三个文件描述符变成了全局的所有1和1以上的进程都包含的文件描述符，并且都关联到相同的标准输入输出和错误输出。

log文件是记录所有进程调度轨迹的文件，它可以在init这个1进程中打开（但是要在创建子进程之前），也可以在main.c这个0进程的move_to_user之后打开，不能比move_to_user更前了，因为那样就是内核空间打开log文件了，不能在后面创建的子进程中访问到内核空间的文件描述符。

**inode和vnode**

https://www.ruanyifeng.com/blog/2011/12/inode.html

Unix标准vnode和inode 保存文件元信息，vnode包含inode。在Linux中只用了inode。inode包含文件字节数，文件数据块位置，文件创建者，文件读写权限，文件修改创建打开时间等信息。

每个硬盘分区被划分为两个部分，inode区和数据区。inode大小是128B或者256B，每间隔1kB或者2kB有一个inode。

每个inode都被inode号码标识，Linux通过inode号码来标识一个文件

```
查看文件inode信息：stat a.txt
查看硬盘所有分区inode总数和已经使用的数量：df -i
查看硬盘某个分区inode占用空间大小：sudo dumpe2fs -h /dev/hda | grep "Inode size"
查看文件inode号码：ls -i debug.txt
```

- Linux读取文件过程

  这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。

  表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。

**内核库函数只能访问内核库函数，不能访问C语言库函数printf或者用户函数**

**include/linux/sched.h  文件描述符 打开文件表 inode表**

https://blog.csdn.net/qq_36553387/article/details/118703354

这个文件定义了NR_TASKS 64也就是最大进程数量是64；定义了HZ 100也就是时钟滴答数是100个/每秒；声明了NR_OPEN 20代表最多20个打开文件

inode信息保存了文件元信息，而inode结构体是inode表的数据类型

定义了进程PCB结构task_struct

```c
struct i387_struct {
	long	cwd;
	long	swd;
	long	twd;
	long	fip;
	long	fcs;
	long	foo;
	long	fos;
	long	st_space[20];	/* 8*10 bytes for each FP-reg = 80 bytes */
};

struct tss_struct {
	long	back_link;	/* 16 high bits zero */
	long	esp0;
	long	ss0;		/* 16 high bits zero */
	long	esp1;
	long	ss1;		/* 16 high bits zero */
	long	esp2;
	long	ss2;		/* 16 high bits zero */
	long	cr3;
	long	eip;
	long	eflags;
	long	eax,ecx,edx,ebx;
	long	esp;
	long	ebp;
	long	esi;
	long	edi;
	long	es;		/* 16 high bits zero */
	long	cs;		/* 16 high bits zero */
	long	ss;		/* 16 high bits zero */
	long	ds;		/* 16 high bits zero */
	long	fs;		/* 16 high bits zero */
	long	gs;		/* 16 high bits zero */
	long	ldt;		/* 16 high bits zero */
	long	trace_bitmap;	/* bits: trace 0, bitmap 16-31 */
	struct i387_struct i387;
};

struct task_struct {
/* these are hardcoded - don't touch */
    //状态相关的变量
	long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
	long counter;
	long priority;
    //信号相关的变量
	long signal;
	struct sigaction sigaction[32];
	long blocked;	/* bitmap of masked signals */
/* various fields */
    //创建进程的用户属性uid等变量
	int exit_code;
	unsigned long start_code,end_code,end_data,brk,start_stack;
	long pid,father,pgrp,session,leader;
	unsigned short uid,euid,suid;
	unsigned short gid,egid,sgid;
	long alarm;
	long utime,stime,cutime,cstime,start_time;
	unsigned short used_math;
/* file system info */
    //进程打开文件信息
	int tty;		/* -1 if no tty, so it must be signed */
	unsigned short umask;
	struct m_inode * pwd;
	struct m_inode * root;
	struct m_inode * executable;
	unsigned long close_on_exec;
    //文件描述符表
	struct file * filp[NR_OPEN];
/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
    //进程ldt表
	struct desc_struct ldt[3];
/* tss for this task */
    //进程CPU寄存器信息
	struct tss_struct tss;
};



其中文件描述符表filp结构体在include/linux/fs.h定义，文件描述符表和打开文件表都是file 结构数组，其中file结构体的数据在两个数据结构中含义不同
struct file {
	unsigned short f_mode;    //在打开文件表中代表访问模式，只读只写等
	unsigned short f_flags;   //在打开文件表中代表open调用的flag参数
                     //在文件描述符表中代表控制文件描述符的标志。
	unsigned short f_count;   //在打开文件表中与驱动和IO相关的设置
	struct m_inode * f_inode; //在打开文件表中代表文件inode对象的引用
	off_t f_pos;     //在文件描述符表中代表文件句柄，也就是打开文件表中的偏移
    				          //在打开文件表中代表文件文件偏移量
};

在include/linux/fs.h还定义了打开文件表和inode表
struct m_inode {
	unsigned short i_mode;	//访问权限
	unsigned short i_uid;	//文件所有人
	unsigned long i_size;	//文件大小
	unsigned long i_mtime;
	unsigned char i_gid;
	unsigned char i_nlinks;	//文件链接数量
	unsigned short i_zone[9];
/* these are in memory also */
	struct task_struct * i_wait; //打开文件的进程列表
	unsigned long i_atime;
	unsigned long i_ctime;
	unsigned short i_dev;
	unsigned short i_num;
	unsigned short i_count;
	unsigned char i_lock;	//文件锁
	unsigned char i_dirt;
	unsigned char i_pipe;
	unsigned char i_mount;
	unsigned char i_seek;
	unsigned char i_update;
};
struct file {
	unsigned short f_mode;
	unsigned short f_flags;
	unsigned short f_count;
	struct m_inode * f_inode;
	off_t f_pos;
};
extern struct m_inode inode_table[NR_INODE];	//inode表
extern struct file file_table[NR_FILE];			//打开文件表





Linux的proc/pid/fd目录记录了对应pid的文件描述符表。
```

定义0进程INIT_TASK的进程PCB

```c
#define INIT_TASK \
/* state etc */	{ 0,15,15, \
/* signals */	0,{{},},0, \
/* ec,brk... */	0,0,0,0,0,0, \
/* pid etc.. */	0,-1,0,0,0, \
/* uid etc */	0,0,0,0,0,0, \
/* alarm */	0,0,0,0,0,0, \
/* math */	0, \
/* fs info */	-1,0022,NULL,NULL,NULL,0, \
/* filp */	{NULL,}, \
	{ \
		{0,0}, \
/* ldt */	{0x9f,0xc0fa00}, \
		{0x9f,0xc0f200}, \
	}, \
/*tss*/	{0,PAGE_SIZE+(long)&init_task,0x10,0,0,0,0,(long)&pg_dir,\
	 0,0,0,0,0,0,0,0, \
	 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \
	 _LDT(0),0x80000000, \
		{} \
	}, \
}
```

定义就绪队列和当前执行进程的PCB

```c
extern struct task_struct *task[NR_TASKS];
extern struct task_struct *last_task_used_math;
extern struct task_struct *current;
```

定义进程状态

```c
#define TASK_RUNNING		0
#define TASK_INTERRUPTIBLE	1
#define TASK_UNINTERRUPTIBLE	2
#define TASK_ZOMBIE		3
#define TASK_STOPPED		4
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210713162217231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTUzMzg3,size_16,color_FFFFFF,t_70)

- 文件系统为所有文件建立inode表，创建一个文件会将文件inode信息保存到inode表，inode表是操作系统自动创建的。

- 使用open系统调用会在打开文件表创建一个表项并且他的inode指针指向对应的inode表中的一个表项的地址，并且在进程pcb的task_struct的文件描述符表filp中添加一个文件描述符，文件句柄指向打开文件表创建的新表项的偏移下标
- 不同进程的文件描述符有相同的文件句柄，可能是使用了fork或者一个进程给另一个进程传递了文件描述符
- 同一进程有相同的文件句柄可能是使用dup,dup2或fcnt1

**Linux时钟中断**

在kernel/sched.c中定义了jiffies，它记录了从开机到现在的时钟中断次数

```c
long volatile jiffies=0;
```

在kernel/sched.c中还设置了发生时钟中断的中断处理函数timer_interrupt

```c
set_intr_gate(0x20,&timer_interrupt);
```

在kernel/system_call.s中实现了timer_interrupt，在这个时钟中断中每次时钟中断都会增加jiffies

```c
.align 2
timer_interrupt:
	push %ds		# save ds,es and put kernel data space
	push %es		# into them. %fs is used by _system_call
	push %fs
	pushl %edx		# we save %eax,%ecx,%edx as gcc doesn't
	pushl %ecx		# save those across function calls. %ebx
	pushl %ebx		# is saved as we use that in ret_sys_call
	pushl %eax
	movl $0x10,%eax
	mov %ax,%ds
	mov %ax,%es
	movl $0x17,%eax
	mov %ax,%fs
	incl jiffies
	movb $0x20,%al		# EOI to interrupt controller #1
	outb %al,$0x20
	movl CS(%esp),%eax
	andl $3,%eax		# %eax is CPL (0 or 3, 0=supervisor)
	pushl %eax
	call do_timer		# 'do_timer(long CPL)' does everything from
	addl $4,%esp		# task switching to accounting ...
	jmp ret_from_sys_call

```

在kernel/sched.c的sched_init函数中设置了时钟中断发生的时间间隔，他设置定时芯片的工作模式是8253模式，8253定时芯片的时钟频率是1193180Hz每秒，LATCH定义了一次时钟中断发生的时钟芯片跳数，那么一秒发生时钟中断的数目是HZ个，也就是每间隔1/HZ秒发生一次时钟终端，那么jiffies/HZ就代表系统开机的总的时间。

```c
// 设置8253模式
outb_p(0x36, 0x43);
outb_p(LATCH&0xff, 0x40);
outb_p(LATCH>>8, 0x40);

// 在 kernel/sched.c 中
#define LATCH  (1193180/HZ)

// 在 include/linux/sched.h 中
#define HZ 100
```

**fork函数**

7-11;14-18;19-22/11

220923/9-14;16-18;19-22/10h

https://blog.csdn.net/honey_qin/article/details/121003012

[(103条消息) linux0.11 fork源码详解_VirtualR_的博客-CSDN博客_linux0.11源码](https://blog.csdn.net/honey_qin/article/details/121003012)

fork系统调用使用的系统调用中断程序system_call（在kernel/system_call.s）的一个子程序sys_fork。system_call对fork系统调用进行一些检查之后跳转到sys_fork函数（call sys_fork)来完成fork系统调用。

include/linux/sched.h中，task[NR_TASKS]规定了任务数组大小64个任务

ss0:esp0指向用户程序工作在内核态使用的堆栈段，ss:esp指向用户程序工作在用户态使用的堆栈

fork函数的声明在include/unistd.h中，他的定义在init/main.c中，他的系统调用号在include/unistd.h中，他的功能函数是sys_fork在include/linux/sys.h中声明，在kernel/system_call.s中定义（因为sys_fork涉及到内存操作，所以需要使用汇编来具体操作内存单元）。

kernel/system_call.s定义了sys_fork系统调用函数实现

```
.align 2
sys_fork:
	call find_empty_process
	testl %eax,%eax
	js 1f
	push %gs
	pushl %esi
	pushl %edi
	pushl %ebp
	pushl %eax
	;copy_process使用内核栈ss0:esp0来传递数据，其中eax是任务数组项号nr
	call copy_process
	addl $20,%esp
1:	ret
```

kernel/fork.c定义了find_empty_process和copy_process。其中find_empty_process没有传递参数，返回参数保存在eax寄存器里，find_empty_process作用是分配last_pid和task[i]，也就是进程pid和进程任务号，其中last_pid是一个全局变量，不需要返回，task[i]中的任务数组项号保存在eax寄存器里面。

[关于get_limit的注解](https://www.cnblogs.com/chenglei/archive/2009/08/12/1544258.html)

[Linux内核完全注释–get_base()、get_limit() | 码农家园 (codenong.com)](https://www.codenong.com/cs106694665/)

```c
/*
 *  linux/kernel/fork.c
 *
 *  (C) 1991  Linus Torvalds
 */

/*
 *  'fork.c' contains the help-routines for the 'fork' system call
 * (see also system_call.s), and some misc functions ('verify_area').
 * Fork is rather simple, once you get the hang of it, but the memory
 * management can be a bitch. See 'mm/mm.c': 'copy_page_tables()'
 */
#include <errno.h>

#include <linux/sched.h>
#include <linux/kernel.h>
#include <asm/segment.h>
#include <asm/system.h>

extern void write_verify(unsigned long address);

long last_pid=0;

void verify_area(void * addr,int size)
{
	unsigned long start;

	start = (unsigned long) addr;
	size += start & 0xfff;
	start &= 0xfffff000;
	start += get_base(current->ldt[2]);
	while (size>0) {
		size -= 4096;
		write_verify(start);
		start += 4096;
	}
}

int copy_mem(int nr,struct task_struct * p)
{
	unsigned long old_data_base,new_data_base,data_limit;
	unsigned long old_code_base,new_code_base,code_limit;

    
    /*
    get_limit, get_base, set_limit, set_base在 include/linux/sched.h定义，都是宏
    
    #define _set_base(addr,base)  \
    __asm__ ("push %%edx\n\t" \
        "movw %%dx,%0\n\t" \
        "rorl $16,%%edx\n\t" \
        "movb %%dl,%1\n\t" \
        "movb %%dh,%2\n\t" \
        "pop %%edx" \
        ::"m" (*((addr)+2)), \
         "m" (*((addr)+4)), \
         "m" (*((addr)+7)), \
         "d" (base) \
        )
    #define _set_limit(addr,limit) \
    __asm__ ("push %%edx\n\t" \
        "movw %%dx,%0\n\t" \
        "rorl $16,%%edx\n\t" \
        "movb %1,%%dh\n\t" \
        "andb $0xf0,%%dh\n\t" \
        "orb %%dh,%%dl\n\t" \
        "movb %%dl,%1\n\t" \
        "pop %%edx" \
        ::"m" (*(addr)), \
         "m" (*((addr)+6)), \
         "d" (limit) \
        )
    #define set_base(ldt,base) _set_base( ((char *)&(ldt)) , (base) )
    #define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , (limit-1)>>12 )
    
    static inline unsigned long _get_base(char * addr)
    {
             unsigned long __base;
             __asm__("movb %3,%%dh\n\t"
                     "movb %2,%%dl\n\t"
                     "shll $16,%%edx\n\t"
                     "movw %1,%%dx"
                     :"=&d" (__base)
                     :"m" (*((addr)+2)),
                      "m" (*((addr)+4)),
                      "m" (*((addr)+7)));
             return __base;
    }

	//ldt表保存在内存中，包含两个段代码段和数据段，ldt表的段保存在GDT表的ldt段，GDT表中保存一个进程的tss段和ldt段。
	//ldt定义在task_struct里面 desc_struct ldt[3]，是一个两个struct{ long a,b}
	//把这两个a,b组合成8个字节的一个段描述符项，在这个段描述符项里面保存有三个部分的基地址，get_base就是组合这三个部分的基地址为一个32位的段基址
    #define get_base(ldt) _get_base( ((char *)&(ldt)) )

    #define get_limit(segment) ({ \
    unsigned long __limit; \
    __asm__("lsll %1,%0\n\tincl %0":"=r" (__limit):"r" (segment)); \
    __limit;})
    */
	code_limit=get_limit(0x0f); //ldtr是当前进程的ldt表在gdt表中的段选择符，ldtr+gdt表可以获得ldt表所在的基地址。
	data_limit=get_limit(0x17); //0x0f使用说明使用ldt表，也就是使用ldtr在gdt表中先找到ldt的基地址，然后用oxof的index选择ldt表的选择符
                                //0x0f代表代码段，0x17代表数据&堆栈段，都会从current->ldt中获取段限长
	old_code_base = get_base(current->ldt[1]); //ldt表保存在进程pcb的ldt中，ldt表的段保存在GDT表中
	old_data_base = get_base(current->ldt[2]); //get_base从ldt表中获得代码段或者数据段的基地址
	if (old_data_base != old_code_base)
		panic("We don't support separate I&D");
	if (data_limit < code_limit)
		panic("Bad data_limit");
	new_data_base = new_code_base = nr * 0x4000000;
	p->start_code = new_code_base; //代码起始位置
	set_base(p->ldt[1],new_code_base); //设置新进程的ldt表中的基地址
	set_base(p->ldt[2],new_data_base);
    
    /*
    copy_page_tables和free_page_tables在mm/memory.c中定义
    
    void free_page(unsigned long addr) //计算addr的内存页号并让mem_map-1
    {
        if (addr < LOW_MEM) return;   //内核地址空间不能free
        if (addr >= HIGH_MEMORY)	//超过最大内存，内存不存在
            panic("trying to free nonexistent page");
        addr -= LOW_MEM;
        addr >>= 12;
        if (mem_map[addr]--) return; //找到addr所在页面，页面计数-1，内存映射字节图实际是一个内存引用计数
        mem_map[addr]=0;
        panic("trying to free free page");
    }
    int free_page_tables(unsigned long from,unsigned long size) //free空间，源地址from，大小size
    {
        unsigned long *pg_table;
        unsigned long * dir, nr;

        if (from & 0x3fffff)   //源地址必须是4M的倍数，因为申请和释放总是一个页目录项的大小，为了简单，总是由64个任务，每个人物分配内存64M
            panic("free_page_tables called with wrong alignment");
        if (!from)
            panic("Trying to free up swapper memory space");
        size = (size + 0x3fffff) >> 22;   //页目录项数
        dir = (unsigned long *) ((from>>20) & 0xffc); //页目录项起始位置，页表从0x1000开始，紧接着页目录表 
        for ( ; size-->0 ; dir++) {
            if (!(1 & *dir))	//页目录表的最后一位p位检查这个页目录项是否被使用，如果没有被使用就跳过
                continue;
            pg_table = (unsigned long *) (0xfffff000 & *dir); //取页目录项对应的页表线性地址，前二十位
            for (nr=0 ; nr<1024 ; nr++) {//每个页表由1k个页表项，每个页表项对赢一个页框，也就是一个页面
                if (1 & *pg_table)//检查页表项（一个页）是否被使用，之后使用的才会被free，free内核函数，将mem_map引用计数的内存映射图减-1
                    free_page(0xfffff000 & *pg_table);
                *pg_table = 0; //释放页表项对应的页框内容之后清空页表项
                pg_table++;
            }
            free_page(0xfffff000 & *dir); //清空页表，因为页表在内核代码空间low_mem，所以是不能被清空的，所以个这个函数没作用。
            *dir = 0;
        }
        invalidate();//更新cr3
        return 0;
    }
    int copy_page_tables(unsigned long from,unsigned long to,long size)
    // from 和to是进程虚拟地址空间其实地址，他是nr*64M，也就是说他是64M的倍数
    {
        unsigned long * from_page_table;
        unsigned long * to_page_table;
        unsigned long this_page;
        unsigned long * from_dir, * to_dir;
        unsigned long nr;

        if ((from&0x3fffff) || (to&0x3fffff)) //from ,to 必须是4M的倍数
            panic("copy_page_tables called with wrong alignment");
        from_dir = (unsigned long *) ((from>>20) & 0xffc);    //父进程内存起始地址，进程在虚拟内存中是连续分配的。size就是取得的连续分配大小
        to_dir = (unsigned long *) ((to>>20) & 0xffc);
        size = ((unsigned) (size+0x3fffff)) >> 22;		//父进程分配内存的页目录数
        for( ; size-->0 ; from_dir++,to_dir++) {  
            if (1 & *to_dir) //子进程起始页目录项的p位，如果为1就代表这个页目录项已经被使用了。分配内存的时候总是找空mem_map并变成1，并没用说明使								用
                panic("copy_page_tables: already exist");
            if (!(1 & *from_dir)) //父进程的页目录项没有使用，跳过复制
                continue;
            //父进程的页目录项被使用了
            from_page_table = (unsigned long *) (0xfffff000 & *from_dir);//页目录项对应的页表地址
            if (!(to_page_table = (unsigned long *) get_free_page())) //获取一个空页来保存父进程页表
                return -1;	 
            *to_dir = ((unsigned long) to_page_table) | 7; //设置子进程的页目录项的u/s，R/W位
            nr = (from==0)?0xA0:1024;  //如果0号页目录项，他是内核页目录项，这个内核页目录项的页表的页表项大小是160个页，也就是头部640K是内核空间
            							 其他的页目录项对应的页表数量是1024个页，也就是4M大小的内存
            for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
                this_page = *from_page_table; //复制页表项
                if (!(1 & this_page))
                    continue;
                this_page &= ~2;   //设置父进程的页表位共享只读，子进程对父进程的页表项只能只读，设置子进程对该页只读
                *to_page_table = this_page; //拷贝父进程的页表项到子进程的页表项
                if (this_page > LOW_MEM) { //子进程使用了父进程的那个页，那么这个页的mem_map+1，引用计数+1
                    *from_page_table = this_page;
                    this_page -= LOW_MEM;
                    this_page >>= 12;
                    mem_map[this_page]++;
                }
            }
        }
        invalidate();
        return 0;
    }
    
    */
	if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
        //复制父进程的页表到子进程的页表
		printk("free_page_tables: from copy_mem\n");
		free_page_tables(new_data_base,data_limit);
		return -ENOMEM;
	}
	return 0;
}

/*
 *  Ok, this is the main fork-routine. It copies the system process
 * information (task[nr]) and sets up the necessary registers. It
 * also copies the data segment in it's entirety.
 */
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
		long ebx,long ecx,long edx,
		long fs,long es,long ds,
		long eip,long cs,long eflags,long esp,long ss)
{
	struct task_struct *p;
	int i;
	struct file *f;

    /*
    get_free_page从mem_map内存字节图（char mem_map[paging_pages）找到一个空页（从后往前找一个空页），将这个字节位置1，将这个页置0之后返回
    这个页的起始位置（32位）
    get_free_page和mem_map在mm/memory.c中定义
    
    static unsigned char mem_map [ PAGING_PAGES ] = {0,};
    unsigned long get_free_page(void)
    {
    register unsigned long __res asm("ax");

    __asm__("std ; repne ; scasb\n\t"
        "jne 1f\n\t"
        "movb $1,1(%%edi)\n\t"
        "sall $12,%%ecx\n\t"
        "addl %2,%%ecx\n\t"
        "movl %%ecx,%%edx\n\t"
        "movl $1024,%%ecx\n\t"
        "leal 4092(%%edx),%%edi\n\t"
        "rep ; stosl\n\t"
        "movl %%edx,%%eax\n"
        "1:"
        :"=a" (__res)
        :"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
        "D" (mem_map+PAGING_PAGES-1)
        );
    return __res;
    }
    
    ############################## 分割
    
    Linux0.11内存管理
    Linux0.11管理的内存是16M，可以扩充内存大小。其中LOW_MEM大小是内核代码位置，之后的的15M内存是内存管理的空间，也就是mem_map管理的内存空间
   	这个空间大小是15M，这个空间被划分为4K大小的页，页面数是paging_pages=paging_memory>>12
   	因此给出内存addr计算他的内存页号的时候是(addr-low_mem)>>12
   	
    #define LOW_MEM 0x100000
    #define PAGING_MEMORY (15*1024*1024)
    #define PAGING_PAGES (PAGING_MEMORY>>12)
    #define MAP_NR(addr) (((addr)-LOW_MEM)>>12)
    #define USED 100
    */
    
    //给新进程申请一页新内存，将当前进程的进程PCB（父进程任务结构体）复制到新内存的新任务结构体中，这个复制不会复制堆栈等的内容
	p = (struct task_struct *) get_free_page(); //申请新任务 任务结构体 一页内存
	if (!p)
		return -EAGAIN;		//如果申请不到内存返回
	task[nr] = p;	//nr是新任务任务号（和进程PID不同，进程PID是long last_pid，而任务号只有64个）
	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
    				//复制父进程的任务结构体的数据到新任务结构体
	p->state = TASK_UNINTERRUPTIBLE;
	p->pid = last_pid;			//当前进程pid
	p->father = current->pid;	//父进程pid
	p->counter = p->priority;	//时间片大小
	p->signal = 0;
	p->alarm = 0;
	p->leader = 0;		/* process leadership doesn't inherit */
	p->utime = p->stime = 0;
	p->cutime = p->cstime = 0; 	//进程用户态和内核态消耗时间（iO时间和CPU时间）
	p->start_time = jiffies;	//进程新建时间p->start_time=jiffies
    
    
    //任务状态段tss设置
	p->tss.back_link = 0;
    
    //设置新进程内核态使用的堆栈是ss0:esp0，为分配内存页的顶端
	p->tss.esp0 = PAGE_SIZE + (long) p;	
	p->tss.ss0 = 0x10;
    
   	//子进程使用父进程的段选择符和数据寄存器，蠢了eax寄存器返回0
	p->tss.eip = eip;		//子进程执行位置和父进程相同
	p->tss.eflags = eflags;
	p->tss.eax = 0;		//eax是函数返回，子进程返回eax=0
	p->tss.ecx = ecx;
	p->tss.edx = edx;
	p->tss.ebx = ebx;
	p->tss.esp = esp;	
	p->tss.ebp = ebp;
	p->tss.esi = esi;
	p->tss.edi = edi;
   	
	p->tss.es = es & 0xffff;
	p->tss.cs = cs & 0xffff;
	p->tss.ss = ss & 0xffff;
	p->tss.ds = ds & 0xffff;
	p->tss.fs = fs & 0xffff;
	p->tss.gs = gs & 0xffff;
    
    //新任务的ldt表的段选择符，_LDT宏
	p->tss.ldt = _LDT(nr);
	p->tss.trace_bitmap = 0x80000000;
	if (last_task_used_math == current)
		__asm__("clts ; fnsave %0"::"m" (p->tss.i387));
    
    //copy_mem设置新进程pcb的start_code位置位nr*64M，使用set_base，设置新进程pcb的ldt表的代码段和数据段基地址
    //使用get_base获取父进程pcb的ldt表中代码段和数据段的起始地址，使用get_limit获取代码段和数据段的段限长
    //使用copy_page_tables把父进程数据段的页表复制到子进程的页表中（利用了写时复制），设置子进程的页为只读，并让mem_map内存映射表+1
	if (copy_mem(nr,p)) {
		task[nr] = NULL;
		free_page((long) p);
		return -EAGAIN;
	}
    //打开文件表打开数量+1
	for (i=0; i<NR_OPEN;i++)
		if ((f=p->filp[i]))
			f->f_count++;
	if (current->pwd)
		current->pwd->i_count++;
	if (current->root)
		current->root->i_count++;
	if (current->executable)
		current->executable->i_count++;
    
    //在gdt表中设置tss和ldt段描述符的起始地址，实际内容保存在进程pcb的那一页里面
	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
	p->state = TASK_RUNNING;	/* do this last, just in case */
	return last_pid;
}

int find_empty_process(void)
    //分配任务号和进程pid
{
	int i;

	repeat:
		if ((++last_pid)<0) last_pid=1;
		for(i=0 ; i<NR_TASKS ; i++)
			if (task[i] && task[i]->pid == last_pid) goto repeat;
	for(i=1 ; i<NR_TASKS ; i++)
		if (!task[i])
			return i;
	return -EAGAIN;
}


```

- fork 系统调用总结

  使用find_empty_process分配任务号（保存在eax中）和进程pid（保存为last_pid的全局变量）

  使用copy_process先调用get_free_page分配新的一个页面，将父进程的pcb复制到这个新页面，设置进程运行状态p->state为uninteruptable。然后修改子进程pcb的参数，主要是eax=0（fork子进程返回0的原因），设置tss（ss0:esp0指向子进程pcb页的顶端），设置pcb的打开文件表+1。然后调用copy_mem函数获取父进程pcb的数据段和代码段基地址和段限长(get_base, get_limit)，获取子进程的数据段和代码段的起始地址(nr*64M)并设置到子进程pcb的ldt表中，然后调用copy_page_tables把父进程的数据段的页表复制到子进程的数据段的页表，并且设置子进程的页表项为只读，并且增加mem_map内存映射图+1。然后将子进程pcb的tss和ldt的起始位置写入到gdt表中。

  总之fork只拷贝了进程pcb并修改了部分属性，并且将父进程的页表复制到子进程中，整个过程并没有复制页（也复制需要写时复制）。linux0.11的内核空间大小是16M，他的页表在内核中有4页来管理内核空间。fork系统调用涉及到新进程的新建态(task_uninteruptable)和就绪态（tast_running)，只有current指向的进程才是正在运行的进程。在task_table里面是就绪队列的进程。

**内存使用**

- 内存划分情况

![Screenshot 2022-09-23 184750](D:\JavaBackend\实验\操作系统实验\实验三 进程轨迹跟踪\截图\Screenshot 2022-09-23 184750.png)

全局描述符表GDT表2K字节，每个描述符项8字节，一共256项。其中前四项分别是null,系统代码段，系统数据段，系统段。之后每两个描述符想标明一个任务，分别是任务状态段tss和局部描述符表ldt的段，状态段开始的项是4，局部描述符表段开始的项是4+1=5，那么之后要获取第NR个任务号的状态段是4\*8+NR\*16。

- GDT表结构

  ![Screenshot 2022-09-23 184955](D:\JavaBackend\实验\操作系统实验\实验三 进程轨迹跟踪\截图\Screenshot 2022-09-23 184955.png)

**schedule函数**

schedule函数是进程调度函数，这个函数在include/linux/sched.h声明，在kernel/sched.c定义。

```c
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

    /*
    #define TASK_RUNNING		0
    #define TASK_INTERRUPTIBLE	1
    #define TASK_UNINTERRUPTIBLE	2
    #define TASK_ZOMBIE		3
    #define TASK_STOPPED		4
    
    */
    
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) 
		if (*p) {
            /*
            如果任务alarm不为0并且alarm时间失效了（alarm<jiffies，jiffies是系统时间-滴答数），就给任务发送SIGALRM信号
            也就是信号为土signal的SIGALRM位变成1，这个信号的处理函数一般是终止进程
                */
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
            /*
            处于interruptable状态的进程收到一个可中断信号，就将进程设置成运行状态
            */
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
			(*p)->state==TASK_INTERRUPTIBLE)
				(*p)->state=TASK_RUNNING;
		}

/* this is the scheduler proper: */
	/*
	调度算法：
	在任务数组中选择时间片最大的那个任务运行(switch_to)，如果所有时间片都是0，也就是时间片用完，那么重新给进程分配时间片再选最大的时间片的任务运行。
	*/
	while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
    //任务切换
    /*
    switch_to在include/linux/sched.h定义为一个宏
    
    #define switch_to(n) {\
    struct {long a,b;} __tmp; \
    __asm__("cmpl %%ecx,current\n\t" \
        "je 1f\n\t" \
        "movw %%dx,%1\n\t" \
        "xchgl %%ecx,current\n\t" \
        "ljmp *%0\n\t" \
        "cmpl %%ecx,last_task_used_math\n\t" \
        "jne 1f\n\t" \
        "clts\n" \
        "1:" \
        ::"m" (*&__tmp.a),"m" (*&__tmp.b), \
        "d" (_TSS(n)),"c" ((long) task[n])); \
    }
    */
	switch_to(next);
}

```

**运行到睡眠函数 sleep_on interuptable_sleep_on sys_pause  sys_waitpid**

```c
//任务睡眠只需要设置task_state=TASK_INTERRUPTABLE或者 TASK_UNINTERUPTABLE
//任务苏醒有两种方式，一种是直接调用wake_up将task_state设置位TASK_RUNNING，或者可中断状态的任务收到一个可中断信号之后被schedule检测到修改task_state为TSAK_RUNNING，还有一种方式就是sleep_on和interruptible_sleep_on唤醒同意等待队列上的其他进程。

int sys_pause(void)
{
	current->state = TASK_INTERRUPTIBLE;
	schedule();
    //调用schedule函数之后sys_pause所在的进程已经被放弃CPU，切换到另外一个进程执行了。sys_pause想要被唤醒需要使用wake_up或者接收到信号之后被schedule的信号检查部分唤醒。
	return 0;
}

void sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	tmp = *p;
	*p = current;
	current->state = TASK_UNINTERRUPTIBLE;
	schedule();
    //前面的两句话就完成了将sleep_on所在的进程睡眠到等待队列中（每个被等待的资源都可以形成一个等待队列），并且调用schedule函数进行任务切换。后面的代码是这个进程被唤醒后执行的，唤醒这个进程的方式因为为uninterruptible所以必须是wake_up唤醒，唤醒之后这个后面的代码会唤醒p等待队列上的其他进程
	if (tmp)
		tmp->state=0;
}

void interruptible_sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	tmp=*p;
	*p=current;
repeat:	current->state = TASK_INTERRUPTIBLE;
	schedule();
    //前面两句话已经完成了睡眠和任务切换，后面的话是在interruptible_sleep_on所在的任务被唤醒重新执行后执行的，他会唤醒p队列上的下一个等待这个资源的其他进程。
	if (*p && *p != current) {
		(**p).state=0;
		goto repeat;
	}
	*p=NULL;
	if (tmp)
		tmp->state=0;
}
```

**睡眠到就绪**

```c
/*睡眠到就绪TASK_INTERRUPTIBLE TASK_UNINTERRUPTIBLE 到TASK_RUNNING，由三种方式，一种是wake_up，一种是可中断任务收获到一个可中断信号之后被schedule的信号检查部分唤醒，一种是同一等待队列上的一个被唤醒之后会唤醒同一等待队列上的任务。

wake_up 在kernel/sched.c定义

*/

void wake_up(struct task_struct **p)
{
	if (p && *p) {
		(**p).state=0;
		*p=NULL;
	}
}
```

**运行到退出**

```c
/*
kernel/exit.c包含了三个系统调用sys_kill sys_waitpid sys_exit
sys_kill(int pid,int sig)是向pid的进程发送sig信号
sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)是父进程等待子进程退出，他的参数pid和sys_kill的参数pid一样
sys_exit(int error_code) 程序退出码
*/

//释放进程pcb的页内存
void release(struct task_struct * p)
{
	int i;

	if (!p)
		return;
	for (i=1 ; i<NR_TASKS ; i++)
		if (task[i]==p) {
			task[i]=NULL;
			free_page((long)p);
			schedule();
			return;
		}
	panic("trying to release non-existent task");
}

//向进程pcb  p发送信号sig，这个和tell_father一样，就是修改pcb中的signal信号位图
static inline int send_sig(long sig,struct task_struct * p,int priv)
{
	if (!p || sig<1 || sig>32)
		return -EINVAL;
	if (priv || (current->euid==p->euid) || suser())
		p->signal |= (1<<(sig-1));
	else
		return -EPERM;
	return 0;
}

//关闭会话所有进程，相当于是send_sig修改信号位图signal的某些位
static void kill_session(void)
{
	struct task_struct **p = NR_TASKS + task;
	
	while (--p > &FIRST_TASK) {
		if (*p && (*p)->session == current->session)
			(*p)->signal |= 1<<(SIGHUP-1);
	}
}

/*
 * XXX need to check permissions needed to send signals to process
 * groups, etc. etc.  kill() permissions semantics are tricky!
 */
int sys_kill(int pid,int sig)
{
	struct task_struct **p = NR_TASKS + task;
	int err, retval = 0;

	if (!pid) while (--p > &FIRST_TASK) {  					//pid=0，sig信号发送给进程组内所有进程
		if (*p && (*p)->pgrp == current->pid) 
			if ((err=send_sig(sig,*p,1)))
				retval = err;
	} else if (pid>0) while (--p > &FIRST_TASK) {			//pid>0，sig发送给pid的那个进程
		if (*p && (*p)->pid == pid) 
			if ((err=send_sig(sig,*p,0)))
				retval = err;
	} else if (pid == -1) while (--p > &FIRST_TASK) {		//pid=-1，sig发送给第一个进程外的所有进程
		if ((err = send_sig(sig,*p,0)))
			retval = err;
	} else while (--p > &FIRST_TASK)
		if (*p && (*p)->pgrp == -pid)						//pid<-1，sig发送给进程组-pid的所有进程
			if ((err = send_sig(sig,*p,0)))
				retval = err;
	return retval;
}

static void tell_father(int pid)							//向父进程发送子进程终止信号
{
	int i;

	if (pid)
		for (i=0;i<NR_TASKS;i++) {
			if (!task[i])
				continue;
			if (task[i]->pid != pid)
				continue;
			task[i]->signal |= (1<<(SIGCHLD-1));
			return;
		}
/* if we don't find any fathers, we just release ourselves */
/* This is not really OK. Must change it to make father 1 */
	printk("BAD BAD - no father found\n\r");
	release(current);
}

int do_exit(long code)
{
	int i;
    //释放进程数据段和代码段内存
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
    //释放进程子进程，让子进程的父进程指向1进程，如果子进程僵尸态，就给1进程发送子进程终止信号
	for (i=0 ; i<NR_TASKS ; i++)
		if (task[i] && task[i]->father == current->pid) {
			task[i]->father = 1;
			if (task[i]->state == TASK_ZOMBIE)
				/* assumption task[1] is always init */
				(void) send_sig(SIGCHLD, task[1], 1);
		}
    //释放进程占有的文件，包括文件描述符表，pwd，root，i文件
	for (i=0 ; i<NR_OPEN ; i++)
		if (current->filp[i])
            /*
            (fs/open.c定义)
            int sys_close(unsigned int fd)
            {	
                struct file * filp;

                if (fd >= NR_OPEN)
                    return -EINVAL;
                current->close_on_exec &= ~(1<<fd);
                //文件描述符不存在出错
                if (!(filp = current->filp[fd]))
                    return -EINVAL;
                current->filp[fd] = NULL;	//文件描述符变空
                if (filp->f_count == 0)	//文件引用为0出错
                    panic("Close: file count is 0");
                if (--filp->f_count)	//如果文件引用计数-1之后不为0，则返回成功关闭，否则代表文件没被占用，那么释放inode节点
                    return (0);
                iput(filp->f_inode);
                return (0);
            }
            */
			sys_close(i);
	iput(current->pwd);
	current->pwd=NULL;
	iput(current->root);
	current->root=NULL;
	iput(current->executable);
	current->executable=NULL;
    //如果是会话首领并拥有控制终端，释放控制终端
	if (current->leader && current->tty >= 0)
		tty_table[current->tty].pgrp = 0;
    //如果占用了协处理器，释放协处理器
	if (last_task_used_math == current)
		last_task_used_math = NULL;
    //如果是会话首领，关闭会话所有进程
	if (current->leader)
		kill_session();
    
    //设置进程状态，退出码，通知父进程子进程终止信号，重新调度。
	current->state = TASK_ZOMBIE;
	current->exit_code = code;
	tell_father(current->father);
	schedule();
	return (-1);	/* just to suppress warnings */
}

int sys_exit(int error_code)
{
	return do_exit((error_code&0xff)<<8);
}

int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)
{
	int flag, code;
	struct task_struct ** p;
	
    //内存写验证函数。因为linux内存页写时复制（共享）机制，导致写内存的时候需要分配空间复制原来的页，这个修改不影响addr给出的线性地址，只需要在分配内存页完成之后修改页表和页表就行了。
    /*
    （kernel/fork.c定义)
    void verify_area(void * addr,int size)	//逻辑地址addr
    {
        unsigned long start;

        start = (unsigned long) addr;
        size += start & 0xfff;
        start &= 0xfffff000;
        start += get_base(current->ldt[2]);	//物理地址start
        while (size>0) {
            size -= 4096;
            write_verify(start);			//start所在的页写验证
            start += 4096;
        }
    }
    
    （mm/memory.c定义)
    void write_verify(unsigned long address)
    {
        unsigned long page;

        if (!( (page = *((unsigned long *) ((address>>20) & 0xffc)) )&1))	//如果页目录项p=0，则这个页可写
            return;
        page &= 0xfffff000;
        page += ((address>>10) & 0xffc);
        if ((3 & *(unsigned long *) page) == 1)                             //如果页不可写，对页进行复制
            un_wp_page((unsigned long *) page);
        return;
    }
    
    （mm/memory.c定义)
    void un_wp_page(unsigned long * table_entry)
    {
        unsigned long old_page,new_page;

		//如果页面只被引用一次，那么这个页面是可写的
        old_page = 0xfffff000 & *table_entry;
        if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {
            *table_entry |= 2;
            invalidate();
            return;
        }
        
        //如果页面被引用多次，那么复制页面到新页面，让旧页面内存映射图-1
        if (!(new_page=get_free_page()))
            oom();
        if (old_page >= LOW_MEM)
            mem_map[MAP_NR(old_page)]--;
        *table_entry = new_page | 7;
        invalidate();
        copy_page(old_page,new_page);
    }	
    */
	verify_area(stat_addr,4);
repeat:
	flag=0;
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
        //跳过本进程
		if (!*p || *p == current)
			continue;
        //不是当前进程的子进程，跳过
		if ((*p)->father != current->pid)
			continue;
		if (pid>0) {
			if ((*p)->pid != pid)
				continue;
		} else if (!pid) {
			if ((*p)->pgrp != current->pgrp)
				continue;
		} else if (pid != -1) {
			if ((*p)->pgrp != -pid)
				continue;
		}
        //根据子进程状态确定
		switch ((*p)->state) {
			case TASK_STOPPED:				//子进程位stopped，返回pid
				if (!(options & WUNTRACED))
					continue;
				put_fs_long(0x7f,stat_addr);
				return (*p)->pid;
			case TASK_ZOMBIE:				//子进程位zombie，将子进程用户时间和内核时间加到父进程，之后释放进程pcb并返回pid
				current->cutime += (*p)->utime;
				current->cstime += (*p)->stime;
				flag = (*p)->pid;
				code = (*p)->exit_code;
				release(*p);
				put_fs_long(code,stat_addr);
				return flag;
			default:
				flag=1;
				continue;
		}
	}
	if (flag) {					//子进程为运行态或者阻塞态，设置父进程为阻塞态并调度。在本进程被唤醒是如果由除子进程终止信号之外的信号就报错
		if (options & WNOHANG)
			return 0;
		current->state=TASK_INTERRUPTIBLE;
		schedule();
		if (!(current->signal &= ~(1<<(SIGCHLD-1))))
			goto repeat;
		else
			return -EINTR;
	}
	return -ECHILD;
}


```



**进程轨迹跟踪**

进程有五种状态，新建到就绪，就绪到运行，运行到就绪，运行到睡眠，睡眠到就绪，运行到终止

- 新建到就绪

  新建并就绪由sys_fork系统调用完成。在find_empty_process中分配任务号和pid，在copy_process中申请一页新内存复制父进程pcb到新内存中（get_free_page)，修改子进程的pcb（eax=0, ss0:esp0指向新页的顶端, 打开文件+1），使用copy_mm获取父进程代码段和数据段起始地址和限址，获取子进程起始地址，将父进程的页表复制到子进程的页表，设置子进程页表项为只读，再mem_map+1，之后把ldt段和tss段写入gdt表。

  fork系统调用的copy_process涉及到新建太和就绪态。

- 就绪到运行和运行到就绪

  就绪到运行和运行到就绪通过schedule调度函数完成。schedule函数有三个部分，第一部分处理信号（任务数组的任务如果alarm<jiffies，设置任务信号为土signal SIGALRM位=1；如果signal含有不可阻塞信号SIGKILL/SIGSTOP并且任务处于interruptable，则设置位RUNNING）；第二部分进程调度，选择时间片最大的那个进程，如果时间篇都是0，就重新分配时间片再调度；第三部分调用switch_to进行任务切换（保存当前任务的tss结构到PCB中，加载新任务的tss结构到CPU）
  
- 运行到睡眠

  运行到睡眠由sleep_on 和interruptable_sleep_on，还有主动睡眠的系统调用sys_pause和sys_waitpid

- 运行到退出(TASK_ZOMBIE TASK_STOPPED)

  sys_exit

**内存管理**

- 早期没有内存管理直接操作内存的问题

  [(103条消息) 内存管理之分段与分页_Coding~Farmer的博客-CSDN博客_内存分页分段](https://blog.csdn.net/weixin_44151739/article/details/108416656)

  [(103条消息) 内存管理＜原理篇＞（一、内存认识和无存储器抽象）_酱油师兄的博客-CSDN博客_无存储器抽象](https://blog.csdn.net/C1033177205/article/details/124529063)

  - 地址空间不隔离。一个程序可以访问到另外一个程序的位置
  - 程序地址不确定。程序被装入内存的时候位置不确定，那么如果在程序中有一个固定访问的内存单元，这个内存单元需要被重定位
  - 内存利用率低。总是把一个程序完整的放入到内存中，如果内存大小400M，而有三个进程100M 、200M、300M，那么装入一个100M和200M的进程就剩下100M的内存没用。

- 程序地址绑定方式&程序装入内存方式

  [(103条消息) 内存管理＜原理篇＞（二、地址空间和链接和装入）_酱油师兄的博客-CSDN博客_界限寄存器](https://blog.csdn.net/C1033177205/article/details/124559014)

  - 绝对装入。事先知道程序在内存中的位置，在编译链接的时候就固定程序的地址为那个位置（编译器处理），那么装入的位置就是绝对位置。适合单道程序系统
  - 静态重定位。编译器编译链接的程序是逻辑0地址开始的程序，在装入的时候操作系统修改代码将代码中的地址修改为被装入位置相加之后的地址，这样爱被装入位置代码中的地址也是一个绝对地址。和上一种方式一样。
  - 动态重定位。编译器编译链接得到的是逻辑0地址开始的程序，再装入的时候操作系统分配内存装入并不改变代码的地址。在是级CPU执行过程中，遇到一个逻辑地址，就通过一些转换比如基址寻址（基址<逻辑地址+基址<基址+限址 ），分区、分段、分页存储器都是动态重定位。

- 内存分配方式&实现多进程并发方式

  [(103条消息) 内存管理＜原理篇＞（三、交换和分区）_酱油师兄的博客-CSDN博客_下次适配算法](https://blog.csdn.net/C1033177205/article/details/124767212)

  [(103条消息) 内存管理＜原理篇＞（四、分段和分页）_酱油师兄的博客-CSDN博客_内存管理 分段 分页](https://blog.csdn.net/C1033177205/article/details/124833422)

  - 交换

    单道程序中内存一次运行一个进程，可以把进程交换到磁盘实现并发。交换的缺点是内存和磁盘交换的性能瓶颈。交换用的不多，不到不得已不用。Linux使用交换分区来实现交换的磁盘存储。交换技术会在内存不够的时候强行终止现在的进程交换到外存并开启新的进程。

  - 分区

    一个进程占用一个连续的分区，将多个进程放入内存。基址寻址就是一种分区内存分配的实现方式。

    - 固定分区和动态分区

      固定分区就是内存区大小固定，动态分区就是内存区大小不固定（进程PCB保存基址和限址）

    - 分区内存分配和管理

      使用空闲分区表或者空闲分区链来管理分区，一般使用空闲分区链。分配内存的时候可以使用首次适配（第一个满足要求的空闲分区）、最佳适配、最差适配等。

    - 分区的回收

      回收的时候和相邻的空闲分区合并

    - 分区的缺点

      分区的时候会遇到外部碎片问题，也就是总的空闲分区足够，但是没有一个单独的空闲分区满足要求导致不能分配内存。此时可以使用的技术是内存紧缩，也就是把所有分配的内存放到内存首位置同时重定位（静态重定位要修改代码中所有地址，动态重定位要修改PCB的基址等）。其他的解决方法是分段和分页。

  - 分段

    分段是一种非连续内存分配技术，用户程序被按照逻辑单元分为不同的段，比如一个函数、一个数组、一个结构体、堆、栈等都被分为不同的段。和动态分区类似，动态分区把一个进程当成一个段，而分段将一个进程按照不同的逻辑单元划分为不同的段，在寻址的时候，动态分区使用保存在PCB的基址寄存器的地址加上偏移得到实际的物理地址，而分段因为有多个段，需要用一个段表来保存段号和段基址的映射。段表的结构如下

    | 段号 | 段基址 | 保护 |
    | ---- | ------ | ---- |
    |      |        |      |

    分段时段寄存器给出的是段选择符（段号，这个段在段表的编号，CS、DS等给出段号），根据CS或DS给出的段号在段表中找到段基址，加上偏移得到诗集的物理地址。

    分段的好处是以段为单位分配内存单元，相比分区内存分配粒度更小

  - 分页

    分页是一种非连续内存分配技术，内存被分配为固定大小的页，Linux是4K为单位（磁盘块是512B为单位）。内存没4K被分为一个快，称为页框，4G大小的内存有1M页框；用户程序也被分为4K大小的一块，称为页面。页面和页框的映射通过页表来标记。页表结构

    | 页号 | 页框号 | 保护 |
    | ---- | ------ | ---- |
    |      |        |      |

    分页相比于分段来说减少了外部碎片。分段和分页实际是分区的升级版本，一个使用段为单位，一个使用固定大小的页单位进行内存分配。分段和分页都需要空闲列表或者空闲链表来管理空闲分区，分段会有外部碎片问题，而分页有内部碎片问题。

    分页给出的是虚拟地址，这个地址除以4K得到页号，取余4K得到页内偏移，页号在页表中查找得到页框号，页框号*4K得到页框基址，最后实际地址是页框基址+页内偏移得到实际地址。

- 分段和分页的区别和联系

  [分页和分段有什么区别（内存管理）？ - holmes_now - 博客园 (cnblogs.com)](https://www.cnblogs.com/holmes7521/p/15118070.html)

  [(103条消息) 分页与分段的主要联系和区别_Octoberone的博客-CSDN博客_分段和分页的区别和联系](https://blog.csdn.net/qq_38855717/article/details/80552459)

  - 联系

    两者都是非连续内存分配，都需要经过地址映射机构MMU进行地址转换

  - 区别

    - 目的不同。分段是满足用户需要，段是信息逻辑单位，存储完整的信息；分页是操作系统内存管理的需要
    - 信息共享。段是信息的逻辑单位，方便共享和存储。
    - 大小不同。段的大小不固定，页的大小固定
    - 地址空间不同。段式存储器需要用户程序给出二维地址，需要段号和段内偏移；而页式存储器需要用户给出的是一维线性地址，地址变换机构通过除以页框大小得到页号，区域页框大小得到页内偏移。
    - 内存碎片不同。两者都减少了内存碎片，分页存在内部碎片问题，分段存在外部碎片问题。

- 段页式存储器

  [GDT,LDT,GDTR,LDTR 详解,包你理解透彻 | 技术部落 (techbulo.com)](https://www.techbulo.com/708.html)

  [(103条消息) 分页和分段的联系和区别_FishBear_move_on的博客-CSDN博客](https://blog.csdn.net/haluoluo211/article/details/42263281)

  [(103条消息) 操作系统——内存管理——分段和分页_zhaohong_bo的博客-CSDN博客](https://blog.csdn.net/zhaohong_bo/article/details/90166135)

  [(103条消息) GDT和LDT详解_关关纠纠的博客-CSDN博客_gdt ldt](https://blog.csdn.net/qq_42762094/article/details/120423812)

  Linux的段页式存储器一个CPU只有一个GDT表，GDT表中给出系统所有段的段描述符项，同时也包含每个进程的LDT表，每个进程的LDT表也包含在GDT表中。GDTR有48位，高32位给出GDT表的物理地址，低16位是GDT表的表限长；LDTR是16位，LDTR实际上是GDT表的段选择子，高13位给出LDT表在GDT表中的编号。GDT表或者LDT表段选择子13位index，规定最多8K个段。

  Linux寻址有两个指令的差别，一种是访问内核空间的数据和程序只是用GDT表，一种是访问用户空间的程序需要使用GDT表和LDT表。

  访问内核空间的时候，CPU给出的逻辑地址是一个二维地址（段选择子：段内偏移），段选择子（CS,DS,ES,FS,SS,GS)的T1=0位代表这个段是系统段使用GDT表，他有两位的RPL请求特权级，他的高13位index是GDT表中的编号，index*8+GDTR的32位基地址=指令在GDT表中的段描述符项的物理地址，GDT表中一个段描述符项有8个字节64位，包括32位段地址，20位段限长，DPL段描述符特权级2位。从段描述符项中取出段基地址+段内偏移得到指令的物理地址。

  访问用户空间的时候，CPU给出的逻辑地址是一个二维地址（段选择子：段内偏移），段选择子的T1=1代表使用LDT表，此时会使用LDTR的高13位作为段号在GDT表中获得LDT表的段描述符项（LDT表存放在内存中被当成一个段处理），这个段描述符项的段基地址是LDT表的物理地址，这个32位的物理地址+index*8得到指令的段描述符项地址，然后从LDT表的段描述符项中获得段基地址+偏移地址得到指令的物理地址。

  从上面段式存储器获得的线性地址是一个一维地址，他的高10位是页目录号，中间10位是页号，最低12位是页内偏移。从CR3寄存器获得页目录表的物理地址32位，CR3+页框号*4=指令所在页目录项（页表项大小4字节），页目录项的高20位是页表地址的高20位，页表地址高20位\*4K+页号\*4=页表项，页表项高20位\*4K+页内偏移=指令物理地址。页内偏移12位满足页大小4K

- 请求特权级

  [(103条消息) Linux从头学12：读完这篇【特权级】文章，你就比别人更“精通”操作系统！_IOT物联网小镇的博客-CSDN博客_linux特权级](https://blog.csdn.net/jchen1218/article/details/120321176)

**glibc/系统调用/c库函数**

[(103条消息) glibc的头文件 linux_Glibc、系统调用和C库函数_勃勃大师兄的博客-CSDN博客](https://blog.csdn.net/weixin_36015213/article/details/112843302?ops_request_misc=&request_id=&biz_id=102&utm_term=glibc的头文件 linux&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-1-112843302.nonecase)

[glibc_百度百科 (baidu.com)](https://baike.baidu.com/item/glibc/10058561?fr=aladdin)

[(103条消息) linux 如何查找命令的路径（which,whereis命令）_IT新人一枚的博客-CSDN博客_linux 查询命令路径where](https://blog.csdn.net/itbaoku1352/article/details/120220326)

c库函数的头文件保存在/usr/include里面，包括系统调用API和glibc头文件，应用程序使用的函数一方面是系统调用API，另一方面也可以是glibc头文件，区别在于系统调用API是内核提供的头文件，而glibc是一个独立的c语言运行时库函数提供的头文件

系统调用API的头文件保存在/usr/include里面，他是一个宏，他把系统调用号放到eax寄存器，调用0x80中断进行处理。也就是说系统调用API的实现是一个0x80的中断处理程序，他的实现是内核实现的。

glibc是一个c语言库函数，他的头文件放到/usr/include里，他的链接库在/usr/local/lib里面（下面的.so文件和.a文件是链接库文件libc.so）。glibc的函数可以不使用系统调用，而系统调用的函数基本上都是内核函数。stdio是glibc库文件的头文件。

linux指令使用which指令查找指令的执行程序位置。whereis查看文件的位置，which查看指令的位置。which在PATH包含usr/bin;usr/local/bin等位置。gcc编译器程序保存在usr/local/bin下面，gcc编译器使用glibc库函数保存在/usr/local/lib下面的.so和.a库文件中。编译器将源代码编译成中间文件.o文件，之后链接器从库文件提取库函数，和其他.o文件一起链接成可执行程序。

ubuntu 查看glibc版本使用lld --version命令

头文件并不是必须的，只要制定了库文件，而库文件包含这个函数，那么编译就不会报错。glibc的头文件是不用显示的在c文件中给出的，因为gcc会从库文件中获得这个程序进行链接。头文件作用主要有两个，一个是通知用户库文件中的函数和调用方法，另外一个是编译器类型检查，如果没有头文件，那么就算库文件存在这个函数，程序会成功链接这个函数，但是如果传入参数类型和数量错误是不会被发现的，这样的坏处是运行的时候会出问题。

**Linux版本**

https://blog.csdn.net/debug_cpp/article/details/2687067

https://blog.csdn.net/m0_46278037/article/details/115195273

[https://zh.wikipedia.org/wiki/Linux%E5%86%85%E6%A0%B8](https://zh.wikipedia.org/wiki/Linux内核)

```
查看Ubuntu版本
cat /etc/issue
查看内核版本
uname -r
查看glibc版本
lld --version

内核代码文件保存在
/usr/src
```

Linux内核有三个不同的命名方案。

早期版本：第一个版本的内核是0.01，其次是0.02,0.03,0.10,0.11,0.12（第一[GPL](https://zh.wikipedia.org/wiki/GPL)版本),0.95,0.96,0.97,0.98,0.99及1.0。[[77\]](https://zh.wikipedia.org/wiki/Linux内核#cite_note-77)，从0.95版有许多的补丁发布于主要版本版本之间。

旧计划（1.0和2.6版之间)，版本的格式为A.B.C，其中A,B,C代表：**A**大幅度转变的内核，这是很少发生变化，只有当发生重大变化的代码和内核发生才会发生，在历史上曾改变两次的内核：1994年的1.0及1996年的2.0； **B**是指一些重大修改的内核，内核使用了传统的奇数次要版本号码的软件号码系统（用偶数的次要版本号码来表示稳定版本）；**C**是指轻微修订的内核，这个数字当有安全补丁，bug修复，新的功能或驱动程序，内核便会有变化。自2.6.0（2003年12月）发布后，人们认识到，更短的发布周期将是有益的。自那时起，版本的格式为A.B.C.D，其中A,B,C,D代表：**A**和**B**是无关紧要的，**C**是内核的版本，**D**是安全补丁。

自3.0（2011年7月）发布后，版本的格式为3.A.B，其中A,B代表：**A**是内核的版本，**B**是安全补丁。而4.0（2015年4月）发布后，则延续3.A.B的命名格式，只是将主版号变更为4。

**系统调用追踪**

https://stackoverflow.com/questions/175882/whats-the-algorithm-behind-sleep

sleep让进程睡眠，同时设置定时器，在每次调度过程中检查

**glibc源代码网站**

[https://www.j10.monster/Glibc-source-browser/glibc_src_2.23/glibc_src_2.23/stdio-common](https://www.j10.monster/Glibc-source-browser/glibc_src_2.23/glibc_src_2.23/stdio-common/)

### 实验4-内核级线程的切换

[(104条消息) 操作系统学习笔记——用户级线程和核心级线程_qq_42518941的博客-CSDN博客_用户级线程举例](https://blog.csdn.net/qq_42518941/article/details/119145575)

**内存映射表MMU**

[一文读懂Linux内核内存映射与页表 (qq.com)](https://view.inews.qq.com/k/20220818A03GM000?web_channel=wap&openApp=false)

MMU是将虚拟地址映射到物理地址的内存映射机构，就是管理页表的一个芯片

**CPU TSS段，LDT表等都是全局变量，CPU执行的时候会load这些全局变量从而切换CPU的数值**

**用户级线程和内核级线程**

[(104条消息) 操作系统学习笔记——用户级线程和核心级线程_qq_42518941的博客-CSDN博客_用户级线程举例](https://blog.csdn.net/qq_42518941/article/details/119145575)

用户级线程是跑在用户空间里面的程序，他的线程跳转需要用户自己手动设置，需要用户自己编写yield程序去设置跳转到线程的操作。yeild程序的主要功能有两个，一个是切换用户栈，一个是切换cs:ip。用户及线程的缺点是如果一个用户级线程发生阻塞（读取文件），那么整个程序都将被阻塞。

现代操作系统是基于多核系统的。多核系统和多处理器系统的区别是多处理器系统每个CPU占有一个MMU和cache，而多核系统共用一个cache和MMU（他们内存和外存都是共享的）。Linux是基于多核系统的多线程操作系统，他是多线程而不是多进程的操作系统，主要区别就在于这些线程公用cache和MMU。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c4f55a9055004d55801554517a1fd59c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTE4OTQx,size_16,color_FFFFFF,t_70#pic_center)

**Linux多线程的实现，用户级线程到内核级线程的映射**

内核级线程切换分为4个步骤：

- 系统调用（启动磁盘等触发阻塞的系统调用）或者时钟中断触发schedule函数执行调度程序

  - 磁盘系统调用触发系统调度

    int80会将用户程序ss:sp,EFLAGS，CS:IP如内核栈（程序TCB所在页的高地址空间），然后执行system_call中断处理程序。system_call中断处理程序如下

    ```
    .align 2
    bad_sys_call:
    	movl $-1,%eax
    	iret
    .align 2
    reschedule:
    	pushl $ret_from_sys_call
    	jmp schedule
    .align 2
    system_call:
    	cmpl $nr_system_calls-1,%eax
    	ja bad_sys_call
    	push %ds
    	push %es
    	push %fs
    	pushl %edx
    	pushl %ecx		# push %ebx,%ecx,%edx as parameters
    	pushl %ebx		# to the system call
    	movl $0x10,%edx		# set up ds,es to kernel space
    	mov %dx,%ds
    	mov %dx,%es
    	movl $0x17,%edx		# fs points to local data space
    	mov %dx,%fs
    	call sys_call_table(,%eax,4)
    	pushl %eax
    	movl current,%eax
    	cmpl $0,state(%eax)		# state
    	jne reschedule
    	cmpl $0,counter(%eax)		# counter
    	je reschedule
    ret_from_sys_call:
    	movl current,%eax		# task[0] cannot have signals
    	cmpl task,%eax
    	je 3f
    	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?
    	jne 3f
    	cmpw $0x17,OLDSS(%esp)		# was stack segment = 0x17 ?
    	jne 3f
    	movl signal(%eax),%ebx
    	movl blocked(%eax),%ecx
    	notl %ecx
    	andl %ebx,%ecx
    	bsfl %ecx,%ecx
    	je 3f
    	btrl %ecx,%ebx
    	movl %ebx,signal(%eax)
    	incl %ecx
    	pushl %ecx
    	call do_signal
    	popl %eax
    3:	popl %eax
    	popl %ebx
    	popl %ecx
    	popl %edx
    	pop %fs
    	pop %es
    	pop %ds
    	iret
    
    ```


  ​		system_call执行完成之后内核栈的内容变化为。其中ds,es,fs,edx,ecx,ebx,eax等压栈操作是system_call的内容，前面是int80的操作。

  ![img](https://img-blog.csdnimg.cn/ea58d55547a7471eb3dd48340c7ac672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTE4OTQx,size_16,color_FFFFFF,t_70#pic_center)

  ​		在system_call的后面部分的代码会检测当前线程如果不是运行状态或者时间片用完机会触发调度（如果时间片没有用完就不会出发调度，而是继续执行系		统调用）

  ```
  	cmpl $0,state(%eax)		# state
  	jne reschedule
  	cmpl $0,counter(%eax)		# counter
  	je reschedule
  	
  ```

  ​		ret_from_sys_call会让内核线程从内核态返回到用户态，他的弹栈是system_call压入的内容，最后使用iret指令从内核态返回到用户态（类似int80传入的		那些参数的弹栈处理

  - 时钟中断触发系统调度

    ```c
    .align 2
    timer_interrupt:
    	push %ds		# save ds,es and put kernel data space
    	push %es		# into them. %fs is used by _system_call
    	push %fs
    	pushl %edx		# we save %eax,%ecx,%edx as gcc doesn't
    	pushl %ecx		# save those across function calls. %ebx
    	pushl %ebx		# is saved as we use that in ret_sys_call
    	pushl %eax
    	movl $0x10,%eax
    	mov %ax,%ds
    	mov %ax,%es
    	movl $0x17,%eax
    	mov %ax,%fs
    	incl jiffies
    	movb $0x20,%al		# EOI to interrupt controller #1
    	outb %al,$0x20
    	movl CS(%esp),%eax
    	andl $3,%eax		# %eax is CPL (0 or 3, 0=supervisor)
    	pushl %eax
    	call do_timer		# 'do_timer(long CPL)' does everything from
    	addl $4,%esp		# task switching to accounting ...
    	jmp ret_from_sys_call
    	
    	
    	
    	
    void do_timer(long cpl)
    {
    	extern int beepcount;
    	extern void sysbeepstop(void);
    
    	if (beepcount)
    		if (!--beepcount)
    			sysbeepstop();
    
    	if (cpl)
    		current->utime++;
    	else
    		current->stime++;
    
    	if (next_timer) {
    		next_timer->jiffies--;
    		while (next_timer && next_timer->jiffies <= 0) {
    			void (*fn)(void);
    			
    			fn = next_timer->fn;
    			next_timer->fn = NULL;
    			next_timer = next_timer->next;
    			(fn)();
    		}
    	}
    	if (current_DOR & 0xf0)
    		do_floppy_timer();
    	if ((--current->counter)>0) return;
    	current->counter=0;
    	if (!cpl) return;
    	schedule();
    }
    ```

- schedule函数执行系统调度，选择一个就绪的线程

- schedule后面的switch_to函数将执行线程的切换

- 如果是进程切换，还需要切换内存映射表（多处理器系统切换MMU，Linux是多核系统不用切换MMU）

**sys_fork执行过程以及调度过程**

（cpu栈寄存器只有ss:esp，ss0:esp0是保存在pcb里面的内核栈地址，他在执行int0x80的时候加载到ss:esp里面指向内核栈）

（c语言函数调用A(int b) 会被编译成push b, call A, add 4, %esp；也就是call的返回地址是add 4,%esp，将A函数的参数弹出栈）

int0x80先设置ss:esp栈指针指向内核栈，然后保存调用int0x80中断的下一条指令，一般是一个赋值到pcb指针的指令，int0x80会在内核栈压入ss:esp,eflags,cs:ip，都是用户程序的栈和返回指令地址。然后进入system_call系统调用处理程序，他先压入一些寄存器，然后根据eax传入的的NR_fork中断调用号call sys_call_table+NR_fork*6(cs2字节，eip4字节)找到sys_fork中断处理程序执行。

sys_fork中断处理程序首先find_empty_process分配任务号和进程pid，然后使用copy_process，分配一页内存把父进程pcb复制到内存中去，然后修改子进程pcb的father，counter等参数；最后根据父进程的数据size分配页目录项和页表项，将页表项的数据赋值为父进程页表项，同时设置这些页表指向的页面的mem_map引用计数加1，设置子进程的页表项为只读。（在进行写变量的时候，会首先对这个变量所在的页进行写验证，如果这个页面是只读的，那么就会重新分配一个页面赋值父进程的页面，然后在分配的页面修改这个变量，同时把这个页面的地址赋值给页表项，同时修改mem_map减1)

sys_fork修改子进程的pcb的时候，父进程和子进程的内核栈的数据分别是

![fork调用内核栈情况](D:/JavaBackend/实验/操作系统实验/实验4 基于内核栈的进程切换/截图/fork调用内核栈情况.PNG)

在system_call后面调用sys_fork之后，是一个reschedule函数，这个函数压入ret_from_sys_call地址，跳转到schedule函数执行，schedule函数先进行系统调度找到下一个执行的目标进程，然后调用switch_to函数，参数为pnext, LDT(next)，以及addl 8,%esp的返回地址，然后执行switch_to切换进程，switch_to 切换进程函数如下

```
.align 2
switch_to:
    //因为该汇编函数要在c语言中调用，所以要先在汇编中处理栈帧
	pushl %ebp
	movl %esp,%ebp
	pushl %ecx
	pushl %ebx
	pushl %eax

    //先得到目标进程的pcb，然后进行判断
    //如果目标进程的pcb(存放在ebp寄存器中) 等于   当前进程的pcb => 不需要进行切换，直接退出函数调用
    //如果目标进程的pcb(存放在ebp寄存器中) 不等于 当前进程的pcb => 需要进行切换，直接跳到下面去执行
	movl 8(%ebp),%ebx
	cmpl %ebx,current
	je 1f

    /** 执行到此处，就要进行真正的基于堆栈的进程切换了 */
	
        // PCB的切换
	movl %ebx,%eax                   	;%ebx 保存目标进程pcb地址
	xchgl %eax,current					;eax指向当前进程pcb地址，current/ebx指向目标pcb
	
	// TSS中内核栈指针的重写
	movl tss,%ecx						;cpu按照tss切换内核栈，这种特性要被维护，所以使用tss0来保存目标pcb内核栈
	addl $4096,%ebx
	movl %ebx,ESP0(%ecx)

	//切换内核栈
	movl %esp,KERNEL_STACK(%eax)		;保存当前esp到当前进程的pcb中，读取目标进程pcb的内核栈到esp中
	movl 8(%ebp),%ebx
	movl KERNEL_STACK(%ebx),%esp

	//LDT的切换
	movl 12(%ebp),%ecx					;切换LDT表
	lldt %cx
	movl $0x17,%ecx
	mov %cx,%fs
	
	cmpl %eax,last_task_used_math
	jne 1f
	clts
	
	//在到子进程的内核栈开始工作了，接下来做的四次弹栈以及ret处理使用的都是子进程内核栈中的东西

1:	popl %eax							;切换内核栈之后执行的程序已经是目标进程的程序了，这段话是返回到目标进程的用户空间。
	popl %ebx
	popl %ecx
	popl %ebp
	ret
```

switch_to函数在父进程中首先pop一些参数之后会ret回到reschedule函数的下一条语句add 8,%esp，然后ret跳转到ret_from_sys_call函数，这句话进一步回复一些寄存器之后使用iret指令回到父进程的用户程序中；在子进程中，switch_to函数pop一些参数之后ret跳转到first_return_kernel函数，这个函数进一步弹出一些寄存器之后iret回到子进程的用户程序。

### 实验5-信号量的实现

[操作系统实验05-信号量实现和应用 - mirage_mc - 博客园 (cnblogs.com)](https://www.cnblogs.com/mirage-mc/p/12913993.html)

**关中断和开中断**

[(104条消息) 汇编指令CLI/STI_小蚂蚁_CrkRes的博客-CSDN博客_cli指令](https://blog.csdn.net/zang141588761/article/details/52325106)

c语言cli()和sti()是关中断和开中断，使用cli + sti可以实现原子操作，内核中修改ss:esp的时候需要使用cli+sti变成原子操作

系统调用是一个中断处理函数，系统调用函数是原子操作的，原因就在于进入int0x80的时候，也就是执行中断处理函数的时候会使用cli+sti关中断，那么中断处理函数就变成了原子操作。

中断处理程序分为可屏蔽中断和不可屏蔽中断，不可屏蔽中断会使用cli和sti操作标志寄存器eflags的IF位，从而让IF=0实现程序在执行这个中断的时候不会相应其他的中断，也就是关中断。（内核线程分为可中断线程和不可中断线程，可中断线程可以用信号唤醒（信号或者wake_up主动唤醒），而不可中断线程必须使用wake_up主动唤醒。

中断分为内中断和外中断，内中断是程序指令引发的，比如int0x80系统调用/除0等等；外中断分为可屏蔽外中断和不可屏蔽外中断，是有外部设备引发的中断，可屏蔽外中断cpu可以拒绝执行，不可屏蔽外中断CPU必须执行而不用理会IF状态标志。时钟中断

**结构体struct/c语言基本数据类型/指针的底层实现**

[(104条消息) 汇编中movl,movw,movb的作用_Lawrence_121的博客-CSDN博客_movw](https://blog.csdn.net/m0_37806112/article/details/80549927)

[(104条消息) AT&T汇编——MOV指令_z974656361的博客-CSDN博客_movl和movq](https://blog.csdn.net/z974656361/article/details/107133955)

[汇编指令：lea - YangARTuan - 博客园 (cnblogs.com)](https://www.cnblogs.com/YangARTuan/p/11628591.html)

[(104条消息) C语言 数组定义和使用 - C语言零基础入门教程_猿说编程的博客-CSDN博客_c语言数组声明](https://blog.csdn.net/ZhaDeNianQu/article/details/119725736)

[c语言详解sizeof - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/74066384)

[(104条消息) C语言 -- 字符串的使用及内存分配_FebSummer的博客-CSDN博客_字符串内存分配](https://blog.csdn.net/u012834152/article/details/108358996)

sizeof是一个操作符，而不是函数，类似++一样，他是取内存字节数的操作

movq 8字节；movl 操作4字节；movw 2字节；movb 1字节

leaq	-40(%rbp), %rax; 把-40(%rbp)的内存地址放到rax寄存器，mov是把内存的内容放到寄存器。计算地址方-40+%rbp

基本数据类型/结构体/指针/数组等数据类型的实现是由编译器实现的。

- 在编译的时候，把printf和string等字符串数组/全局变量放到数据区，把函数的局部变量/函数传递的参数放到栈上申请内存；

- 在编译的时候，基本数据类型变量的定义会在x(%ebp)上开辟一个基本数据类型大小的栈空间（ebp指向用户栈的底端，%esp指向用户栈的顶端，x是局部变量/参数申请栈上的内存区域），基本数据类型变量的赋值会使用mov $y, x(%ebp)将字面值使用mov传送指令传送到对应变量申请的栈空间；

- 在编译的时候，结构体的数据类型分配的栈空间总是以4字节为单位分配的，分配的内存空间总是结构体所定义的基本数据类型的所有字节数的最小的4的倍数的字节，也就是sizeof= (基本数据类型和+4)/4\*4，多出的分配的字节作为填充字节，没有被使用。比如struct T{char a; int b}，基本数据类型的字节数的和是1+4=5个字节，但是编译器在分配内存的时候会分配sizeof(struct T)=(5+4)/4\*4=8个字节，其他的字节被作为填充字节没有被使用，一种底层实现是***movb 0,-4(%ebp) ;  movl 0, -8(%ebp) **  ，也就是给char放入了三个填充字节而没有使用  

- 在编译的时候，局部变量的基本数据类型的数组的定义是在栈空间上分配内存的，c语言基本数据类型数组的定义和初始化为char ctmp[]={0,0,0}，这里ctmp并不是一个独立的变量，他是一个数组，他只会被分配在栈上3个字节，ctmp会被编译成这3个字节开头的栈地址-3(%ebp)，那么在printf("%p", ctmp)中，传送给printf参数数据地址是lea -3(%ebp), eax；ctmp数组的栈空间的内存的初始化由mov完成，而不是像printf或者字符串数组char* p="abcdefg"一样被放到数据区，也就是使用大括号{0,0,0}初始化的基本数据类型数组的初始化是在栈上分配内存和初始化的，是在代码汇编代码中使用mov指令一个一个数组的字节进行初始化的，对于char ctmp[]={0,0,0}的一种初始化方案是**movw -3(%ebp); movb -1(%ebp)**；基本数据类型数组分配的栈空间大小是**基本数据类型字节数\*基本数据类型个数**

- 在编译的时候，字符串局部变量的定义是在数据区分配内存的，也就是char *p="abcdefg"是和printf中的字符数组一样被放到数据区分配内存保存字符串“abcdefg”的，但是在栈区依旧会分配一个内存4字节变量保存数据区的内容的地址，也就是p是栈上的一个4字节的变量，他保存了“abcdefg”字符串在数据区的地址，这个过程在编译到的汇编代码是**data: "abcdefg"          code:  leal data, -4(%ebp) **，也就是字符串数组保存到数据区，然后使用lea把数据区的地址赋值给栈局部变量的位置p；当使用p[1]获取字符串数组中的一个元素的时候，会先加载啊栈上的变量到eax，然后eax增加[  1\*sizeof(基本数据类型)  ]个字节的数字（增加的数字由编译器计算得到），然后使用mov指令从eax指向的内存单元读取数字到eax寄存器，这个过程用汇编指令完成为**mov -4(%ebp), %eax;  add 1, %eax; mov (%eax), %eax**,  寄存器eax的数值被传递给printf函数或者其他操作

- 在编译的时候，结构体数组并不是按照结构体来分配内存的，而是按照结构体的基本数据类型来分配内存的，也就是struct T p[2] 并不会分配(sizeof(T)+4)/4*2，而是把基本数据类型打散之后分配内存的，如果struct T{char a,b,c} ，那么分配的内存是sizeof(char)\*3=6个字节char，分配的内存在栈上，而对于p的初始化依旧使用mov指令将字面值赋值给栈上的内存；当我们使用p[1].a获取p中的元素的变量的时候，实际汇编将p[1].a解释称栈上的一个内存-4(%ebp)放到eax寄存器，汇编代码为mov -4(%ebp), %eax。局部变量结构体数组分配内存和使用方式实际上转换成局部变量基本类型数组分配内存和使用方式，只是局部变量字符串数组分配内存和使用方式不同于上面两种。

- 全局变量都是按照基本类型分配内存的。全局基本类型，全局结构体，全局基本类型数组，全局结构体数组，全局字符串数组都是按照基本数据类型分配内存，但是内存分配需要是4的倍数，所以会有编译器进行数据对齐，但是使用sizeof并不会显示这些对齐数据(.align)。字符串数组分配的内存要+1，因为会有一个'\0'字符，字符串数组无法通过sizeof来获取字符串数组分配的内存大小，因为字符串数组是一个指针类型，sizeof总是获取的指针的字节数4，这样就不能获取字符串数组的内存大小。全局基本数据类型数组int a[10]={0}和全局字符串数组char* a="abc"中前一个a和后一个a是不同的，前一个a直接指向的是分配的int数组的首地址，而后一个a直接指向的是一个4位的指针，他保存了字符串"abc"被分配的内存的首地址。

  ```c
  #include<stdio.h>
  
  struct T{
  	char a;
  	short b;
  	int c;
  };
  
  struct S{
  	long long a;
  	long b ;
  };
  
  struct E{
  	char a,b,c;
  };
  
  
  //global variable
  //global basic type
  char ga =4;
  short gb = 1;
  int gc = 2 ;
  
  //global struct type
  struct E gpEE = {0,1,2} ;
  
  //global basic type list
  char gpchar[] = {1,2,3} ;
  
  //global character list
  char * gcl = "abcefghigkl" ;
  
  //global struct list
  struct E gpE[] = {
  	[0]{
  		.a=1,.b=2,.c=3
  	},
  	[1]{
  		.a=4,.b=5,.c=6
  	}
  } ;
  
  
  int main(){
  	printf("==============local basic type\n");
  	
  	char a=0;
  	short b=0;
  	int c=0;
  	long d=0;
  	long long e=0;
  	float f=0;
  	double g=0;
  	printf("char:  		%lu\n",sizeof(a)) ;
  	printf("short: 		%lu\n",sizeof(b)) ;
  	printf("int: 			%lu\n",sizeof(c)) ;
  	printf("long:			%lu\n",sizeof(d)) ;
  	printf("long long:		%lu\n",sizeof(e)) ;
  	printf("float:			%lu\n",sizeof(f)) ;
  	printf("double:		%lu\n",sizeof(g)) ;
  	
  	printf("================local struct\n") ;
  	printf("================\n");
  	struct T tmp={0,0,0};
  	printf("st:			%lu\n",sizeof(tmp));
  	
  	printf("================\n");
  	struct S stmp={0,0} ;
  	printf("ss:			%lu\n",sizeof(stmp));
  	
  	printf("================local basic type list\n");
  	struct T *ptmp = &tmp ;
  	printf("*ptmp:			%p\n",ptmp) ;
  	
  	char ctmp[]={0,0,0} ;
  	printf("sizeof(ctmp):		%lu\n",sizeof(ctmp));
  	printf("length(ctmp):		%lu\n",sizeof(ctmp)/sizeof(ctmp[0]));
  	printf("sizeof(ctmp[0]):	%lu\n",sizeof(ctmp[0]) );
  	printf("ctmp address:		%p\n",ctmp) ;
  	short shtmp[]={0,0,0} ;
  	printf("sizeof(shtmp):		%lu\n",sizeof(shtmp));
  	printf("length(shtmp):		%lu\n",sizeof(shtmp)/sizeof(shtmp[0]));
  	printf("sizeof(shtmp[0]):	%lu\n",sizeof(shtmp[0]) );
  	printf("shtmp address:		%p\n",shtmp) ;
  	int itmp[]={0,0,0};
  	printf("sizeof(itmp):		%lu\n",sizeof(itmp));
  	printf("length(itmp):		%lu\n",sizeof(itmp)/sizeof(itmp[0]));
  	printf("sizeof(itmp[0]):	%lu\n",sizeof(itmp[0]) );
  	printf("itmp address:		%p\n",itmp) ;
  	
  	printf("================local character list\n");
  	
  	char *pchar = "abcdefg";
  	printf("pchar:			%s\n",pchar);
  	printf("pchar[0]:		%c\n",pchar[1]);
  	printf("sizeof(pchar):		%lu\n",sizeof(pchar)) ;
  	printf("length(pchar):		%lu\n",sizeof(pchar)/sizeof(pchar[0])) ;
  	printf("address(pchar):	%p\n",pchar) ;
  	
  	
  	
  	printf("================local struct list \n");
  	struct E pE[2]={
  		[0]{
  			.a = 0,
  			.b = 1,
  			.c = 2
  		},
  		[1]{
  			.a=3,
  			.b=4,
  			.c=5
  		}
  	} ;
  	printf("pE[1].a:		%d\n", pE[1].a) ;	
  	printf("sizeof(pE):		%lu\n", sizeof(pE) ) ;
  	
  	
  	
  	printf("\n\n\n\n\n") ;
  	printf("================global basic type\n") ;
  	printf("sizeof(ga):			%lu\n", sizeof(ga) ) ;
  	printf("sizeof(gb):			%lu\n", sizeof(gb) ) ;
  	printf("sizeof(gc):			%lu\n", sizeof(gc) );
  	printf("address(ga):			%p\n", &ga ) ;
  	printf("address(gb):			%p\n", &gb ) ;
  	printf("address(gc):			%p\n", &gc );
  	
  	printf("================global struct\n") ;
  	printf("sizeof(gpEE):		%lu\n", sizeof(gpEE) ) ;
  	printf("address(gpEE):			%p\n", &gpEE );
  	
  	printf("================global basic type list\n") ;
  	printf("sizeof(gpchar):	%lu\n", sizeof(gpchar)) ;
  	printf("address(gpchar):	%p\n", gpchar );
  	printf("gpchar[1]:		%d\n", gpchar[1]);
  	printf("sizeof(gpchar[1]):	%lu\n", sizeof(gpchar[1]) );
  	
  	printf("================global character list\n") ;
  	printf("sizeof(gcl):		%lu\n", sizeof( gcl) ) ;
  	printf("address(gcl):			%p\n", gcl);
  	printf("gcl[1]:		%d\n", gcl[1]);
  	printf("sizeof(gcl[1]):	%lu\n", sizeof(gcl[1]) );
  	
  	printf("================global struct list\n") ;
  	printf("sizeof(gpE):		%lu\n", sizeof( gpE) ) ;
  	printf("address(gpE):			%p\n", gpE );
  	printf("gpE[1].a:		%d\n", gpE[1].a);
  	
  	
  
  }
  	
  ```

  ```
  	.file	"ab.c"
  	.text
  	.globl	ga
  	.data
  	.type	ga, @object
  	.size	ga, 1
  ga:
  	.byte	4
  	.globl	gb
  	.align 2
  	.type	gb, @object
  	.size	gb, 2
  gb:
  	.value	1
  	.globl	gc
  	.align 4
  	.type	gc, @object
  	.size	gc, 4
  gc:
  	.long	2
  	.globl	gpEE
  	.type	gpEE, @object
  	.size	gpEE, 3
  gpEE:
  	.byte	0
  	.byte	1
  	.byte	2
  	.globl	gpchar
  	.type	gpchar, @object
  	.size	gpchar, 3
  gpchar:
  	.ascii	"\001\002\003"
  	.globl	gcl
  	.section	.rodata
  .LC0:
  	.string	"abcefghigkl"
  	.section	.data.rel.local,"aw"
  	.align 8
  	.type	gcl, @object
  	.size	gcl, 8
  gcl:
  	.quad	.LC0
  	.globl	gpE
  	.data
  	.type	gpE, @object
  	.size	gpE, 6
  gpE:
  	.byte	1
  	.byte	2
  	.byte	3
  	.byte	4
  	.byte	5
  	.byte	6
  	.section	.rodata
  	.align 8
  .LC1:
  	.string	"==============local basic type"
  .LC4:
  	.string	"char:  \t\t%lu\n"
  .LC5:
  	.string	"short: \t\t%lu\n"
  .LC6:
  	.string	"int: \t\t\t%lu\n"
  .LC7:
  	.string	"long:\t\t\t%lu\n"
  .LC8:
  	.string	"long long:\t\t%lu\n"
  .LC9:
  	.string	"float:\t\t\t%lu\n"
  .LC10:
  	.string	"double:\t\t%lu\n"
  .LC11:
  	.string	"================local struct"
  .LC12:
  	.string	"================"
  .LC13:
  	.string	"st:\t\t\t%lu\n"
  .LC14:
  	.string	"ss:\t\t\t%lu\n"
  	.align 8
  .LC15:
  	.string	"================local basic type list"
  .LC16:
  	.string	"*ptmp:\t\t\t%p\n"
  .LC17:
  	.string	"sizeof(ctmp):\t\t%lu\n"
  .LC18:
  	.string	"length(ctmp):\t\t%lu\n"
  .LC19:
  	.string	"sizeof(ctmp[0]):\t%lu\n"
  .LC20:
  	.string	"ctmp address:\t\t%p\n"
  .LC21:
  	.string	"sizeof(shtmp):\t\t%lu\n"
  .LC22:
  	.string	"length(shtmp):\t\t%lu\n"
  .LC23:
  	.string	"sizeof(shtmp[0]):\t%lu\n"
  .LC24:
  	.string	"shtmp address:\t\t%p\n"
  .LC25:
  	.string	"sizeof(itmp):\t\t%lu\n"
  .LC26:
  	.string	"length(itmp):\t\t%lu\n"
  .LC27:
  	.string	"sizeof(itmp[0]):\t%lu\n"
  .LC28:
  	.string	"itmp address:\t\t%p\n"
  	.align 8
  .LC29:
  	.string	"================local character list"
  .LC30:
  	.string	"abcdefg"
  .LC31:
  	.string	"pchar:\t\t\t%s\n"
  .LC32:
  	.string	"pchar[0]:\t\t%c\n"
  .LC33:
  	.string	"sizeof(pchar):\t\t%lu\n"
  .LC34:
  	.string	"length(pchar):\t\t%lu\n"
  .LC35:
  	.string	"address(pchar):\t%p\n"
  	.align 8
  .LC36:
  	.string	"================local struct list "
  .LC37:
  	.string	"pE[1].a:\t\t%d\n"
  .LC38:
  	.string	"sizeof(pE):\t\t%lu\n"
  .LC39:
  	.string	"\n\n\n\n"
  	.align 8
  .LC40:
  	.string	"================global basic type"
  .LC41:
  	.string	"sizeof(ga):\t\t\t%lu\n"
  .LC42:
  	.string	"sizeof(gb):\t\t\t%lu\n"
  .LC43:
  	.string	"sizeof(gc):\t\t\t%lu\n"
  .LC44:
  	.string	"address(ga):\t\t\t%p\n"
  .LC45:
  	.string	"address(gb):\t\t\t%p\n"
  .LC46:
  	.string	"address(gc):\t\t\t%p\n"
  .LC47:
  	.string	"================global struct"
  .LC48:
  	.string	"sizeof(gpEE):\t\t%lu\n"
  .LC49:
  	.string	"address(gpEE):\t\t\t%p\n"
  	.align 8
  .LC50:
  	.string	"================global basic type list"
  .LC51:
  	.string	"sizeof(gpchar):\t%lu\n"
  .LC52:
  	.string	"address(gpchar):\t%p\n"
  .LC53:
  	.string	"gpchar[1]:\t\t%d\n"
  .LC54:
  	.string	"sizeof(gpchar[1]):\t%lu\n"
  	.align 8
  .LC55:
  	.string	"================global character list"
  .LC56:
  	.string	"sizeof(gcl):\t\t%lu\n"
  .LC57:
  	.string	"address(gcl):\t\t\t%p\n"
  .LC58:
  	.string	"gcl[1]:\t\t%d\n"
  .LC59:
  	.string	"sizeof(gcl[1]):\t%lu\n"
  	.align 8
  .LC60:
  	.string	"================global struct list"
  .LC61:
  	.string	"sizeof(gpE):\t\t%lu\n"
  .LC62:
  	.string	"address(gpE):\t\t\t%p\n"
  .LC63:
  	.string	"gpE[1].a:\t\t%d\n"
  	.text
  	.globl	main
  	.type	main, @function
  main:
  .LFB0:
  	.cfi_startproc
  	endbr64
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	addq	$-128, %rsp
  	movq	%fs:40, %rax
  	movq	%rax, -8(%rbp)
  	xorl	%eax, %eax
  	leaq	.LC1(%rip), %rdi
  	call	puts@PLT
  	movb	$0, -123(%rbp)
  	movw	$0, -122(%rbp)
  	movl	$0, -120(%rbp)
  	movq	$0, -112(%rbp)
  	movq	$0, -104(%rbp)
  	pxor	%xmm0, %xmm0
  	movss	%xmm0, -116(%rbp)
  	pxor	%xmm0, %xmm0
  	movsd	%xmm0, -96(%rbp)
  	movl	$1, %esi
  	leaq	.LC4(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$2, %esi
  	leaq	.LC5(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$4, %esi
  	leaq	.LC6(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$8, %esi
  	leaq	.LC7(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$8, %esi
  	leaq	.LC8(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$4, %esi
  	leaq	.LC9(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$8, %esi
  	leaq	.LC10(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC11(%rip), %rdi
  	call	puts@PLT
  	leaq	.LC12(%rip), %rdi
  	call	puts@PLT
  	movb	$0, -72(%rbp)
  	movw	$0, -70(%rbp)
  	movl	$0, -68(%rbp)
  	movl	$8, %esi
  	leaq	.LC13(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC12(%rip), %rdi
  	call	puts@PLT
  	movq	$0, -64(%rbp)
  	movq	$0, -56(%rbp)
  	movl	$16, %esi
  	leaq	.LC14(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC15(%rip), %rdi
  	call	puts@PLT
  	leaq	-72(%rbp), %rax
  	movq	%rax, -88(%rbp)
  	movq	-88(%rbp), %rax
  	movq	%rax, %rsi
  	leaq	.LC16(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movw	$0, -11(%rbp)
  	movb	$0, -9(%rbp)
  	movl	$3, %esi
  	leaq	.LC17(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$3, %esi
  	leaq	.LC18(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$1, %esi
  	leaq	.LC19(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	-11(%rbp), %rax
  	movq	%rax, %rsi
  	leaq	.LC20(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movw	$0, -36(%rbp)
  	movw	$0, -34(%rbp)
  	movw	$0, -32(%rbp)
  	movl	$6, %esi
  	leaq	.LC21(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$3, %esi
  	leaq	.LC22(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$2, %esi
  	leaq	.LC23(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	-36(%rbp), %rax
  	movq	%rax, %rsi
  	leaq	.LC24(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$0, -24(%rbp)
  	movl	$0, -20(%rbp)
  	movl	$0, -16(%rbp)
  	movl	$12, %esi
  	leaq	.LC25(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$3, %esi
  	leaq	.LC26(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$4, %esi
  	leaq	.LC27(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	-24(%rbp), %rax
  	movq	%rax, %rsi
  	leaq	.LC28(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC29(%rip), %rdi
  	call	puts@PLT
  	leaq	.LC30(%rip), %rax
  	movq	%rax, -80(%rbp)
  	movq	-80(%rbp), %rax
  	movq	%rax, %rsi
  	leaq	.LC31(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movq	-80(%rbp), %rax
  	addq	$1, %rax
  	movzbl	(%rax), %eax
  	movsbl	%al, %eax
  	movl	%eax, %esi
  	leaq	.LC32(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$8, %esi
  	leaq	.LC33(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$8, %esi
  	leaq	.LC34(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movq	-80(%rbp), %rax
  	movq	%rax, %rsi
  	leaq	.LC35(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC36(%rip), %rdi
  	call	puts@PLT
  	movb	$0, -30(%rbp)
  	movb	$1, -29(%rbp)
  	movb	$2, -28(%rbp)
  	movb	$3, -27(%rbp)
  	movb	$4, -26(%rbp)
  	movb	$5, -25(%rbp)
  	movzbl	-27(%rbp), %eax
  	movsbl	%al, %eax
  	movl	%eax, %esi
  	leaq	.LC37(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$6, %esi
  	leaq	.LC38(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC39(%rip), %rdi
  	call	puts@PLT
  	leaq	.LC40(%rip), %rdi
  	call	puts@PLT
  	movl	$1, %esi
  	leaq	.LC41(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$2, %esi
  	leaq	.LC42(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$4, %esi
  	leaq	.LC43(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	ga(%rip), %rsi
  	leaq	.LC44(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	gb(%rip), %rsi
  	leaq	.LC45(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	gc(%rip), %rsi
  	leaq	.LC46(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC47(%rip), %rdi
  	call	puts@PLT
  	movl	$3, %esi
  	leaq	.LC48(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	gpEE(%rip), %rsi
  	leaq	.LC49(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC50(%rip), %rdi
  	call	puts@PLT
  	movl	$3, %esi
  	leaq	.LC51(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	gpchar(%rip), %rsi
  	leaq	.LC52(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movzbl	1+gpchar(%rip), %eax
  	movsbl	%al, %eax
  	movl	%eax, %esi
  	leaq	.LC53(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$1, %esi
  	leaq	.LC54(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC55(%rip), %rdi
  	call	puts@PLT
  	movl	$8, %esi
  	leaq	.LC56(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movq	gcl(%rip), %rax
  	movq	%rax, %rsi
  	leaq	.LC57(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movq	gcl(%rip), %rax
  	addq	$1, %rax
  	movzbl	(%rax), %eax
  	movsbl	%al, %eax
  	movl	%eax, %esi
  	leaq	.LC58(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$1, %esi
  	leaq	.LC59(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	.LC60(%rip), %rdi
  	call	puts@PLT
  	movl	$6, %esi
  	leaq	.LC61(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	leaq	gpE(%rip), %rsi
  	leaq	.LC62(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movzbl	3+gpE(%rip), %eax
  	movsbl	%al, %eax
  	movl	%eax, %esi
  	leaq	.LC63(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$0, %eax
  	movq	-8(%rbp), %rdx
  	xorq	%fs:40, %rdx
  	je	.L3
  	call	__stack_chk_fail@PLT
  .L3:
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	main, .-main
  	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
  	.section	.note.GNU-stack,"",@progbits
  	.section	.note.gnu.property,"a"
  	.align 8
  	.long	 1f - 0f
  	.long	 4f - 1f
  	.long	 5
  0:
  	.string	 "GNU"
  1:
  	.align 8
  	.long	 0xc0000002
  	.long	 3f - 2f
  2:
  	.long	 0x3
  3:
  	.align 8
  4:
  ```

- **C语言内存分配**

  [(104条消息) 深入理解C语言数组与内存分配_未羊_z的博客-CSDN博客_c语言中定义数组内存分配](https://blog.csdn.net/weixin_44793395/article/details/106292650)

  C语言内存分为3个段，数据段.data段、堆段、栈段

  数据段保存全局变量，字符串数组，printf的字符串，静态变量等，他是在加载的时候被加载器分配内存和初始化的

  堆段是动态内存分配使用的，也就是malloc分配内存使用的

  栈段保存局部变量和传递参数

  局部变量的数组的定义可以使用int n=3; int a[n]， 而全局变量或者静态变量的数组的定义不能这样，只能int a[3]，因为全局变量和静态变量是在程序加载的时候被加载器分配内存和初始化的，他必须知道分配的内存的大小，所以需要显示给出；而局部变量数组分配内存和初始化是在执行过程中得到的，局部变量数组在栈上分配内存，他在分配内存的时候先定义了int n的大小，那么在分配的时候知道了内存大小，并且局部变量分配内存只需要移动sp就行，也就是sp-n\*sizeof(int)就可以分配内存了，那么要寻找数组的元素只需要sp-n\*sizeof(int)+idx*sizeof(int)就能查找到a[idx]元素的位置。这样就能在运行过程中初始化对应的元素了。

  全局变量和静态变量的定义和初始化必须使用int a[3]={1,2,3}这样的方式，也就是在main函数上定义的全局变量和在main函数内部定义的数组必须这样来定义和初始化，在main函数上面不能使用a[1]=1这样的方式来赋值全局变量，因为这个语句实际上是一个代码**lea 3\*4(%esp), %eax; add 1\*4,%eax; mov 1,(%eax)**,这个代码的是在运行时赋值的，而全局变量和静态变量的初始化是在加载器加载的时候分配内存和初始化的，并不是运行时

  局部变量的内存分配并不是使用malloc来分配内存的，他的内存分配实际上在编译的时候就完成了，只需要修改sp指针就能指定数组的元素位置，所以局部变量的定义和初始化使用int n=3;int a[3]是可以的，因为局部变量数组分配内存只需要修改sp指针，局部变量数组初始化也只是是用mov指令在运行时赋值。编译器在处理a[3]在全局变量和局部变量时不同的，全局变量会时a:  .byte1 .byte 2 .byte 3，这个语句块会在加载的时候被加载器使用分配内存和初始化，而在局部变量里面，int a[3]并不会特意的处理，只是编译器会根据3\*sizeof(int)让sp减少(也就是sp-3*sizeof(int))。而对于int a[3]={1,2,3}的处理时lea -12(%ebp), %eax; movl $1, -12(%ebp); movl $2,-8(%ebp); movl $3 -4(%ebp)

- 变量/子程序调用&递归/循环的底层实现

  变量/子程序调用/循环的底层实现以来编译器以及CPU（机器指令）不同而不同，一种将c语言编译成汇编语言的底层实现可以如下

  ```c
  //C源代码
  
  char a=1;
  short b=2;
  struct T{
  	char a,b,c;
  };
  struct T st0={1,2,3};
  char la[]={1,2,3} ;
  struct T ls[]={
  	[0]{1,2,3},
  	[1]{4,5,6}
  };
  char * lc = "abc" ;
  
  
  void func(short n){
  	char a[n];
  	for(char i=0;i<n;i++){
  		a[i]=i+1;
  	}
  }
  
  int main(){
  	char lcva=1;
  	short lcvb=1;
  	struct T lcvst={1,2,3} ;
  	char lcvc[]={1,2,3} ;
  	struct T ls[]={
  		[0]{1,2,3},
  		[1]{4,5,6}
  	};
  	char * lcvchar = "abcd" ;
  
  	lcva++
  	lcvst.b ++
  	lcvc[1] ++
  	lcvlst[1].b ++
  	lcvchar[1] ++
  
  	func(3) ;
  }
  ```

  ```
  //8086 intel汇编指令
  assume cs:codeseg, ss:stackseg, ds:dataseg
  
  
  ; 数据段，保存常量，全局变量，静态变量，malloc动态内存分配空间
  ; 常量池段（常量），数据段（全局变量和字符串数组），栈段，堆段都是数据段/堆栈段，在编译的时候需要编译器指定
  ; 内存变量由编译器设置，并由Linux内存管理模块管理。
  ; 汇编语言的加载器需要手动分配栈段的内存
  ; 在操作系统运行的程序加载器由操作系统分配内存的单位自动分配栈段的内存位数据区的高地址空间
  ; 也就是在高级语言的汇编代码中不用显示分配栈段的内存，同样的道理，数据段（.data段/常量池段）和堆段在操作系统中都是
  ; 	自动分配的，不用显式分配，但是在汇编代码中需要显示分配，因为汇编代码的加载器不会自动分配内存
  ;常量池段/.data段，保存常量，全局变量，printf中的和代码中定义的字符串数组，常量
  dataseg segment
  					;常量池
  ca	dw	1			;静态变量或者常量 const short ca=1/ static short ca=1,由编译器约束
  lcc	db	'abc\0'			;全局字符串变量的内容
  lcvchar	db	'abcd\0'		;局部字符串变量内容	
  
  					
  					;全局变量
  a	db	1,0			;全局基本类型变量 char a=1, 0是对齐使用的
  b	dw	2			;全局基本类型变量 short b=2
  st0	db	1,2,3			;全局结构体类型变量 struct T st0 = {1,2,3}, 其中struct T{char a,b,c} ;
  la	db	1,2,3			;全局基本类型数组变量 char la[] = {1,2,3}
  ls	db	1,2,3
  	db	4,5,6			;全局结构体数组变量 struct T ls[] = {
  					;			[0]{
  					;				.a=1,.b=2,.c=3
  					;			},
  					;			[1]{
  					;				.a=4,.b=5,.c=6
  					;			}
  					;		   }	
  lc	dw	0,0			;全局字符串变量 char* lc = "abc"
  
  heap	db 100 dup(0)
  dataseg ends
  
  
  
  ;栈段，保存局部变量和传递参数，局部变量指针
  stackseg segment
  	db 100 dup(0)
  stackseg ends
  
  
  
  
  ; 代码段
  codeseg segment
  
  func:
  	push bp				; bp指向局部变量的栈顶，这里保存调用子程序的父程序的局部变量的栈顶
  	mov bp, sp			; bp+2+2指向的是子程序传递的参数
  					; 在子程序结束ret前要释放局部变量, add sp,n （n是局部变量申请的内存字节数）
  					; 之后是pop bp恢复父程序的局部变量栈顶
  					; 之后是ret返回父程序
  					; 在父程序中需要 add sp, m (m是分配的参数的内存数），来释放参数内存
  	mov ax, ss:[bp+4]			; bp+4 越过了 旧bp/sp，得到的是参数的地址
  	add ax, 1			; ax是char a[3]分配内存大小n，加1是分配内存给char i和其他局部变量
  	sub sp, ax			; char a[3]; char i; 分配内存
  	
  
  					; 循环结构底层实现
  					; for(i=0;i<n;i++){
  					; 	a[i] = i+1;
  					; }
  	mov byte ptr ss:-4[bp], 0		; i=0
  	mov al, byte ptr ss:-4[bp]
  	mov cl, ss:[bp+4]
  func_1C:
  	cmp al, cl
  	jb func_1			; if ax<bx, 循环体执行，否则跳出循环结构
  					; 跳出循环结构的后续代码
  					; 结束子程序，也就是子程序} 的内容，释放局部变量并且ret
  	mov sp, bp			; 释放局部变量，bp指向局部变量栈顶
  	pop bp
  	ret
  
  func_1:
  	mov dl, al
  	add dl, 1			; i+1
  	
  	lea bx, ss:-3[bp]		; a[]基地址
  	mov di, ax			; a[] 偏移idx
  	mov ss:[bx+di], dl		; a[i] = i+1
  
  	add ax, 1			; i++
  	jmp func_1C
  
  main:
  
  	;设置栈段的地址
  	;在Linux操作系统中这个操作不需要
  	;加载器会自动分配内存并指定ss:esp
  	mov ax,stackseg
  	mov ss, ax
  	mov sp, 100		
  
  	;设置数据段地址，这个过程在Linux加载器中同样被隐式初始化
  	mov ax, dataseg
  	mov ds, ax        
  
  	;设置全局字符串变量的指针，这个过程在Linux上由加载器完成，不需要显示设置
  	;在8086汇编lea把lcc偏移地址放到bx，可以用mov bx,offset lcc代替得到同样结果
  	;x86CPU汇编lea会加载虚拟地址32位
  	lea bx, ds:lcc
  	mov ds:lc, bx
  
  	
  	;main函数实际代码
  	;局部基本类型变量
  	;char lcva=1						1b
  	;short lcvb=1						2b
  	;struct T lcvst={1,2,3}					4b
  	;char lcvc[]={1,2,3}					3b
  	;struct T lcvlst[] = {[0]{1,2,3},[1]{4,5,6}}		6b
  	;char *lcvchar = "abcd"					2b
  	;局部变量在栈上分配内存和初始化
  	mov bp, sp						;bp指向栈顶，栈顶的再上面存放的是函数返回地址cs:ip
  	sub sp, 18						;sp指向栈底，也就是再栈上分配空间
  								; 局部基本类型变量
  	mov byte ptr ss:-1[bp],1				; lcva=1
  	mov word ptr ss:-3[bp],1				; lcvb = 1
  								; 局部结构体变量
  								; struct T lcvst = {1,2,3}
  	mov byte ptr ss:-7[bp],1				; lcvst.a=1
  	mov byte ptr ss:-6[bp],2				; lcvst.b=2
  	mov byte ptr ss:-5[bp],3				; lcvst.c=3
  								; 局部基本类型数组
  								; char lcvc[]= {1,2,3}
  	mov byte ptr ss:-10[bp],1				; lcvc[0] = 1
  	mov byte ptr ss:-9[bp],2				; lcvc[1]=2
  	mov byte ptr ss:-8[bp],3				; lcvc[3]=3
  								; 局部结构体数组
  								; struct T lcvlst[] = {[0]{1,2,3},[1]{4,5,6}}
  	mov byte ptr ss:-16[bp],1				; lcvlst[0].a=1
  	mov byte ptr ss:-15[bp],2				; lcvlst[0].b=2
  	mov byte ptr ss:-14[bp],3				; lcvlst[0].c=3
  	mov byte ptr ss:-13[bp],4				; lcvlst[1].a=4
  	mov byte ptr ss:-12[bp],5				; lcvlst[1].b=5
  	mov byte ptr ss:-11[bp],6				; lcvlst[1].c=6
  								; 局部字符串指针
  								; char * lcvchar="abcd"
  	lea bx, ds:lcvchar
  	mov ss:-18[bp], bx					; -10[bp]保存常量池中"abcd"字符串地址
  
  	;局部变量的使用
  	; lcva++
  	; lcvst.b ++
  	; lcvc[1] ++
  	; lcvlst[1].b ++
  	; lcvchar[1] ++
  	mov al, ss:-1[bp]
  	add al, 1
  	mov ss:-1[bp], al					; lcva++
  
  	lea bx, ss:-7[bp]
  	mov al, ss:1[bx]
  	add al, 1
  	mov ss:1[bx], al						; lcvst.b ++
  
  	lea bx, ss:-10[bp]
  	mov al, ss:1[bx]					; 1=1*sizeof(char)
  	add al, 1
  	mov ss:1[bx], al					; lcvc[1]++
  
  	lea bx, ss:-16[bp]
  	mov al, ss:4[bx]					
  	add al, 1
  	mov ss:4[bx], al					; lcvlst[1].b ++ 
  	
  	mov bx, ss:-18[bp]
  	mov al, ds:1[bx]					; 1=1*sizeof(char)
  	add al, 1
  	mov ds:1[bx], al					; lcvchar[1] ++ 
  
  	
  
  	;子程序调用,用栈传递参数
  	mov ax, 3
  	push ax
  	call func
  	add sp,2
  
  	mov ax,4c00H
  	int 21H
  codeseg ends
  
  end main
  ```

  - x86_32 intel汇编

    [(105条消息) MASM 32位汇编 32与16汇编区别_不会写代码的丝丽的博客-CSDN博客_32位汇编](https://blog.csdn.net/qfanmingyiq/article/details/120824722)

    [(105条消息) x86汇编入门_kikajack的博客-CSDN博客](https://blog.csdn.net/kikajack/article/details/110247241)

    [(105条消息) x86-64 intel64 AMD64 IA-32e x64汇编语言_wufeng_asia的博客-CSDN博客](https://blog.csdn.net/icandoit_2014/article/details/87385583)

    [(105条消息) x86_64汇编之五：System V AMD64调用约定下的函数调用_ponnylv的博客-CSDN博客_amd64汇编](https://blog.csdn.net/qq_29328443/article/details/107235138)

    [(105条消息) x86_64汇编之四：函数调用、调用约定_ponnylv的博客-CSDN博客_汇编函数调用](https://blog.csdn.net/qq_29328443/article/details/107232025)

    [(105条消息) x86_64汇编之一：AT&T汇编语法_ponnylv的博客-CSDN博客_x86汇编at&t](https://blog.csdn.net/qq_29328443/article/details/107242121)

    调用约定，子程序设计的时候参数传递和返回参数是使用寄存器还是使用栈来操作，这些不同诞生了不同的子程序调用约定

    c语言内存结构，代码段，data数据段（只读数据&常量&字面值&字符串，被初始化了的全局变量&静态变量，可读写的数据），bss数据段（未被初始化的全局变量和局部变量），堆段（动态内存分配区域，malloc），栈段（局部变量和参数）

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200710084539928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MzI4NDQz,size_16,color_FFFFFF,t_70)

    子程序的调用设计规则，和上面8086所设计的规则一样

    [(105条消息) x86的32位汇编快速入门_luckyone906的博客-CSDN博客_32位汇编](https://blog.csdn.net/u011555996/article/details/80265537)


**后端优化方向**

![后端优化方向](实验\操作系统实验\实验5 信号量的实现和应用\后端优化方向.PNG)

**没有信号量进程无法协作的原因**

- 缓冲区满，生产者进程继续运行覆盖缓冲区
- 缓冲区空，消费者进程继续运行读取错误数据
- 消费这进程同时竞争文件出错 

**信号量的实现**

````c
//信号量街头提sem.h

#ifndef _SEM_H
#define _SEM_H

#include <linux/sched.h>

struct sem_t{
	char * name ;
	unsigned int value;
	struct task_t* queue ;
} ;

#endif



//信号量的实现sem.c

#include <linux/sem.h>
#include <linux/sched.h>
#include <unistd.h>
#include <asm/segment.h>
#include <linux/tty.h>
#include <linux/kernel.h>
#include <linux/fdreg.h>
#include <asm/system.h>
#include <asm/io.h>


struct sem_t Buffer[20] ;
int cnt=0;

sem_t* sys_sem_open(const char * name, unsigned int value){
	struct sem_t* tmp ;
	cli() ;
	
	Buffer[cnt].value= value ;
	tmp = Buffer[cnt] ;
	cnt ++ ;
	
	sti() ;
	
	return tmp ;
}

void sys_sem_wait(sem_t* sem){
	cli() ;
	while( sem.value<=0 )
		sleep_on(sem.queue) ;
	sem.value-- ;
	sti() ;
}

void sys_sem_post(sem_t* sem){
	cli() ;
	sem.value++ ;
	wake_up(sem.queue) ;
	sti() ;
}

void sys_sem_unlink(const char * name){
	
}



//测试函数test.c


#define __LIBRARY__
#include <unistd.h>
#include <linux/sem.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/sched.h>

_syscall2(sem_t *,sem_open,const char *,name,unsigned int,value)
_syscall1(int, sem_wait, sem_t *, sem)
_syscall1(int, sem_post, sem_t *, sem)
_syscall1(int, sem_unlink, const char *, name)

const char *FileName="/usr/root/buffer";
const int consumers=5;
const int items = 20 ;
const int bufferSize=5 ;

unsigned int used ;

unsigned int i1,i2 ;

sem_t *mutex, *full, *empty ;
int fi, fo;

int main(int argc, char *argv[]){
	int pid;

	fi = open(FileName, O_CREAT| O_TRUNC| O_WRONLY, 0222);
	fo = open(FileName, O_TRUNC| O_RDONLY, 0444);       
	
	printf("aaaaaaa\n") ;
	
	mutex = sem_open("Mutex", 1) ;
	printf("======\n") ;
	full = sem_open("Full", 0) ;
	printf("======1\n") ;
	empty = sem_open("Empty", bufferSize) ;
	printf("======2\n") ;
	
	if( pid = fork() ){
		for(i1=0;i1<items;i1++){
			sem_wait(empty) ;
			sem_wait(mutex) ;
			
			if( !(i1%bufferSize) )
				lseek(fi,0,0) ;
				
			write(fi, (char*)&i1, sizeof(i1) ) ;

			sem_post(full) ;
			sem_post(mutex) ;
		}
	}else{
		for(i2=0;i2<consumers;i2++){
			if( !(pid=fork() ) ) {
				pid = getpid() ;
				while(1){
					sem_wait(full) ;
					sem_wait(mutex) ;
					if(!read(fo, (char*)&used, sizeof(used)) ){
						lseek(fo,0,0) ;
						read(fo, (char*)&used, sizeof(used)) ;
					}
					printf("%d: %d\n", pid, used);
        				fflush(stdout);
					
					sem_post(empty) ;
					sem_post(mutex) ;
					
					if(used== items)
						goto OK;
						
					
				}
			}
		}
	}
OK:
	close(fi);
	close(fo) ;
	return 0;
}
````

**使用信号量实现阻塞队列**

我想用信号量实现阻塞队列，代码如下，但是这个是错误的，因为在没有实现共享内存下使用malloc分配的堆内存在fork的时候会重新分配内存给子进程，这样父进程和子进程操作的队列并不是同一个队列。在这个过程中我怀疑过不是同一个队列，但是我用&符号来取地址发现地址相同，我怀疑&号取的不是物理地址而是逻辑地址，查阅材料可知&取得的就是逻辑地址，这个逻辑地址和数据段结合组成虚拟地址，虚拟地址通过MMU映射得到实际的物理地址。

```c
#define __LIBRARY__
#include <unistd.h>
#include <linux/sem.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/sched.h>

_syscall2(sem_t *,sem_open,const char *,name,unsigned int,value)
_syscall1(int,sem_wait,sem_t *,sem)
_syscall1(int,sem_post,sem_t *,sem)
_syscall1(int,sem_unlink,const char *,name)


#define queLength 5

typedef struct Queue{
	int que[queLength] ;
	int start, end ;
	
	sem_t * mutex, *full, *empty ;
} Queue_t;

int push(struct Queue* que, int value){
	int start, end;
	
	sem_wait(que->empty) ;
	sem_wait(que->mutex) ;
	
	
	start = que->start ;
	end = que->end ;

	que->que[end] = value ;
	/*printf("push: start %d, end %d: %d\n", start, end, que->que[end]) ; */
	printf("push: %p %d %d %d %d %p\n", &que->que[0], que->que[1], que->que[2], que->que[3], que->que[4] ,que) ;
	que->end = (que->end+1)%queLength ;
	
	sem_post(que->full) ;
	sem_post(que->mutex) ;
	return 0;
}

int pop(struct Queue* que){
	int start, end, res;

	sem_wait(que->full) ;
	sem_wait(que->mutex) ;

	
	start = que->start ;
	end = que->end;
	
	res = que->que[start] ;
	printf("pop: %p %d %d %d %d %p\n", &que->que[0], que->que[1], que->que[2], que->que[3], que->que[4] ,que) ;
	/*printf("pop: start %d, end %d: %d\n", start, end, que->que[start]) ;*/
	que->start = (que->start+1)%queLength ;
	sem_post(que->empty) ;
	sem_post(que->mutex) ;
	return res;
	
}


const char *FileName="/usr/root/buffer";
const int consumers=5;
const int items = 20 ;
const int bufferSize=queLength ;

int used ;

unsigned int i1,i2 ;

struct Queue* que ;

int main(){
	int pid ;
	que= (Queue_t*)malloc(sizeof(Queue_t)) ;
	
	que->start = 0;
	que->end=0;
	que->mutex=sem_open("Mutex",1) ;
	que->empty=sem_open("Empty",bufferSize) ;
	que->full =sem_open("Full", 0) ;



	if( pid = fork() ){
		for(i1=0;i1<items;i1++){
			push(que, i1) ;
		}
	}else{
		for(i2=0;i2<consumers;i2++){
			if( !(pid=fork() ) ) {
				pid = getpid() ;
				while(1){

					used = pop(que) ;
					
					printf("%d: %d\n", pid, used);
        				fflush(stdout);
				}
			}
		}
	}
	return 0;
}

```

![Screenshot 2022-10-12 180431](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-12 180431.png)

**&取得的是逻辑地址而不是物理地址**

https://www.cnblogs.com/fengxing999/p/10209835.html

要想获得实际的物理地址只有操作系统才能获得，需要写一个系统调用来获取实际的物理地址。获取GDTR和LDTR，LDTR32位是一个段选择子，GDTR是GDT表的物理地址，GDTR+LDTR20位*16得到进程LDT表段描述符，从其中取得LDT表的基地址，从ds段选择符获取段选择子，从LDT表中基地址+ds段选择子20位\*8得到变量所处数据段段选择符，从段选择符获取变量所处数据段基地址，基地址+逻辑地址得到实际物理地址。

### 实验6-地址映射和共享内存实现

这个章节的实验就是我在第五实验想到的基于共享内存和信号量实现阻塞队列和生产者消费者模型的方法的解决。这个章节重点是实现共享内存

**CPU原语**

[CPU 原语，汇编语言，机器语言 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/380524095)

[cpu 硬件同步原语(compare and swap) - langke93 - 博客园 (cnblogs.com)](https://www.cnblogs.com/langke93/archive/2011/11/15/2249812.html)

CPU原语就是需要连续完成的一段程序，CPU原语的实现通过关中断实现。和数据库事务的差别在于事务是一段连续完成的程序，如果不能连续完成可以回滚，通过回滚相关文件实现回滚，而CPU原语时保证能够连续完成的一段程序，没有回滚。

CPU原语通过cli sti关中断实现或者本身就是一个原子指令，而数据库事务通过回滚操作实现

CPU硬件同步原语CAS，在Intel处理器上有一条指令cmpxchg来执行CAS操作

**JVM的CAS相关**

[(107条消息) cas cpu 硬件同步原语(compare and swap)_not_in_mountain的博客-CSDN博客](https://blog.csdn.net/not_in_mountain/article/details/78070447)

[(107条消息) JVM之CAS(Compare and swap缩写)_墨xiao渊的博客-CSDN博客_cas jvm](https://blog.csdn.net/qq_28772075/article/details/119282482)

[(107条消息) cas cpu 硬件同步原语(compare and swap)_zdy0_2004的博客-CSDN博客](https://blog.csdn.net/zdy0_2004/article/details/40875761)

[(107条消息) synchronized的CPU原语原理解析_草根玉堂的博客-CSDN博客_cpu原语](https://blog.csdn.net/byt420/article/details/105988133)

**POSIX标准：操作系统功能和系统调用相关的定义**

[POSIX标准理解 - 1130136248 - 博客园 (cnblogs.com)](https://www.cnblogs.com/1130136248wlxk/articles/5308863.html)

POSIX标准定义了操作系统的功能和系统调用相关的内容。

**Linux内核常见的系统调用**

[Linux系统调用实例和功能速查 (baidu.com)](https://baijiahao.baidu.com/s?id=1604601045858159778&wfr=spider&for=pc)

[Linux文档](https://cn.bing.com/search?q=man+pages&aqs=edge..69i57&FORM=ANCMS9&PC=WSEDDB)

[linux系统调用列表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/344311940)

Linux系统调用和功能函数并不完全遵循POSIX标准，比如共享内存相关的系统调用POSIX标准和Linux实现的标准是不一样的。

**一些疑惑的解答**

[(107条消息) 操作系统实验一到实验九合集(哈工大李治军)_Casten-Wang的博客-CSDN博客_哈工大操作系统实验](https://blog.csdn.net/leoabcd12/article/details/122268321)

上述链接的实验7部分给出了ds:[eax]的逻辑地址到物理地址映射的全过程，其中的堆GDT表、段描述符各个位的功能、特权级、页目录表、页表等描述很详细。有关逻辑地址映射到物理地址的方面非常详细

虚拟地址=线性地址=段基址+逻辑地址

C语言程序内存段划分：代码段（.text)，已初始化的数据段（.data)，未初始化的数据段(.bss)，堆段(brk指针指向，brk保存在PCB中，他是堆段的逻辑地址，brk+数据段基地址得到堆段基地址)，栈段（esp寄存器指向）

**使用共享内存的线程必须通过共享内存变量的key来获得变量的实际物理地址**

下面的代码使用共享内存的方式是错误的

```c
#define __LIBRARY__
#include <unistd.h>
#include <linux/sem.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/sched.h>
#include <linux/shm.h>

_syscall2(sem_t *,sem_open,const char *,name,unsigned int,value)
_syscall1(int,sem_wait,sem_t *,sem)
_syscall1(int,sem_post,sem_t *,sem)
_syscall1(int,sem_unlink,const char *,name)


_syscall2(int,shmget,unsigned int,key,size_t,size)
_syscall1(void *,shmat,int,shmid)

int * tmp;
int shmid ;

int main(){

	shmid = shmget(1234, sizeof(int) );

	if(shmid == -1){
		return -1;
	}

	tmp = (int *) shmat(shmid);
	(*tmp) = 1;

	if( fork() ){
		while(1){
			printf("f: %d\n", *tmp) ;
			sleep(1) ;
		}

	}else{
		while(1){
			(*tmp) = 2;
			printf("s: %d\n", *tmp) ;
			sleep(1) ;
		}
	}
	return 0;
}



```

上面代码得到的结果截图是

![Screenshot 2022-10-13 223913](D:\JavaBackend\实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-13 223913.png)

从上面我们可以看到f父进程和s子进程实际上使用的是两个变量，也就是tmp在父进程和子进程中物理地址是不同的。实际上上面的问题出在我们在fork之前申请了共享内存，设置了全局变量int *tmp的内存分配为共享内存，设置了(\*tmp)这个堆内存虚拟地址的实际物理地址是一个共享内存，也即是ds:(\*tmp)这个虚拟地址所映射的页表项为page|7，其中7代表设置申请的实际物理页page到虚拟地址的映射为可写。在这个过程中我们设置了一个共享内存变量（\*tmp)，实现他的方式实际上是设置虚拟地址ds:(\*tmp)所映射到的物理地址page的属性是（U/S, R/W, P)=(1,1,1)=7，也就是可写。但是在我们使用fork系统调用的时候，fork会赋值父进程的页表到子进程并且设置父进程和子进程的页表为只读，也就是(U/S,R/W,P)=(0,0,1)=1，那么我们的(\*tmp)这个变量分配的内存就失去了共享内存的效果，这个时候已经没有共享内存了，所以在子进程中我们获得（\*tmp)变量实际上在(\*tmp)=2写(\*tmp)内存的时候会进行write_verify写检查，发现ds:(\*tmp)所对应的虚拟地址的页表项的属性已经不是7了，而是1，所以他会重新分配内存进行写时复制，这样我们在父进程和子进程中的逻辑变量(\*tmp)在父进程和子进程中指向的不是同一块内存了。要实现共享内存，必须使用key关键字来标记，也就是在每个进程中我们都需要使用key关键字来获取共享内存的变量，下面的程序才是合法的。

```c
#define __LIBRARY__
#include <unistd.h>
#include <linux/sem.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/sched.h>
#include <linux/shm.h>

_syscall2(sem_t *,sem_open,const char *,name,unsigned int,value)
_syscall1(int,sem_wait,sem_t *,sem)
_syscall1(int,sem_post,sem_t *,sem)
_syscall1(int,sem_unlink,const char *,name)


_syscall2(int,shmget,unsigned int,key,size_t,size)
_syscall1(void *,shmat,int,shmid)

int * tmp;
int shmid ;

int main(){

	if( fork() ){
	
		shmid = shmget(1234, sizeof(int) );
		if(shmid == -1){
			return -1;
		}

		tmp = (int *) shmat(shmid);
		(*tmp) = 1;
		
		
		while(1){
			printf("f: %d\n", *tmp) ;
			sleep(1);
		}

	}else{
	
		shmid = shmget(1234, sizeof(int) );

		if(shmid == -1){
			return -1;
		}

		tmp = (int *) shmat(shmid);
		(*tmp) = 2;
		
		while(1){
			printf("s: %d\n", *tmp) ;
			sleep(1) ;
		}
	}
	return 0;
}



```

mov [eax], 2写内存的时候会先进行写验证write_verify，就像除0发生除0中断一样。是一种软中断

上面的程序可以看到在每个进程中我们都必须通过共享内存关键字key=1234来实际获得共享内存的物理地址。上面程序的结果如下图

![Capture](实验\操作系统实验\实验5 信号量的实现和应用\Capture.PNG)

从上面我们可以看到共享内存对了。

共享内存变量要在每个进程中通过key来获得实际物理地址

**使用共享内存和信号量实现阻塞队列，进而使用阻塞队列实现生产者消费者进程**

```c
#define __LIBRARY__
#include <unistd.h>
#include <linux/sem.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/sched.h>
#include <linux/shm.h>

_syscall2(sem_t *,sem_open,const char *,name,unsigned int,value)
_syscall1(void,sem_wait,sem_t *,sem)
_syscall1(void,sem_post,sem_t *,sem)
_syscall1(void,sem_unlink,const char *,name)


_syscall2(int,shmget,unsigned int,key,size_t,size)
_syscall1(void *,shmat,int,shmid)


#define queLength 5

typedef struct Queue{
	int que[queLength] ;
	int start, end ;
	
	sem_t * mutex, *full, *empty ;
} Queue_t;

const char *FileName="/usr/root/buffer";
const int consumers=5;
const int items = 20 ;
const int bufferSize=queLength ;

int used ;

unsigned int i1,i2 ;

struct Queue* que ;

int pid, shmid;

int *tmpque;


int push(struct Queue* que, int value){
	int start, end;
	
	/*
	printf("===============push %d\n", value) ;
	fflush(stdout); */
	
	sem_wait(que->empty) ;
	sem_wait(que->mutex) ;
	
	
	start = que->start ;
	end = que->end ;

	que->que[end] = value ;
	/*printf("push: start %d, end %d: %d\n", start, end, que->que[end]) ; */
	
	/*
	printf("push: %d %d\n", que->que[0], que->que[1]) ;
	fflush(stdout); 
	*/
	que->end = (que->end+1)%queLength ;
	
	sem_post(que->full) ;
	sem_post(que->mutex) ;
	return 0;
}

int pop(struct Queue* que){	
	int start, end, res;
	
	/*
	printf("===============pop \n") ;
	fflush(stdout);*/

	sem_wait(que->full) ;
	sem_wait(que->mutex) ;

	
	start = que->start ;
	end = que->end;
	
	res = que->que[start] ;
	
	/*
	printf("pop: %d %d \n", que->que[0], que->que[1]) ;
	fflush(stdout);
	*/
	/*printf("pop: start %d, end %d: %d\n", start, end, que->que[start]) ;*/
	que->start = (que->start+1)%queLength ;
	sem_post(que->empty) ;
	sem_post(que->mutex) ;
	return res;
	
}

int main(){

	
	shmid = shmget(1234, sizeof(Queue_t) );
	if(shmid == -1){
		return -1;
	}
	que = (Queue_t*) shmat(shmid);

	que->start = 0;
	que->end=0;
	que->mutex=sem_open('M',1) ;
	que->empty=sem_open('E',bufferSize) ;
	que->full =sem_open('F', 0) ;


	if( pid = fork() ){
		shmid = shmget(1234, sizeof(Queue_t) );
		if(shmid == -1){
			return -1;
		}
		que = (Queue_t*) shmat(shmid);
		
		for(i1=0;i1<items;i1++){
			push(que, i1+100) ;
		}
	}else{
		for(i2=0;i2<consumers;i2++){
			if( !(pid=fork() ) ) {
			
				shmid = shmget(1234, sizeof(Queue_t) );
				if(shmid == -1){
					return -1;
				}
				que = (Queue_t*) shmat(shmid);
				
				pid = getpid() ;
				while(1){

					used = pop(que) ;
					
					printf("%d: %d\n", pid, used);
					fflush(stdout);
				}
			}
		}
	}
	return 0;
}



```

上面实验的结果

![Screenshot 2022-10-13 234825](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-13 234825.png)

从上面可以看到顺序输出结果

**编写系统调用方法**

- 编写头文件定义相关数据结构体和系统调用函数原型，编写源文件实现系统调用函数，修改Makefile编译文件包含系统调用的编译
- 在include/unistd.h中添加系统调用号__NR\_XXX，在include/linux/sys.h中添加系统调用函数到系统调用表sys_call_table，在kernel/system_call.s中修改系统调用总数nr_system_calls
- 在应用文件或者测试文件中使用\_\_systemcall1,\_\_systemcall2等宏定义系统调用API

### 实验7-终端设备的控制

**IO管理，网络管理都是设备管理**

IO管理涉及到的设备有鼠标和键盘，网络管理涉及到的设备有网卡。鼠标键盘网卡都是设备，都是设备管理的部分。

鼠标键盘都是字符设备，网卡是串行设备，但是都是按照字符来操作的。

**设备驱动程序**

管理设备的驱动程序是内核函数或者中断处理函数，管理键盘的驱动程序是键盘中断（在keyboard.S中实现），管理显示器的驱动程序是一个内核函数con_write(在console.c中实现)

**键盘中断过程/scanf和printf实现**

scanf传入字符串地址和变量地址，调用read系统调用，read系统调用会把进程阻塞到键盘设备结构体的等待队列上。

此时，scanf等待读取键盘输入的进程被阻塞，操作系统调度到其他程序运行。当按下键盘的时候，引发键盘中断，键盘中断获取键盘传递的扫描符在一个寄存器里面，键盘中断会将这个扫描符按照字符映射表映射到ascii字符（字符映射表是按照使用的输入法来设置的，比如英语键盘对应ascii字符映射表，韩语键盘对应韩语字符映射表），然后使用put_char()将这个字符放到键盘读缓冲队列中去（读缓冲队列可以设计成循环队列，清空读缓冲队列可以让head=tail，检验满可以使用head==tail，添加元素tail+1，从缓冲区读元素queue[head]）。然后键盘中断使用行规范函数copy_to_cooked（）将键盘读缓冲区的原始字符通过转义等规范转换成实际需要的字符放到辅助队列（比如backspace删除键会被处理，他会删除前面的字符，而本字符backspace不会放到辅助队列中。）在copy_to_cooked函数里，如果设置了回显到控制台Echo标志，那么copy_to_cooked函数会将字符写入控制台设备结构体的写缓冲队列并且调用写控制台（显示器）函数con_write()。当键盘都缓冲区满的时候，wake_up唤醒等待这个设备队列的阻塞进程（设置进程PCB结构体的state为task_running，也就是运行态放入就绪队列）。

当键盘中断满或者遇到回车符时，键盘中断wake_up唤醒scanf的被阻塞进程，当进程被唤醒之后，使用它tty_read函数（在ttyio.c定义，同时还有tty_write，copy_to_cooked)把键盘缓冲区的数据拷贝到用户程序变量中，如果输入不够，会继续阻塞到键盘设备结构体的阻塞队列上，如果输入够了，就返回read系统调用iret回到调用scanf的用户程序中继续执行。

printf调用write系统调用，write系统调用会使用tty_write函数将用户空间的字符串拷贝到内核的显示设备结构体tty_table[n]的写缓冲队列中，然后调用写控制台函数con_write将显示设备结构体的写缓冲区的字符串拷贝到显示器内存中（显示器内存是一块固定位置和大小的内存，被内核管理，是内核空间），拷贝到显示器内存就能在显示器上看到字符。

写控制台函数con_write的属性保存在控制台设备结构体的termios结构体中，这个结构体规定了一些参数，比如写到控制台（显示器）的速率颜色等等。修改控制台termios的参数是一个系统调用，在tty_ioctn.c中定义，这个系统调用可以修改控制台设备结构体的termios变量的参数，从而控制向控制台输出字符串的参数。

上面的过程涉及4个文件，keyboard.S提供键盘中断，put_char函数，将键盘扫描码转换成ascii码放到键盘设备结构体的读缓冲区中，之后调用copy_to_cooked将读缓冲队列的数据转义之后放到辅助队列，如果设置回显还会调用con_write将读缓冲队列数据写道控制台显示；tty_io.c提供用户程序系统调用read/write时的地层函数和copy_to_cooked，read系统调用调用了tty_read，tty_read将键盘设备结构体的读缓冲队列的数据从内核态拷贝到用户程序空间的变量，write系统调用调用了tty_write函数，tty_write函数将用户空间变量拷贝到控制台设备结构体的写缓冲队列，然后调用con_write将控制台结构体写缓冲队列的数据写到屏幕上；consol.c提供了con_write，他按照控制台结构体的termios参数将控制台设备结构体写缓冲区的数据写到控制台内存中；tty_ioctl.c提供了系统调用修改控制台设备结构体的termios参数，从而控制con_write写控制台结构体写缓冲队列的数据到控制台内存的过程。

下面的图是从《Linux内核剖析》截取的

![Screenshot 2022-10-14 165649](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-14 165649.png)

read系统调用判断设备结构体的读缓冲区为空就阻塞，否则调用tty_read从设备结构体的读缓冲区读取一个字符然后put_fs_byte从内核空间拷贝到用户变量。

**串行设备中断/网络中断过程/socket系统调用**

![Screenshot 2022-10-14 170739](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-14 170739.png)

![Screenshot 2022-10-14 170832](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-14 170832.png)

当网络或电路发生变化，或者接收到字符或者要发送字符，会触发串行中断。串行设备通过端口连接到系统，网卡通过端口连接到系统。当使用socket进程等待网卡数据输入的时候会阻塞socket进程，当网卡端口接收到字符的时候会触发网卡中断，中断调用rs_read函数将端口的字符写入到网卡设备结构体的读缓冲队列，当写读缓冲队列函数遇到输入结束字符的时候会唤醒阻塞在网卡读缓冲队列的进程。被唤醒的进程通过tty_read从网卡读缓冲队列将内核数据拷贝到用户空间，之后从socket读系统调用返回。当进程需要写网卡的时候，会调用socket某系统调用，该系统调用使用tty_write将用户程序数据拷贝到网卡写缓冲队列，然后调用rs_write函数把写缓冲队列的数据发送到网卡设备的内存中，网卡设备自己又将内存中的数据发送出去。

网络中断和设备中断的不同点主要在于从设备中获取字符并转换和写入到设备结构体的读缓冲队列的函数rs_read/put_char，以及将设备写缓冲队列写到设备内存的函数rs_write/con_write等的差异，其他基本一样。

**实验要求**

按下F12，那么向控制台输出的字母和数字都用*代替，再次按下F12，那么显示正常。

实现思路：按下F12引发键盘中断，键盘中断根据F12扫描码从key_table中找到处理F12扫描码的程序，然后跳转到那个程序执行，在F12处理程序中添加一个全局变量，按下一次F12设置F12STATE=1，在字符回显到控制台的时候修改con_write函数，这个函数根据F12STATE=1，将从控制台缓冲区读取的字符转换为*后写到显存。这个实现只能实现控制台变换，因为他只修改了con_write函数。对于write系统调用写入到控制台有用，对于写入文件没有用，因为文件设备写函数是file_write函数，要实现在文件中的过程需要修改file_write函数。

**tty_read/tty_write/con_write/rs_write**

- tty_read

  tty_read定义在tty_io.c中，原型int tty_read(unsigned channel, char * buf, int nr)， 其中channel是被读取的设备，是tty_table中的下标；buf是用户空间字符串指针，nr是需要从tty_table[channel]设备的辅助队列读取的字符个数，返回值代表实际读取的字符数目（因为有信号和超时等设置，造成实际读取的数目没有那么多）。tty_read的含义是从tty_table[channel]的辅助队列中读取nr个字符返回给用户空间。

  tty_read在nr--循环while(nr--)，遇到有信号就返回，遇到tty_table[channel]的辅助队列为空就阻塞在辅助队列的阻塞队列上，否则将一个字符(nr--) put_fs_byte从内核空间的辅助队列拷贝到用户空间的字符串数组buf中（b= buff, b++)，直到nr>0或者辅助队列为空。最后返回实际读取的字符个数b-buff

  ```c
  int tty_read(unsigned channel, char * buf, int nr)
  {
  	struct tty_struct * tty;
  	char c, * b=buf;
  	int minimum,time,flag=0;
  	long oldalarm;
  
  	if (channel>2 || nr<0) return -1;
  	tty = &tty_table[channel];
  	oldalarm = current->alarm;
  	time = 10L*tty->termios.c_cc[VTIME];
  	minimum = tty->termios.c_cc[VMIN];
  	if (time && !minimum) {
  		minimum=1;
  		if ((flag=(!oldalarm || time+jiffies<oldalarm)))
  			current->alarm = time+jiffies;
  	}
  	if (minimum>nr)
  		minimum=nr;
  	while (nr>0) {
  		if (flag && (current->signal & ALRMMASK)) {
  			current->signal &= ~ALRMMASK;
  			break;
  		}
  		if (current->signal)
  			break;
  		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
  		!tty->secondary.data && LEFT(tty->secondary)>20)) {
  			sleep_if_empty(&tty->secondary);
  			continue;
  		}
  		do {
  			GETCH(tty->secondary,c);
  			if (c==EOF_CHAR(tty) || c==10)
  				tty->secondary.data--;
  			if (c==EOF_CHAR(tty) && L_CANON(tty))
  				return (b-buf);
  			else {
  				put_fs_byte(c,b++);
  				if (!--nr)
  					break;
  			}
  		} while (nr>0 && !EMPTY(tty->secondary));
  		if (time && !L_CANON(tty)) {
  			if ((flag=(!oldalarm || time+jiffies<oldalarm)))
  				current->alarm = time+jiffies;
  			else
  				current->alarm = oldalarm;
  		}
  		if (L_CANON(tty)) {
  			if (b-buf)
  				break;
  		} else if (b-buf >= minimum)
  			break;
  	}
  	current->alarm = oldalarm;
  	if (current->signal && !(b-buf))
  		return -EINTR;
  	return (b-buf);
  }
  ```

- tty_write

  tty_write原型int tty_write(unsigned channel, char * buf, int nr)， 含义是将用户空间的字符串buf的nr个字符输出到设备数组tty_table[channel]中，并且返回输出的字符个数。

  tty_write在while(nr--)里面，如果遇到信号就break，如果遇到tty_table[channel]的写缓冲队列为满就可中断阻塞，然后while(nr>0 && 写缓冲队列不满)就不断从用户空间buf中拷贝到内核写缓冲队列中（get_fs_byte)，在这个while结束拷贝了所有字符到写缓冲队列或者写缓冲队列为满的时候，掉要昂tty->write函数（对控制台设备是con_write，对键盘设备时rs_write)将写缓冲队列的数据写入到对应的控制终端（rs_write没有实现任何功能，因为键盘不用写入数据，但是rs_write可以用在网卡设备中），接下来的schedul是为了保证其他进程使用写缓冲队列响应时间而设计的。

  ```c
  int tty_write(unsigned channel, char * buf, int nr)
  {
  	static int cr_flag=0;
  	struct tty_struct * tty;
  	char c, *b=buf;
  
  	if (channel>2 || nr<0) return -1;
  	tty = channel + tty_table;
  	while (nr>0) {
  		sleep_if_full(&tty->write_q);
  		if (current->signal)
  			break;
  		while (nr>0 && !FULL(tty->write_q)) {
  			c=get_fs_byte(b);
  			if (O_POST(tty)) {
  				if (c=='\r' && O_CRNL(tty))
  					c='\n';
  				else if (c=='\n' && O_NLRET(tty))
  					c='\r';
  				if (c=='\n' && !cr_flag && O_NLCR(tty)) {
  					cr_flag = 1;
  					PUTCH(13,tty->write_q);
  					continue;
  				}
  				if (O_LCUC(tty))
  					c=toupper(c);
  			}
  			b++; nr--;
  			cr_flag = 0;
  			PUTCH(c,tty->write_q);
  		}
  		tty->write(tty);
  		if (nr>0)
  			schedule();
  	}
  	return (b-buf);
  
  ```

- con_write

  con_write 原型 void con_write(struct tty_struct *tty)，他的含义是将tty写缓冲队列的数据全部写入到控制台中。他在控制台键盘中断的tty_write被调用用来写到控制台。

  ```c
  void con_write(struct tty_struct * tty)
  {
  	int nr;
  	char c;
  
  	nr = CHARS(tty->write_q);
  	while (nr--) {
  		GETCH(tty->write_q,c);
  		switch(state) {
  			case 0:
  				if (c>31 && c<127) {
  					if (x>=video_num_columns) {
  						x -= video_num_columns;
  						pos -= video_size_row;
  						lf();
  					}
  					__asm__("movb attr,%%ah\n\t"
  						"movw %%ax,%1\n\t"
  						::"a" (c),"m" (*(short *)pos)
  						);
  					pos += 2;
  					x++;
  				} else if (c==27)
  					state=1;
  				else if (c==10 || c==11 || c==12)
  					lf();
  				else if (c==13)
  					cr();
  				else if (c==ERASE_CHAR(tty))
  					del();
  				else if (c==8) {
  					if (x) {
  						x--;
  						pos -= 2;
  					}
  				} else if (c==9) {
  					c=8-(x&7);
  					x += c;
  					pos += c<<1;
  					if (x>video_num_columns) {
  						x -= video_num_columns;
  						pos -= video_size_row;
  						lf();
  					}
  					c=9;
  				} else if (c==7)
  					sysbeep();
  				break;
  			case 1:
  				state=0;
  				if (c=='[')
  					state=2;
  				else if (c=='E')
  					gotoxy(0,y+1);
  				else if (c=='M')
  					ri();
  				else if (c=='D')
  					lf();
  				else if (c=='Z')
  					respond(tty);
  				else if (x=='7')
  					save_cur();
  				else if (x=='8')
  					restore_cur();
  				break;
  			case 2:
  				for(npar=0;npar<NPAR;npar++)
  					par[npar]=0;
  				npar=0;
  				state=3;
  				if ((ques=(c=='?')))
  					break;
  			case 3:
  				if (c==';' && npar<NPAR-1) {
  					npar++;
  					break;
  				} else if (c>='0' && c<='9') {
  					par[npar]=10*par[npar]+c-'0';
  					break;
  				} else state=4;
  			case 4:
  				state=0;
  				switch(c) {
  					case 'G': case '`':
  						if (par[0]) par[0]--;
  						gotoxy(par[0],y);
  						break;
  					case 'A':
  						if (!par[0]) par[0]++;
  						gotoxy(x,y-par[0]);
  						break;
  					case 'B': case 'e':
  						if (!par[0]) par[0]++;
  						gotoxy(x,y+par[0]);
  						break;
  					case 'C': case 'a':
  						if (!par[0]) par[0]++;
  						gotoxy(x+par[0],y);
  						break;
  					case 'D':
  						if (!par[0]) par[0]++;
  						gotoxy(x-par[0],y);
  						break;
  					case 'E':
  						if (!par[0]) par[0]++;
  						gotoxy(0,y+par[0]);
  						break;
  					case 'F':
  						if (!par[0]) par[0]++;
  						gotoxy(0,y-par[0]);
  						break;
  					case 'd':
  						if (par[0]) par[0]--;
  						gotoxy(x,par[0]);
  						break;
  					case 'H': case 'f':
  						if (par[0]) par[0]--;
  						if (par[1]) par[1]--;
  						gotoxy(par[1],par[0]);
  						break;
  					case 'J':
  						csi_J(par[0]);
  						break;
  					case 'K':
  						csi_K(par[0]);
  						break;
  					case 'L':
  						csi_L(par[0]);
  						break;
  					case 'M':
  						csi_M(par[0]);
  						break;
  					case 'P':
  						csi_P(par[0]);
  						break;
  					case '@':
  						csi_at(par[0]);
  						break;
  					case 'm':
  						csi_m();
  						break;
  					case 'r':
  						if (par[0]) par[0]--;
  						if (!par[1]) par[1] = video_num_lines;
  						if (par[0] < par[1] &&
  						    par[1] <= video_num_lines) {
  							top=par[0];
  							bottom=par[1];
  						}
  						break;
  					case 's':
  						save_cur();
  						break;
  					case 'u':
  						restore_cur();
  						break;
  				}
  		}
  	}
  	set_cursor();
  }
  ```

- rs_write

  ```c
  void rs_write(struct tty_struct * tty)
  {
  	cli();
  	if (!EMPTY(tty->write_q))
  		outb(inb_p(tty->write_q.data+1)|0x02,tty->write_q.data+1);
  	sti();
  }
  ```

### 实验8-虚拟文件系统的实现

**C语言关键字**

https://worktile.com/blog/know-1394/

  	 **关键字的实质是约束编译器编译的行为**

* 数据类型关键字(12个)

  数据类型关键字约束编译器声明变量分配内存数据量（字节数）

  - char, short, int, long, siagned，unsigned
  - float，double
  - enum， struct，union，union

* 控制语句关键字（12个）

  **控制语句关键字约束编译器生成一段代码**

  - 循环语句：for，do，while，break，continue
  - 条件语句：if，else，goto，switch/case/default
  - 返回语句：return（返回参数保存到eax寄存器或者栈上的指针）

- 存储类型关键字（4个）

  - auto: 声明自动变量

  - extern： 声明的变量在其他文件声明

  - register：声明寄存器变量

  - static：

    https://blog.csdn.net/iuices/article/details/115385660

    https://www.cnblogs.com/jacklong-yin/p/9613037.html

    https://blog.csdn.net/mm_hh/article/details/77126878#:~:text=%E8%BF%99%E4%B8%A4%E8%80%85%E5%9C%A8%E5%AD%98%E5%82%A8,%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E5%AE%83%E3%80%82

    声明静态变量，静态变量放到数据段。C语言内存分为代码段，数据段（已初始化数据区.data和未初始化数据区.bss，前者由加载器初始哈，后者通过代码赋值和初始化，字面值，常量池处在已初始化数据区（包括字面值和字符串），静态变量放到数据段。

    static发展了三层语义：1. 一个存储在数据区但是作用域在定义的函数域中的变量，函数退出之后不会消失的变量，只被初始化一次的变量；2. 一个全局变量只能作用在定义的文件中而不能使用extern被外部文件引用；3.在C++中扩展的，一个只属于一个类的而不属于任何对象的全局变量，Java有同样的语义

    C语言变量类型有：全局变量，静态全局变量，局部变量，静态局部变量。

    - 全局变量在数据区分配内存，如果没有初始化将会初始化为0，如果有初始化会初始化为字面值，全局变量作用域在定义的文件和外部文件（可以使用extern引用全局变量到外部文件），全局变量和静态全局变量区别在于静态全局变量作用在定义的文件，他们都是在数据区分配内存，保存在程序整个生命周期；
    - 静态局部变量只被初始化一次（在main函数中初始化一次，随后定义他的函数中的初始化语句**static int a=1**的初始化操作**mov a, 1**不会再出现再定义的函数位置。静态局部变量再定义的函数退出之后不会消失，在再次进入定义的函数时会继续引用内存中的静态全局变量。静态局部变量和局部变量的区别在于局部变量在栈上分配内存，程序进入时分配内存并初始化(sub sp, xxx)，程序退出时被销毁（add sp, xxx)。

    C++和Java中扩展了static的语义，static变量被认为是类变量，可以通过**类名.静态变量**的方式直接访问。

    C语言静态函数规定了函数只能在本文件中作用，不能使用extern被其他文件访问，可以减少函数耦合。

  其他关键字（4个）

  - const：声明只读变量（只读变量的实现由编译器保证，编译器检查变量发生写行为就会报错编译错误），变量只读，但是变量的指针可以变的。

  - sizeof：计算数据类型长度（sizeof是一个操作符，计算数据类型的长度，由编译器根据数据类型计算长度，如果struct在数据区，那么计算的长度是每个基本类型长度和，如果在栈区，计算长度是基本长度和/4*4，也就是4倍对齐。

  - typdef： 给数据类型别名

  - volatile：

    https://blog.csdn.net/u010134355/article/details/125058164

    https://blog.csdn.net/weixin_38815998/article/details/102883098

    https://blog.csdn.net/weixin_38815998/article/details/102857437

    保证使用变量的时候总是从内存中重新读取变量。volatile作用在于多进程编译器优化方面，非多进程编译器优化不受影响，在非多进程程序中，改变用户程序的指令总是在当前进程中，而这个改变是会反映到使用该变量的指令中的；而对于多进程编译器优化，应为编译器优化的时候总是针对一个进程内部的指令的优化，不能反映时钟中断和调度的效果，造成被优化的变量读取到一个寄存器，然后这个寄存器一直被使用，而实际上在这个过程中可能发生时钟中断子进程修改了共享变量的数值，所以父进程在使用这个共享变量的时候寄存器的值不是实际变量的值，这个时候应该重新读取共享变量到寄存器使用。而volatile的作用就在于这样，他在共享变量被使用的时候总是从变量内存重新读取变量新值。

    volatile变量的实现是，在使用volatile变量的地方先关中断，然后重新读取volatile共享变量的值到寄存器，然后操作完成之后再开中断。比如**volatile a=0; int c=a;**代码的实现是**cli; mov eax, ss:-8[ebp]; mov ss:-4[ebp],eax; sti**

    gcc编译器默认不适用优化，但是工业界为了获得更高效的代码，会开启编译器优化，开启编译器优化就会产生上述的多进程编译器优化共享变量不一致的问题，所以产生了volatile变量来解决这个问题。

    gcc编译器有会员又3个级别，高级别优化会更厉害。

    编译器优化方法：

    - 编译器优化会对未使用的变量根本不会申请内存（比如上int a=0，如果a没有被使用那么main函数就不会分配栈内存给a变量，同时main里面也不是又mov ss:-4[ebp],0这样初始化a变量的代码）
    - 编译器优化会对赋值操作直接使用寄存器上的值而不会重新读取栈上变量的值到寄存器然后赋值（比如栈上**int a=0; int b=a; int c=a;** 编译器优化会让实现变成**mov ss:-12[ebp], 0; mov eax, ss:-12[ebp]; mov ss:-8[ebp], eax; mov ss:-4[ebp], eax; **而不是**mov ss:-12[ebp], 0; mov eax, ss:-12[ebp]; mov ss:-8[ebp], eax; mov eax, ss:-12[ebp]; mov ss:-4[ebp], eax; ** 
    - 编译器优化会对非volatile修饰while(value--)延时操作直接无视掉，根本不会申请value变量内存和做这个循环，把延时操作删除。而延时操作时触发时钟中断进行调度的一种方式，所以在多进程中是不能忽略的。那么设置**volatile int value=1000000**也就是设置value为volatile可以强制产生**cli; mov eax, ss:X[ebp]; sti**的指令，那么也就不会忽略while(value--)延时操作

    **下面的程序时编译器优化导致的效果比较**

    ```c
    //源程序
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <pthread.h>
     
    int main(){
    	int a=1;
    	printf("%d\n",a) ;
    	return 0;
    }
    
    
    //没有编译器优化gcc编译
    //gcc -o test0 test1.c
    	.file	"test1.c"
    	.text
    	.section	.rodata
    .LC0:
    	.string	"%d\n"
    	.text
    	.globl	main
    	.type	main, @function
    main:
    .LFB6:
    	.cfi_startproc
    	endbr64
    	pushq	%rbp
    	.cfi_def_cfa_offset 16
    	.cfi_offset 6, -16
    	movq	%rsp, %rbp
    	.cfi_def_cfa_register 6
    	subq	$16, %rsp
    	movl	$1, -4(%rbp)
    	movl	-4(%rbp), %eax
    	movl	%eax, %esi
    	leaq	.LC0(%rip), %rdi
    	movl	$0, %eax
    	call	printf@PLT
    	movl	$0, %eax
    	leave
    	.cfi_def_cfa 7, 8
    	ret
    	.cfi_endproc
    .LFE6:
    	.size	main, .-main
    	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
    	.section	.note.GNU-stack,"",@progbits
    	.section	.note.gnu.property,"a"
    	.align 8
    	.long	 1f - 0f
    	.long	 4f - 1f
    	.long	 5
    0:
    	.string	 "GNU"
    1:
    	.align 8
    	.long	 0xc0000002
    	.long	 3f - 2f
    2:
    	.long	 0x3
    3:
    	.align 8
    4:
    
    
    
    //编译器优化1级
    //gcc -O1 -o test1 test1.c
    	.file	"test1.c"
    	.text
    	.section	.rodata.str1.1,"aMS",@progbits,1
    .LC0:
    	.string	"%d\n"
    	.text
    	.globl	main
    	.type	main, @function
    main:
    .LFB51:
    	.cfi_startproc
    	endbr64
    	subq	$8, %rsp
    	.cfi_def_cfa_offset 16
    	movl	$1, %edx
    	leaq	.LC0(%rip), %rsi
    	movl	$1, %edi
    	movl	$0, %eax
    	call	__printf_chk@PLT
    	movl	$0, %eax
    	addq	$8, %rsp
    	.cfi_def_cfa_offset 8
    	ret
    	.cfi_endproc
    .LFE51:
    	.size	main, .-main
    	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
    	.section	.note.GNU-stack,"",@progbits
    	.section	.note.gnu.property,"a"
    	.align 8
    	.long	 1f - 0f
    	.long	 4f - 1f
    	.long	 5
    0:
    	.string	 "GNU"
    1:
    	.align 8
    	.long	 0xc0000002
    	.long	 3f - 2f
    2:
    	.long	 0x3
    3:
    	.align 8
    4:
    
    
    
    //编译器优化2级
    //gcc -O2 -o test2 test1.c
    	.file	"test1.c"
    	.text
    	.section	.rodata.str1.1,"aMS",@progbits,1
    .LC0:
    	.string	"%d\n"
    	.section	.text.startup,"ax",@progbits
    	.p2align 4
    	.globl	main
    	.type	main, @function
    main:
    .LFB51:
    	.cfi_startproc
    	endbr64
    	subq	$8, %rsp
    	.cfi_def_cfa_offset 16
    	movl	$1, %edx
    	movl	$1, %edi
    	xorl	%eax, %eax
    	leaq	.LC0(%rip), %rsi
    	call	__printf_chk@PLT
    	xorl	%eax, %eax
    	addq	$8, %rsp
    	.cfi_def_cfa_offset 8
    	ret
    	.cfi_endproc
    .LFE51:
    	.size	main, .-main
    	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
    	.section	.note.GNU-stack,"",@progbits
    	.section	.note.gnu.property,"a"
    	.align 8
    	.long	 1f - 0f
    	.long	 4f - 1f
    	.long	 5
    0:
    	.string	 "GNU"
    1:
    	.align 8
    	.long	 0xc0000002
    	.long	 3f - 2f
    2:
    	.long	 0x3
    3:
    	.align 8
    4:
    
    
    
    //编译器优化3级
    //gcc -O3 -o test3 test1.c
    	.file	"test1.c"
    	.text
    	.section	.rodata.str1.1,"aMS",@progbits,1
    .LC0:
    	.string	"%d\n"
    	.section	.text.startup,"ax",@progbits
    	.p2align 4
    	.globl	main
    	.type	main, @function
    main:
    .LFB51:
    	.cfi_startproc
    	endbr64
    	subq	$8, %rsp
    	.cfi_def_cfa_offset 16
    	movl	$1, %edx
    	movl	$1, %edi
    	xorl	%eax, %eax
    	leaq	.LC0(%rip), %rsi
    	call	__printf_chk@PLT
    	xorl	%eax, %eax
    	addq	$8, %rsp
    	.cfi_def_cfa_offset 8
    	ret
    	.cfi_endproc
    .LFE51:
    	.size	main, .-main
    	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
    	.section	.note.GNU-stack,"",@progbits
    	.section	.note.gnu.property,"a"
    	.align 8
    	.long	 1f - 0f
    	.long	 4f - 1f
    	.long	 5
    0:
    	.string	 "GNU"
    1:
    	.align 8
    	.long	 0xc0000002
    	.long	 3f - 2f
    2:
    	.long	 0x3
    3:
    	.align 8
    4:
    
    ```

    volatile主要应用在多进程编译器优化程序中，并且必须设置volatile变量为共享全局变量，并且必须使用vfork（使用fork的话为了使用共享全局变量必须使用共享内存，而共享内存返回的时一个指针，而堆指针进行volatile设置没有任何效果）。vfork天然为多进程共享数据设计。

    **下面是多进程编译器优化使用volatile和不使用的结果**

    ​		从下面的实验可以看到volatile变量会阻止编译器优化删除while延时函数，同时保证每次使用变量的时候会重新读取内存中的volatile变量值。

    - 非volatile非编译器优化

      ```
      //不使用volatile源程序
      
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
      #include <pthread.h>
       
      int a = 1;
       
      void *child_pth_fun(void *arg);
       
      int main(){
       
      	int b, c;
      	int val = 10000000;
      	
      	//创建子线程
      	pthread_t child_pth_id;
      	/*
      	pthread_create使用的vfork来实现子进程。fork系统调用创造子进程过程，先find_empty_process获取空pid和任务id，
      		然后申请一页内存，将父进程的PCB复制到新页中作为子进程的PCB，修改子进程PCB的参数，修改子进程的父进程节点，
      		修改子进程的状态为可运行态TASK_RUNNING，（打开文件表，TSS寄存器结构，信号相关），修改brk堆指针，修改用户程序和内核程序执行时间等，
      		同时对基于栈切换进程的进程切换，会构造栈切换数据结构，将当前寄存器的数据压入子进程PCB页的顶部形成子进程内核栈，
      		也就是构造子进程内核栈在子进程PCB的页顶端；然后申请数据段&堆栈段页目录项（在0地址空间开始），为页表申请内存，
      		将父进程的页表项赋值给新的页表，将新页表地址赋值给页目录项，将子进程的页目录表的地址赋值给CR3寄存器（current指向内存），
      		然后修改父进程和子进程页表为只读，增加mem_map内存映射图中对应页的共享数目；之后调用schedule进行进程调度，
      		schedule首先从任务数组task_table中找到一个就绪态的进程，然后返回任务号，之后使用switch_to执行进程切换，
      		保存PCB，重写tss栈指针（保存intel结构），切换current指针指向切换到的进程，切换ss:esp为切换到的进程的内核栈，然后执行fork的返回，
      		fork返回会恢复寄存器数值，最后使用iret指令恢复进程用户空间程序的cs:eip, ss:esp, eflags，重新回到用户程序执行。
      		
      		vfork的却别在于在复制父进程页表的时候，本来需要修改页表项为只读并且增加mem_map内存映射图的占用数，但是vfork对数据区（数据区分
      		初始化数据区.data和未初始化数据区.bss）的页表项并不设置只读，导致数据区的数据是共享数据，子进程在写共享数据的时候会进行写检查write_verify，
      		发现这个地方为可读，就不会重新分配空间复制这个变量，那么子进程修改的变量和父进程占用的是同一个变量，达到共享内存的全局变量的效果。
      	*/
      	pthread_create(&child_pth_id, NULL, child_pth_fun, NULL);
      	
      		
      	b = a;
      	
      
      	//延时操作
      	//消耗时间片延时
      	/*
      	消耗时间片方法延迟会占用CPU，这个过程主要发生时钟中断，在while消耗CPU时间的时候，会发生时钟中断，时钟中断发生调度，执行其他程序。
      	发生时钟中断的时候进程的运行状态依然是TASK_RUNNING，当while所处进程被重新调度唤醒，会冲洗运行while循环。
      	*/
      	while(val--) ;
      	//通过阻塞延时
      	/*
      	sleep延时方法会使用设置信号系统调用设置进程的ALARM信号，根据延时时间1s和Linux时间片1个10ms，那么会有1s/10ms=100个时钟中断，也就是ALARM=jiffies+100，
      	设置ALARM信号之后，设置进程状态为阻塞状态，然后调用schedule调度程序进行京城调度。当每次时钟中断发生时，会让进程运行时间counter-1,同时会检查每个进程的信号，如果当前jiffies>=ALARM，
      	就会设置那个进程的状态为TASK_RUNNING,然后时钟中断启动schedule系统调度，从TASK_RUNNING的进程中找到一个执行switch_to进程切换。switch_to保存PCB，重置TSS栈，
      	切换current指针，切换内核栈，然后执行从内核空间返回到用户空间操作。如果是sleep所在的进程，就是返回sleep的用户程序执行。
      
      	消耗CPU延时和阻塞延时的却别在于，CPU延时会占用CPU，这个过程可能发生时钟中断让进程放弃CPU，当时状态是TASK_RUNNING，在就绪队列中；
      	阻塞延时会设置进程为TASK_INTERRUPTIBLE并且立即放弃CPU进行进程调度，同时修改ALARM信号，阻塞延时依靠时钟中断检查是否超过ALARM信号设置的时间，等到超过的时候才会设置进程TASK_RUNNING进入就绪队列
      	*/
      	//sleep(1);
       
      	c = a;
      	printf("In main pthread: a=%d, b=%d, c=%d\n", a, b, c);
      	
       	/*
      	pthread_join调用wait调用。wait系统调用等待子进程完成退出之后菜才能退出。当子进程执行自己的程序到右括号}的时候，会调用exit内核函数来杀死进程。
      		exit会清空任务数组中子进程所在位置设置为null，同时释放子进程占用的内存（清除页目录表，清除页表的mem_map位置-1），释放占用文件等等。
      		修改子进程的运行状态为TASK_END。当发生时钟中断的时候，时钟中断会检查所有进程，如果是TASK_END，就会循环任务队列，将子进程对应的父进程
      		等待的子进程数目-1，如果子进程数据变成0，那么父进程将被设置成TASK_RUNNING，然后调用schedule函数进行进程调度。如果调度到父进程，
      		父进程从pthread_join的wait系统调用返回到用户空间
      	
      		如果不适用wait系统调用，那么在父进程右括号}exit退出之后，exit内核退出函数会扫描所有任务队列，对父进程的子进程，因为父进程退出了，会设置
      		子进程的父进程为0进程。0进程执行的程序时while(1）{pause}，也就是0进程他不断触发调度。
      	*/
      	pthread_join(child_pth_id, NULL);
      	return 0;
       
      }
       
      void *child_pth_fun(void *arg){
       
          //子线程修改共享的全局变量
          	a = 4;		
          	printf("In child pthread: a=%d\n", a);
      }
      
      
      
      
      //不适用volatile源程序编译结果
      	.file	"testUnV.c"
      	.text
      	.globl	a
      	.data
      	.align 4
      	.type	a, @object
      	.size	a, 4
      a:
      	.long	1
      	.section	.rodata
      	.align 8
      .LC0:
      	.string	"In main pthread: a=%d, b=%d, c=%d\n"
      	.text
      	.globl	main
      	.type	main, @function
      main:
      .LFB6:
      	.cfi_startproc
      	endbr64
      	pushq	%rbp
      	.cfi_def_cfa_offset 16
      	.cfi_offset 6, -16
      	movq	%rsp, %rbp
      	.cfi_def_cfa_register 6
      	subq	$32, %rsp
      	movq	%fs:40, %rax
      	movq	%rax, -8(%rbp)
      	xorl	%eax, %eax
      	movl	$10000000, -28(%rbp)
      	leaq	-16(%rbp), %rax
      	movl	$0, %ecx
      	leaq	child_pth_fun(%rip), %rdx
      	movl	$0, %esi
      	movq	%rax, %rdi
      	call	pthread_create@PLT
      	movl	a(%rip), %eax
      	movl	%eax, -24(%rbp)
      	nop
      .L2:
      	movl	-28(%rbp), %eax
      	leal	-1(%rax), %edx
      	movl	%edx, -28(%rbp)
      	testl	%eax, %eax
      	jne	.L2
      	movl	a(%rip), %eax
      	movl	%eax, -20(%rbp)
      	movl	a(%rip), %eax
      	movl	-20(%rbp), %ecx
      	movl	-24(%rbp), %edx
      	movl	%eax, %esi
      	leaq	.LC0(%rip), %rdi
      	movl	$0, %eax
      	call	printf@PLT
      	movq	-16(%rbp), %rax
      	movl	$0, %esi
      	movq	%rax, %rdi
      	call	pthread_join@PLT
      	movl	$0, %eax
      	movq	-8(%rbp), %rsi
      	xorq	%fs:40, %rsi
      	je	.L4
      	call	__stack_chk_fail@PLT
      .L4:
      	leave
      	.cfi_def_cfa 7, 8
      	ret
      	.cfi_endproc
      .LFE6:
      	.size	main, .-main
      	.section	.rodata
      .LC1:
      	.string	"In child pthread: a=%d\n"
      	.text
      	.globl	child_pth_fun
      	.type	child_pth_fun, @function
      child_pth_fun:
      .LFB7:
      	.cfi_startproc
      	endbr64
      	pushq	%rbp
      	.cfi_def_cfa_offset 16
      	.cfi_offset 6, -16
      	movq	%rsp, %rbp
      	.cfi_def_cfa_register 6
      	subq	$16, %rsp
      	movq	%rdi, -8(%rbp)
      	movl	$4, a(%rip)
      	movl	a(%rip), %eax
      	movl	%eax, %esi
      	leaq	.LC1(%rip), %rdi
      	movl	$0, %eax
      	call	printf@PLT
      	nop
      	leave
      	.cfi_def_cfa 7, 8
      	ret
      	.cfi_endproc
      .LFE7:
      	.size	child_pth_fun, .-child_pth_fun
      	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
      	.section	.note.GNU-stack,"",@progbits
      	.section	.note.gnu.property,"a"
      	.align 8
      	.long	 1f - 0f
      	.long	 4f - 1f
      	.long	 5
      0:
      	.string	 "GNU"
      1:
      	.align 8
      	.long	 0xc0000002
      	.long	 3f - 2f
      2:
      	.long	 0x3
      3:
      	.align 8
      4:
      ```

      ![Screenshot 2022-10-15 182556](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-15 182556.png)

    - 非volatile编译器优化

      ```c
      //源程序见上面一个讨论，这里给出非volatile编译器优化 汇编代码
      
      	.file	"testUnV.c"
      	.text
      	.section	.rodata.str1.1,"aMS",@progbits,1
      .LC0:
      	.string	"In child pthread: a=%d\n"
      	.text
      	.p2align 4
      	.globl	child_pth_fun
      	.type	child_pth_fun, @function
      child_pth_fun:
      .LFB52:
      	.cfi_startproc
      	endbr64
      	subq	$8, %rsp
      	.cfi_def_cfa_offset 16
      	movl	$4, %edx
      	movl	$1, %edi
      	xorl	%eax, %eax
      	leaq	.LC0(%rip), %rsi
      	movl	$4, a(%rip)
      	call	__printf_chk@PLT
      	addq	$8, %rsp
      	.cfi_def_cfa_offset 8
      	ret
      	.cfi_endproc
      .LFE52:
      	.size	child_pth_fun, .-child_pth_fun
      	.section	.rodata.str1.8,"aMS",@progbits,1
      	.align 8
      .LC1:
      	.string	"In main pthread: a=%d, b=%d, c=%d\n"
      	.section	.text.startup,"ax",@progbits
      	.p2align 4
      	.globl	main
      	.type	main, @function
      main:
      .LFB51:
      	.cfi_startproc
      	endbr64
      	subq	$24, %rsp
      	.cfi_def_cfa_offset 32
      	xorl	%ecx, %ecx
      	leaq	child_pth_fun(%rip), %rdx
      	xorl	%esi, %esi
      	movq	%fs:40, %rax
      	movq	%rax, 8(%rsp)
      	xorl	%eax, %eax
      	movq	%rsp, %rdi
      	call	pthread_create@PLT
      	movl	a(%rip), %edx
      	leaq	.LC1(%rip), %rsi
      	xorl	%eax, %eax
      	movl	$1, %edi
      	movl	%edx, %r8d
      	movl	%edx, %ecx
      	call	__printf_chk@PLT
      	movq	(%rsp), %rdi
      	xorl	%esi, %esi
      	call	pthread_join@PLT
      	movq	8(%rsp), %rax
      	xorq	%fs:40, %rax
      	jne	.L7
      	xorl	%eax, %eax
      	addq	$24, %rsp
      	.cfi_remember_state
      	.cfi_def_cfa_offset 8
      	ret
      .L7:
      	.cfi_restore_state
      	call	__stack_chk_fail@PLT
      	.cfi_endproc
      .LFE51:
      	.size	main, .-main
      	.globl	a
      	.data
      	.align 4
      	.type	a, @object
      	.size	a, 4
      a:
      	.long	1
      	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
      	.section	.note.GNU-stack,"",@progbits
      	.section	.note.gnu.property,"a"
      	.align 8
      	.long	 1f - 0f
      	.long	 4f - 1f
      	.long	 5
      0:
      	.string	 "GNU"
      1:
      	.align 8
      	.long	 0xc0000002
      	.long	 3f - 2f
      2:
      	.long	 0x3
      3:
      	.align 8
      4:
      ```

      ![Screenshot 2022-10-15 183718](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-15 183718.png)

      - volatile非编译器优化

        ```
        #include <stdio.h>
        #include <stdlib.h>
        #include <unistd.h>
        #include <pthread.h>
         
        int a = 1;
         
        void *child_pth_fun(void *arg);
         
        int main(){
         
        	int b, c;
        	volatile int val = 10000000;
        	
        	//创建子线程
        	pthread_t child_pth_id;
        	/*
        	pthread_create使用的vfork来实现子进程。fork系统调用创造子进程过程，先find_empty_process获取空pid和任务id，
        		然后申请一页内存，将父进程的PCB复制到新页中作为子进程的PCB，修改子进程PCB的参数，修改子进程的父进程节点，
        		修改子进程的状态为可运行态TASK_RUNNING，（打开文件表，TSS寄存器结构，信号相关），修改brk堆指针，修改用户程序和内核程序执行时间等，
        		同时对基于栈切换进程的进程切换，会构造栈切换数据结构，将当前寄存器的数据压入子进程PCB页的顶部形成子进程内核栈，
        		也就是构造子进程内核栈在子进程PCB的页顶端；然后申请数据段&堆栈段页目录项（在0地址空间开始），为页表申请内存，
        		将父进程的页表项赋值给新的页表，将新页表地址赋值给页目录项，将子进程的页目录表的地址赋值给CR3寄存器（current指向内存），
        		然后修改父进程和子进程页表为只读，增加mem_map内存映射图中对应页的共享数目；之后调用schedule进行进程调度，
        		schedule首先从任务数组task_table中找到一个就绪态的进程，然后返回任务号，之后使用switch_to执行进程切换，
        		保存PCB，重写tss栈指针（保存intel结构），切换current指针指向切换到的进程，切换ss:esp为切换到的进程的内核栈，然后执行fork的返回，
        		fork返回会恢复寄存器数值，最后使用iret指令恢复进程用户空间程序的cs:eip, ss:esp, eflags，重新回到用户程序执行。
        		
        		vfork的却别在于在复制父进程页表的时候，本来需要修改页表项为只读并且增加mem_map内存映射图的占用数，但是vfork对数据区（数据区分
        		初始化数据区.data和未初始化数据区.bss）的页表项并不设置只读，导致数据区的数据是共享数据，子进程在写共享数据的时候会进行写检查write_verify，
        		发现这个地方为可读，就不会重新分配空间复制这个变量，那么子进程修改的变量和父进程占用的是同一个变量，达到共享内存的全局变量的效果。
        	*/
        	pthread_create(&child_pth_id, NULL, child_pth_fun, NULL);
        	
        		
        	b = a;
        	
        
        	//延时操作
        	//消耗时间片延时
        	/*
        	消耗时间片方法延迟会占用CPU，这个过程主要发生时钟中断，在while消耗CPU时间的时候，会发生时钟中断，时钟中断发生调度，执行其他程序。
        	发生时钟中断的时候进程的运行状态依然是TASK_RUNNING，当while所处进程被重新调度唤醒，会冲洗运行while循环。
        	*/
        	while(val--) ;
        	//通过阻塞延时
        	/*
        	sleep延时方法会使用设置信号系统调用设置进程的ALARM信号，根据延时时间1s和Linux时间片1个10ms，那么会有1s/10ms=100个时钟中断，也就是ALARM=jiffies+100，
        	设置ALARM信号之后，设置进程状态为阻塞状态，然后调用schedule调度程序进行京城调度。当每次时钟中断发生时，会让进程运行时间counter-1,同时会检查每个进程的信号，如果当前jiffies>=ALARM，
        	就会设置那个进程的状态为TASK_RUNNING,然后时钟中断启动schedule系统调度，从TASK_RUNNING的进程中找到一个执行switch_to进程切换。switch_to保存PCB，重置TSS栈，
        	切换current指针，切换内核栈，然后执行从内核空间返回到用户空间操作。如果是sleep所在的进程，就是返回sleep的用户程序执行。
        
        	消耗CPU延时和阻塞延时的却别在于，CPU延时会占用CPU，这个过程可能发生时钟中断让进程放弃CPU，当时状态是TASK_RUNNING，在就绪队列中；
        	阻塞延时会设置进程为TASK_INTERRUPTIBLE并且立即放弃CPU进行进程调度，同时修改ALARM信号，阻塞延时依靠时钟中断检查是否超过ALARM信号设置的时间，等到超过的时候才会设置进程TASK_RUNNING进入就绪队列
        	*/
        	//sleep(1);
         
        	c = a;
        	printf("In main pthread: a=%d, b=%d, c=%d\n", a, b, c);
        	
         	/*
        	pthread_join调用wait调用。wait系统调用等待子进程完成退出之后菜才能退出。当子进程执行自己的程序到右括号}的时候，会调用exit内核函数来杀死进程。
        		exit会清空任务数组中子进程所在位置设置为null，同时释放子进程占用的内存（清除页目录表，清除页表的mem_map位置-1），释放占用文件等等。
        		修改子进程的运行状态为TASK_END。当发生时钟中断的时候，时钟中断会检查所有进程，如果是TASK_END，就会循环任务队列，将子进程对应的父进程
        		等待的子进程数目-1，如果子进程数据变成0，那么父进程将被设置成TASK_RUNNING，然后调用schedule函数进行进程调度。如果调度到父进程，
        		父进程从pthread_join的wait系统调用返回到用户空间
        	
        		如果不适用wait系统调用，那么在父进程右括号}exit退出之后，exit内核退出函数会扫描所有任务队列，对父进程的子进程，因为父进程退出了，会设置
        		子进程的父进程为0进程。0进程执行的程序时while(1）{pause}，也就是0进程他不断触发调度。
        	*/
        	pthread_join(child_pth_id, NULL);
        	return 0;
         
        }
         
        void *child_pth_fun(void *arg){
         
            //子线程修改共享的全局变量
            	a = 4;		
            	printf("In child pthread: a=%d\n", a);
        }
        
        
        //////////////////////汇编代码
        	.file	"testV.c"
        	.text
        	.section	.rodata.str1.1,"aMS",@progbits,1
        .LC0:
        	.string	"In child pthread: a=%d\n"
        	.text
        	.p2align 4
        	.globl	child_pth_fun
        	.type	child_pth_fun, @function
        child_pth_fun:
        .LFB52:
        	.cfi_startproc
        	endbr64
        	subq	$8, %rsp
        	.cfi_def_cfa_offset 16
        	movl	$4, %edx
        	movl	$1, %edi
        	xorl	%eax, %eax
        	leaq	.LC0(%rip), %rsi
        	movl	$4, a(%rip)
        	call	__printf_chk@PLT
        	addq	$8, %rsp
        	.cfi_def_cfa_offset 8
        	ret
        	.cfi_endproc
        .LFE52:
        	.size	child_pth_fun, .-child_pth_fun
        	.section	.rodata.str1.8,"aMS",@progbits,1
        	.align 8
        .LC1:
        	.string	"In main pthread: a=%d, b=%d, c=%d\n"
        	.section	.text.startup,"ax",@progbits
        	.p2align 4
        	.globl	main
        	.type	main, @function
        main:
        .LFB51:
        	.cfi_startproc
        	endbr64
        	subq	$40, %rsp
        	.cfi_def_cfa_offset 48
        	leaq	child_pth_fun(%rip), %rdx
        	xorl	%ecx, %ecx
        	xorl	%esi, %esi
        	movq	%fs:40, %rax
        	movq	%rax, 24(%rsp)
        	xorl	%eax, %eax
        	leaq	16(%rsp), %rdi
        	movl	$10000000, 12(%rsp)
        	call	pthread_create@PLT
        	movl	a(%rip), %edx
        	.p2align 4,,10
        	.p2align 3
        .L5:
        	movl	12(%rsp), %eax
        	leal	-1(%rax), %ecx
        	movl	%ecx, 12(%rsp)
        	testl	%eax, %eax
        	jne	.L5
        	movl	%edx, %r8d
        	movl	%edx, %ecx
        	movl	$1, %edi
        	leaq	.LC1(%rip), %rsi
        	call	__printf_chk@PLT
        	movq	16(%rsp), %rdi
        	xorl	%esi, %esi
        	call	pthread_join@PLT
        	movq	24(%rsp), %rax
        	xorq	%fs:40, %rax
        	jne	.L9
        	xorl	%eax, %eax
        	addq	$40, %rsp
        	.cfi_remember_state
        	.cfi_def_cfa_offset 8
        	ret
        .L9:
        	.cfi_restore_state
        	call	__stack_chk_fail@PLT
        	.cfi_endproc
        .LFE51:
        	.size	main, .-main
        	.globl	a
        	.data
        	.align 4
        	.type	a, @object
        	.size	a, 4
        a:
        	.long	1
        	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
        	.section	.note.GNU-stack,"",@progbits
        	.section	.note.gnu.property,"a"
        	.align 8
        	.long	 1f - 0f
        	.long	 4f - 1f
        	.long	 5
        0:
        	.string	 "GNU"
        1:
        	.align 8
        	.long	 0xc0000002
        	.long	 3f - 2f
        2:
        	.long	 0x3
        3:
        	.align 8
        4:
        
        ```

        ![Screenshot 2022-10-15 184659](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-15 184659.png)

      - volatile编译器优化

        ```
        	.file	"testV.c"
        	.text
        	.globl	a
        	.data
        	.align 4
        	.type	a, @object
        	.size	a, 4
        a:
        	.long	1
        	.section	.rodata
        	.align 8
        .LC0:
        	.string	"In main pthread: a=%d, b=%d, c=%d\n"
        	.text
        	.globl	main
        	.type	main, @function
        main:
        .LFB6:
        	.cfi_startproc
        	endbr64
        	pushq	%rbp
        	.cfi_def_cfa_offset 16
        	.cfi_offset 6, -16
        	movq	%rsp, %rbp
        	.cfi_def_cfa_register 6
        	subq	$32, %rsp
        	movq	%fs:40, %rax
        	movq	%rax, -8(%rbp)
        	xorl	%eax, %eax
        	movl	$10000000, -28(%rbp)
        	leaq	-16(%rbp), %rax
        	movl	$0, %ecx
        	leaq	child_pth_fun(%rip), %rdx
        	movl	$0, %esi
        	movq	%rax, %rdi
        	call	pthread_create@PLT
        	movl	a(%rip), %eax
        	movl	%eax, -24(%rbp)
        	nop
        .L2:
        	movl	-28(%rbp), %eax
        	leal	-1(%rax), %edx
        	movl	%edx, -28(%rbp)
        	testl	%eax, %eax
        	jne	.L2
        	movl	a(%rip), %eax
        	movl	%eax, -20(%rbp)
        	movl	a(%rip), %eax
        	movl	-20(%rbp), %ecx
        	movl	-24(%rbp), %edx
        	movl	%eax, %esi
        	leaq	.LC0(%rip), %rdi
        	movl	$0, %eax
        	call	printf@PLT
        	movq	-16(%rbp), %rax
        	movl	$0, %esi
        	movq	%rax, %rdi
        	call	pthread_join@PLT
        	movl	$0, %eax
        	movq	-8(%rbp), %rsi
        	xorq	%fs:40, %rsi
        	je	.L4
        	call	__stack_chk_fail@PLT
        .L4:
        	leave
        	.cfi_def_cfa 7, 8
        	ret
        	.cfi_endproc
        .LFE6:
        	.size	main, .-main
        	.section	.rodata
        .LC1:
        	.string	"In child pthread: a=%d\n"
        	.text
        	.globl	child_pth_fun
        	.type	child_pth_fun, @function
        child_pth_fun:
        .LFB7:
        	.cfi_startproc
        	endbr64
        	pushq	%rbp
        	.cfi_def_cfa_offset 16
        	.cfi_offset 6, -16
        	movq	%rsp, %rbp
        	.cfi_def_cfa_register 6
        	subq	$16, %rsp
        	movq	%rdi, -8(%rbp)
        	movl	$4, a(%rip)
        	movl	a(%rip), %eax
        	movl	%eax, %esi
        	leaq	.LC1(%rip), %rdi
        	movl	$0, %eax
        	call	printf@PLT
        	nop
        	leave
        	.cfi_def_cfa 7, 8
        	ret
        	.cfi_endproc
        .LFE7:
        	.size	child_pth_fun, .-child_pth_fun
        	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
        	.section	.note.GNU-stack,"",@progbits
        	.section	.note.gnu.property,"a"
        	.align 8
        	.long	 1f - 0f
        	.long	 4f - 1f
        	.long	 5
        0:
        	.string	 "GNU"
        1:
        	.align 8
        	.long	 0xc0000002
        	.long	 3f - 2f
        2:
        	.long	 0x3
        3:
        	.align 8
        4:
        
        ```

        ![Screenshot 2022-10-15 184818](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-15 184818.png)

      volatile变量可以修饰全局变量或者局部变量，主要效果是**cli; mov eax, ss:-xx[ebp]; sti**，一般进程共享全局变量需要用volatile修饰来同步互斥。

**C99引入了5个关键字**

inline， restrict, _Bool, _Complex, _Imaginary

**C11引入了7个关键字**

_Alignas, _Alignof, _Atomic,  _Static_assert,  _Noreturn,  _Thread_local,  _Generic

- _Thread_local

  https://cloud.tencent.com/developer/article/1915012

  https://www.cnblogs.com/gd-luojialin/p/15027719.html

  https://www.cnblogs.com/zhoug2020/p/6497709.html

  http://www.codebaoku.com/it-c/it-c-207197.html

  [重要]https://stackoverflow.com/questions/10810203/what-is-the-fs-gs-register-intended-for#:~:text=FS%20is%20used%20to%20point,function%20in%20FS%3A%5B0x00%5D%20.

  [重要]https://www.kernel.org/doc/html/latest/x86/x86_64/fsgs.html

  https://maskray.me/blog/2021-02-14-all-about-thread-local-storage

  https://stackoverflow.com/questions/32245103/how-does-the-gcc-thread-work

  https://stackoverflow.com/questions/14289634/thread-local-storage-class-specifier-in-c

  [非常重要] https://www.cnblogs.com/abozhang/p/10800332.html

  [非常重要] https://www.educative.io/answers/what-is-the-threadlocal-keyword-in-c

  [非常重要] https://www.cnblogs.com/gd-luojialin/p/15027719.html

  [比较重要-pthread和_thread_local两种实现thread_local] https://blog.csdn.net/aguoxin/article/details/103968031

  [比较重要-Java的thread_local实现] https://blog.csdn.net/pcww12/article/details/125568535

  线程本地存储，在gcc中实现的关键字是thread_local，这种实现是基于编译器的。线程本地存储thread_local_storage(TLS)的含义是变量在进程开始的时候初始化，在进程结束的时候销毁，相当于进程全局变量，而这个变量在其他进程中是不一样的，不会相互影响。

  全局变量的作用域是整个程序，整个程序的每个函数和每个进程都是可见全局变量的，全局变量随着整个程序运行创建，随着整个程序退出被销毁；局部变量作用域在局部变量定义的函数内部，函数调用时创建和初始化，函数退出时销毁；而线程本地存储的作用域在线程内部，它随着线程创建被创建和初始化，随着线程退出而被销毁。

  线程本地存储的实现有很多种，一种结合gcc编译其和fork系统调用的方式是如下面的程序所示。主进程将所有子进程使用的线程本地存储变量汇总到一个.tdata段代表线程本地存储段，当使用thread_create调用fork系统调用创建子进程的时候，会在子进程的内核栈中压入fs段寄存器，fs段寄存器是这样获得的，首先在线程结构体TCB中加入两个变量.tdata代表线程本地存储数据段地址，在进行foke系统调用的时候会重新分配页面复制.tdata段的页到新页，实现新建子进程的时候初始化线程本地存储变量的目的，同时将新的.tdata段的地址压入子进程的内核栈中去作为fs寄存器的参数。这种线程本地存储让每个线程都有一个父进程.tdata的副本，实现了全局变量在子进程中为一个副本的功能，这个副本在子进程创建时初始化，在子进程退出时销毁。

  ```
  #include <stdio.h>
  #include "threads.h"
  #define SIZE 5
  
  int func(void *id)
  {
      //_Thread_local variable 
      static thread_local int var = 5;
      var += 5;
  
      //Print id of current thread and addr of var
      printf("Thread ID:[%d], Value of var: %d\n", *(int*)id, var);
  
      return 0;
  }
  
  int func1(void *id)
  {
      //_Thread_local variable 
      static thread_local int var = 10;
      var += 5;
  
      //Print id of current thread and addr of var
      printf("Thread ID:[%d], Value of var: %d\n", *(int*)id, var);
  
      return 0;
  }
  
  int main(void)
  {
      thrd_t id[SIZE];
  
      //thread ID arr
      int arr[SIZE] = {1, 2, 3, 4, 5};
  
      //Creating 5 threads
      for(int i = 0; i < SIZE/2; i++) {
          thrd_create(&id[i], func, &arr[i]);
      }
      for(int i = SIZE/2; i < SIZE; i++) {
          thrd_create(&id[i], func1, &arr[i]);
      }
  
      //Wait for threads to complete
      for(int i = 0; i < SIZE; i++) {
          thrd_join(id[i], NULL);
      }
  }
  
  
  
  ///////////////////////////////////////
  
  	.file	"static.c"
  	.text
  	.section	.tdata,"awT",@progbits
  	.align 4
  	.type	var.2533, @object
  	.size	var.2533, 4
  var.2533:
  	.long	5
  	.section	.rodata
  	.align 8
  .LC0:
  	.string	"Thread ID:[%d], Value of var: %d\n"
  	.text
  	.globl	func
  	.type	func, @function
  func:
  .LFB0:
  	.cfi_startproc
  	endbr64
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$16, %rsp
  	movq	%rdi, -8(%rbp)
  	movl	%fs:var.2533@tpoff, %eax			; movl %fs:-16, %eax ; fs在创建进程时申请内存和设置
  	addl	$5, %eax
  	movl	%eax, %fs:var.2533@tpoff
  	movl	%fs:var.2533@tpoff, %edx
  	movq	-8(%rbp), %rax
  	movl	(%rax), %eax
  	movl	%eax, %esi
  	leaq	.LC0(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$0, %eax
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	func, .-func
  	.section	.tdata
  	.align 4
  	.type	var.2537, @object
  	.size	var.2537, 4
  var.2537:
  	.long	10
  	.text
  	.globl	func1
  	.type	func1, @function
  func1:
  .LFB1:
  	.cfi_startproc
  	endbr64
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$16, %rsp
  	movq	%rdi, -8(%rbp)
  	movl	%fs:var.2537@tpoff, %eax			; movl %fs:-8, %eax ; fs在创建进程时申请内存和设置
  	addl	$5, %eax
  	movl	%eax, %fs:var.2537@tpoff
  	movl	%fs:var.2537@tpoff, %edx
  	movq	-8(%rbp), %rax
  	movl	(%rax), %eax
  	movl	%eax, %esi
  	leaq	.LC0(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$0, %eax
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE1:
  	.size	func1, .-func1
  	.globl	main
  	.type	main, @function
  main:
  .LFB2:
  	.cfi_startproc
  	endbr64
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$96, %rsp
  	movq	%fs:40, %rax
  	movq	%rax, -8(%rbp)
  	xorl	%eax, %eax
  	movl	$1, -80(%rbp)
  	movl	$2, -76(%rbp)
  	movl	$3, -72(%rbp)
  	movl	$4, -68(%rbp)
  	movl	$5, -64(%rbp)
  	movl	$0, -92(%rbp)
  	jmp	.L6
  .L7:
  	leaq	-80(%rbp), %rax
  	movl	-92(%rbp), %edx
  	movslq	%edx, %rdx
  	salq	$2, %rdx
  	addq	%rax, %rdx
  	leaq	-48(%rbp), %rax
  	movl	-92(%rbp), %ecx
  	movslq	%ecx, %rcx
  	salq	$3, %rcx
  	addq	%rcx, %rax
  	leaq	func(%rip), %rsi
  	movq	%rax, %rdi
  	call	thrd_create@PLT
  	addl	$1, -92(%rbp)
  .L6:
  	cmpl	$1, -92(%rbp)
  	jle	.L7
  	movl	$2, -88(%rbp)
  	jmp	.L8
  .L9:
  	leaq	-80(%rbp), %rax
  	movl	-88(%rbp), %edx
  	movslq	%edx, %rdx
  	salq	$2, %rdx
  	addq	%rax, %rdx
  	leaq	-48(%rbp), %rax
  	movl	-88(%rbp), %ecx
  	movslq	%ecx, %rcx
  	salq	$3, %rcx
  	addq	%rcx, %rax
  	leaq	func1(%rip), %rsi
  	movq	%rax, %rdi
  	call	thrd_create@PLT
  	addl	$1, -88(%rbp)
  .L8:
  	cmpl	$4, -88(%rbp)
  	jle	.L9
  	movl	$0, -84(%rbp)
  	jmp	.L10
  .L11:
  	movl	-84(%rbp), %eax
  	cltq
  	movq	-48(%rbp,%rax,8), %rax
  	movl	$0, %esi
  	movq	%rax, %rdi
  	call	thrd_join@PLT
  	addl	$1, -84(%rbp)
  .L10:
  	cmpl	$4, -84(%rbp)
  	jle	.L11
  	movl	$0, %eax
  	movq	-8(%rbp), %rsi
  	xorq	%fs:40, %rsi
  	je	.L13
  	call	__stack_chk_fail@PLT
  .L13:
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE2:
  	.size	main, .-main
  	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
  	.section	.note.GNU-stack,"",@progbits
  	.section	.note.gnu.property,"a"
  	.align 8
  	.long	 1f - 0f
  	.long	 4f - 1f
  	.long	 5
  0:
  	.string	 "GNU"
  1:
  	.align 8
  	.long	 0xc0000002
  	.long	 3f - 2f
  2:
  	.long	 0x3
  3:
  	.align 8
  4:
  ```

- _Aatomic

  原子类型，在C语言里是通过**lock xaddl	%eax, atomic_count(%rip)**指令（CPU原语fetch-and-add, 其他有用的CPU原语cmpxchg用来实现CAS操作从而实现进程同步互斥）来实现的。如果用精简指令集架构可以通过cli/sti关中断实现。原子类型可以时全局变量、静态全局变量、静态局部变量、局部变量，他主要是通过CPU原语fetch-and-add指令直接给变量内存进行加法，实际可以通过关中断之后加法操作。

  ```
  #include <stdio.h>
  #include <pthread.h>
  #include <stdatomic.h>
  
  // making an atomic counter
  _Atomic int atomic_count = 0;
  // making a simple variable
  int count = 0;
  
  // the function which will run in the thread
  void* runner()
  {
      for(int i = 0; i < 1000; i++) {
          count++;
          atomic_count++;
      }
      return 0;
  }
  
  int main()
  {
      // making the essential variables to create threads
      pthread_t threadIDs[5];
      pthread_attr_t attr;
      pthread_attr_init(&attr);
  
      // making 5 threads
      for(int i = 0; i < 8; i++)
          pthread_create(&threadIDs[i], &attr, runner, NULL);
      
      // waiting for all threads to finish
      for(int i = 0; i < 8; i++)
          pthread_join(threadIDs[i], NULL);
  
      // printing the variables
      printf("The atomic counter is %u\n", atomic_count);
      printf("The non-atomic counter is %u\n", count);
  }
  
  
  
  ///////////////////////////
  	.file	"automic.c"
  	.text
  	.globl	atomic_count
  	.bss
  	.align 4
  	.type	atomic_count, @object
  	.size	atomic_count, 4
  atomic_count:
  	.zero	4
  	.globl	count
  	.align 4
  	.type	count, @object
  	.size	count, 4
  count:
  	.zero	4
  	.text
  	.globl	runner
  	.type	runner, @function
  runner:
  .LFB0:
  	.cfi_startproc
  	endbr64
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$32, %rsp
  	movq	%fs:40, %rax
  	movq	%rax, -8(%rbp)
  	xorl	%eax, %eax
  	movl	$0, -12(%rbp)
  	jmp	.L2
  .L3:
  	movl	count(%rip), %eax
  	addl	$1, %eax
  	movl	%eax, count(%rip)
  	movl	$1, -20(%rbp)
  	movl	-20(%rbp), %eax
  	lock xaddl	%eax, atomic_count(%rip)
  	movl	%eax, -16(%rbp)
  	addl	$1, -12(%rbp)
  .L2:
  	cmpl	$999, -12(%rbp)
  	jle	.L3
  	movl	$0, %eax
  	movq	-8(%rbp), %rdx
  	xorq	%fs:40, %rdx
  	je	.L5
  	call	__stack_chk_fail@PLT
  .L5:
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	runner, .-runner
  	.section	.rodata
  .LC0:
  	.string	"The atomic counter is %u\n"
  .LC1:
  	.string	"The non-atomic counter is %u\n"
  	.text
  	.globl	main
  	.type	main, @function
  main:
  .LFB1:
  	.cfi_startproc
  	endbr64
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	addq	$-128, %rsp
  	movq	%fs:40, %rax
  	movq	%rax, -8(%rbp)
  	xorl	%eax, %eax
  	leaq	-64(%rbp), %rax
  	movq	%rax, %rdi
  	call	pthread_attr_init@PLT
  	movl	$0, -120(%rbp)
  	jmp	.L7
  .L8:
  	leaq	-112(%rbp), %rax
  	movl	-120(%rbp), %edx
  	movslq	%edx, %rdx
  	salq	$3, %rdx
  	leaq	(%rax,%rdx), %rdi
  	leaq	-64(%rbp), %rax
  	movl	$0, %ecx
  	leaq	runner(%rip), %rdx
  	movq	%rax, %rsi
  	call	pthread_create@PLT
  	addl	$1, -120(%rbp)
  .L7:
  	cmpl	$7, -120(%rbp)
  	jle	.L8
  	movl	$0, -116(%rbp)
  	jmp	.L9
  .L10:
  	movl	-116(%rbp), %eax
  	cltq
  	movq	-112(%rbp,%rax,8), %rax
  	movl	$0, %esi
  	movq	%rax, %rdi
  	call	pthread_join@PLT
  	addl	$1, -116(%rbp)
  .L9:
  	cmpl	$7, -116(%rbp)
  	jle	.L10
  	movl	atomic_count(%rip), %eax
  	movl	%eax, -124(%rbp)
  	movl	-124(%rbp), %eax
  	movl	%eax, %esi
  	leaq	.LC0(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	count(%rip), %eax
  	movl	%eax, %esi
  	leaq	.LC1(%rip), %rdi
  	movl	$0, %eax
  	call	printf@PLT
  	movl	$0, %eax
  	movq	-8(%rbp), %rcx
  	xorq	%fs:40, %rcx
  	je	.L12
  	call	__stack_chk_fail@PLT
  .L12:
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE1:
  	.size	main, .-main
  	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
  	.section	.note.GNU-stack,"",@progbits
  	.section	.note.gnu.property,"a"
  	.align 8
  	.long	 1f - 0f
  	.long	 4f - 1f
  	.long	 5
  0:
  	.string	 "GNU"
  1:
  	.align 8
  	.long	 0xc0000002
  	.long	 3f - 2f
  2:
  	.long	 0x3
  3:
  	.align 8
  4:
  ```

**磁盘管理**

磁盘读写通过硬盘中断完成的，磁盘接入计算机系统之后，计算机端口和磁盘控制器件的寄存器相连接，计算机数据总线和磁盘数据总线连接。BIOS提供硬盘中断，硬盘中断需要传入读写的（磁面、磁道、扇区），控制方式（读写），读写缓冲区地址（es:[ebx]，在写磁盘的时候用作保存写的缓冲块地址，在读的时候用作存储从磁盘读取的数据的缓冲块地址）。进程在读写磁盘的时候因为磁盘是同一时间只能服务一个进程，那么多个进程读写磁盘需要阻塞。一个进程续写磁盘的时候，会向磁盘管理程序发送一个读写请求，磁盘管理线程在接收到一堆磁盘读写请求之后，会对这些请求进行电梯调度算法优化排序，之后从队列头部选取一个请求，使用硬盘中断从磁盘中读取数据到指定的内核缓冲区中。

**文件管理**

Linux任何资源都是按照文件进行管理的。read, write系统调用实现对文件的读写操作，read/write根据文件类型的不同会调用不同的实现函数。对块设备类型调用blk_read/blk_write，对于文件类型调用file_read/file_write，对于管道类型调用pipe_read/pipe_wirte，对于字符类型调用char_read/char_write(控制台管理调用的char_read调用put_char/copy_to_cooked/tty_read/con_write，char_write调用tty_write/con_write)

blk_wirte传入的参数有四个，（设备号dev，文件指针，写字符串数组指针，写字符串个数）。blk_write首先根据文件指针计算出这个指针所在的逻辑块号和在逻辑块中的偏移（逻辑块号=文件指针/1k+数据区起始逻辑块号），然后调用buffer.c中的bread函数传入设备号和逻辑块号获取文件指针所在的块放到内核缓冲块中，bread传入两个参数，设备号和逻辑号，bread函数调用blk函数先从内核缓冲区获取一个块，这个块要么是一个空的块，要么就是我们需要的缓冲块，然后bread函数判断getblk函数获取的内核缓冲块数据是否有效，如果无效或者是一个空的块，就会使用blk_dev/ll_rw_blk.c中的ll_rw_blk函数带入设备号和逻辑号从设备中读取对应的逻辑块放入到内核缓冲区(es:[ebx]），这个过程是磁盘完成的，磁盘数据总线连接计算机数据总线指向es:[ebx]的位置，当ll_rw_blk函数调用磁盘中断函数（BIOS提供）从磁盘读取数据后，磁盘控制器程序接管数据加载到计算机缓冲区的工作，这个时候ll_rw_blk函数所在的进程阻塞。当磁盘控制器加载完成一个缓冲块之后，会重新触发一个磁盘中断，这个磁盘中断唤醒阻塞在磁盘读写队列上的进程。进程被重新唤醒之后bread函数返回获得的内核缓冲块的地址。如果是blk_write函数，他会根据之前计算的文件指针的在缓冲块的偏移位置按照用户空间的字符串数组指针和写字符串个数使用get_fs_char将字符写入到内核缓冲块中。如果文件指针超过磁盘缓冲块1k，也就是这个文件指针不在缓冲块中，会重新出发上述blk_write过程。磁盘读也一样，首先使用bread获取要读的缓冲块，然后从文件指针偏移处读n个字符put_fs_char到用户空间数组中。

file_read/file_write和blk_write/blk_read差不多，只不过file_read/file_write传入的参数是i节点指针，文件读写函数从i节点指针获取需要的设备号和文件指针，然后其他的读写操作和blk_write/blk_read一样。

pipe_read/pipe_write管道，管道实际上是一个文件，用于进程通信或者同步。有名管道使用sys_read/sys_write系统调用调用pipe_read/pipe_write底层读写函数，操作的是一个有名的文件，这个文件可以被计算机中所有进程获取。而基于同样pipe_read/pipe_write的无名管道系统调用sys_pipe会创建无名文件，这个文件只能被使用sys_pipe的进程所创建的子进程所使用。对于文件操作部分，实际上跟file_read/file_write， blk_read/blk_write一样， 都是根据设备号和文件指针bread获得一个内核缓冲区，然后对内核缓冲区进行读写。

char_read/char_write(rw_char)是字符设备读写。字符设备在插入计算机系统的时候，他的控制器的寄存器要接入计算机端口包括控制总线和数据总线都要连接到计算机系统，并且需要提供读写设备的驱动程序，在插入的时候读设备的驱动程序被注册成中断，写设备的驱动程序被加载到内核空间并且函数地址放到字符设备结构体的写函数指针中。当进程向字符设备读的时候（read控制台，socket网卡），会调用tty_read函数从字符设备辅助队列读取数据，如果辅助队列为空，就会阻塞进程。当字符设备有数据到达的时候（控制台设备按下键盘按键，网卡到来数据)，会触发对应的中断函数，中断函数将到达设备的字符处理之后放到辅助队列，然后唤醒阻塞在设备辅助队列上的进程。当被阻塞的进程被唤醒之后，会将辅助队列上的字符拷贝到用户空间的变量中。当发生写设备的时候（write控制台，socket网卡），进程调用tty_write函数将数据写入到字符设备结构体的写缓冲队列中，如果队列满就阻塞进程，然后调用保存在字符设备结构体的写字符设备驱动程序将写缓冲队列的数据写入到设备在计算机中对应的端口或者内存中。之后设备的控制程序会处理对应端口的或者对应数据区的数据【对于磁盘等块设备，磁盘中断需要内核数据区以及读写磁盘的中断函数，以及磁盘完成读写的中断函数。块设备和字符设备拥有相似的处理过程。内核中有字符设备结构体（字符设备结构体数组），也有块设备结构体（超级块数组）；在字符设备插入设备时，需要提供字符设备读写驱动程序，读驱动程序被注册成中断，写驱动程序被放入设备结构体的写函数指针中，同样块设备插入系统时，也需要提供块设备读写驱动程序，读写驱动程序被注册称为中断由用户程序调用（字符设备是读驱动程序被注册成中断，而写驱动程序放入字符设备结构体写函数指针，而块设备读写驱动成旭是通过寄存器区分的，是一个程序而不是两个分开的程序，所以读写驱动程序被注册成中断，块设备读写驱动函数只会被程序调用，而不是硬件中断，是一种软件中断，块设备不会主动触发读写驱动程序，这和字符设备不同，字符设备可以主动触发读中断-按下按键/网卡到达数据都会主动触发读中断），块设备还有一个设备完成读写完成的中断，这个中断会唤醒阻塞在块设备结构体的进程，这个中断是设备控制器完成一个块的读写之后触发的；读字符设备的时候，read系统调用的底层实现函数是tty_read，tty_read检查字符设备结构体的辅助队列是否为满，如果满了会阻塞进程，没有满就会从辅助队列读数据put_fs_char到用户空间，而读块设备的时候，read系统调用底层实现函数是blk_read，blk_read首先使用bread获取读数据的内核缓冲块，bread函数首先使用getblk函数获取一个内核缓冲块，这个内核缓冲块要么是一个空闲缓冲块，要么就是以前加载的文件指针所在的缓冲块，然后bread判断这个缓冲块是否有效，如果是空缓冲块或者数据被更改导致缓冲块无效，bread会调用ll_rw_blk函数从磁盘中加载文件指针所在的磁盘快到内核缓冲块，ll_rw_blk会调用磁盘读中断并阻塞进程，然后磁盘控制器会加载磁盘块数据到内核缓冲区，磁盘读中断完成之后，磁盘触发读写完成中断，这个中断会唤醒中断在块设备读队列上的阻塞进程。当进程被唤醒之后，返回ll_rw_blk和bread函数，bread函数返回缓冲块地址，进程从bread返回之后会把用户空间数据拷贝到内核缓冲区的位置；写字符设备的时候，进程write系统调用底层实现函数是tty_write，tty_write检查设备写缓冲队列是否为满，满就阻塞，不满就写入数据，然后调用设备结构体中的写函数指针完成设备写（控制台设备写函数是con_write)，而写块设备的时候，write底层实现函数是blk_write，blk_write函数调用bread函数找到或者创建文件指针对应的内核缓冲块，这个过程可能阻塞，然后将用户空间的数据get_fs_char写入到内核缓冲块，这个过程和字符设备写不同，字符设备写会直接调用写字符设备程序将缓冲的数据直接写入到字符设备，而在块设备写的时候只是写到缓冲区中，而没有进一步写入到块设备中，写到块设备中的操作要到后面释放块设备的时候完成，比如sys_umount，会将缓冲区的所有相关块设备的缓冲块调用ll_rw_blk写入到块设备（文件系统释放文件的时候可以使用fclose函数将文件相关缓冲块写入到块设备）】。

字符设备和块设备驱动的异同可以见下图

![未命名文件 (1)](实验\操作系统实验\实验8 虚拟文件系统的实现\未命名文件 (1).png)



## 操作系统实验总结

### 进程管理

实验3-进程状态跟踪

实验4-基于栈的内核级线程的切换

实验5-信号量的实现

1. 进程控制

   | fork                   | 创建一个新进程                                       |
   | ---------------------- | ---------------------------------------------------- |
   | clone                  | 按指定条件创建子进程                                 |
   | execve                 | 运行可执行文件                                       |
   | exit                   | 中止进程                                             |
   | _exit                  | 立即中止当前进程                                     |
   | getdtablesize          | 进程所能打开的最大文件数                             |
   | getpgid                | 获取指定进程组标识号                                 |
   | setpgid                | 设置指定进程组标志号                                 |
   | getpgrp                | 获取当前进程组标识号                                 |
   | setpgrp                | 设置当前进程组标志号                                 |
   | getpid                 | 获取进程标识号                                       |
   | getppid                | 获取父进程标识号                                     |
   | getpriority            | 获取调度优先级                                       |
   | setpriority            | 设置调度优先级                                       |
   | modify_ldt             | 读写进程的本地描述表                                 |
   | nanosleep              | 使进程睡眠指定的时间                                 |
   | nice                   | 改变分时进程的优先级                                 |
   | pause                  | 挂起进程，等待信号                                   |
   | personality            | 设置进程运行域                                       |
   | prctl                  | 对进程进行特定操作                                   |
   | ptrace                 | 进程跟踪                                             |
   | sched_get_priority_max | 取得静态优先级的上限                                 |
   | sched_get_priority_min | 取得静态优先级的下限                                 |
   | sched_getparam         | 取得进程的调度参数                                   |
   | sched_getscheduler     | 取得指定进程的调度策略                               |
   | sched_rr_get_interval  | 取得按RR算法调度的实时进程的时间片长度               |
   | sched_setparam         | 设置进程的调度参数                                   |
   | sched_setscheduler     | 设置指定进程的调度策略和参数                         |
   | sched_yield            | 进程主动让出处理器,并将自己等候调度队列队尾          |
   | vfork                  | 创建一个子进程，以供执行新程序，常与execve等同时使用 |
   | wait                   | 等待子进程终止                                       |
   | wait3                  | 参见wait                                             |
   | waitpid                | 等待指定子进程终止                                   |
   | wait4                  | 参见waitpid                                          |
   | capget                 | 获取进程权限                                         |
   | capset                 | 设置进程权限                                         |
   | getsid                 | 获取会晤标识号                                       |
   | setsid                 | 设置会晤标识号                                       |

2. 进程通信、传递数据和同步

   | ipc  | 进程间通信总控制调用 |
   | ---- | -------------------- |
   |      |                      |

   - 信号

     | sigaction   | 设置对指定信号的处理方法                               |
     | ----------- | ------------------------------------------------------ |
     | sigprocmask | 根据参数对信号集中的信号执行阻塞/解除阻塞等操作        |
     | sigpending  | 为指定的被阻塞信号设置队列                             |
     | sigsuspend  | 挂起进程等待特定信号                                   |
     | signal      | 参见signal                                             |
     | kill        | 向进程或进程组发信号                                   |
     | *sigblock   | 向被阻塞信号掩码中添加信号,已被sigprocmask代替         |
     | *siggetmask | 取得现有阻塞信号掩码,已被sigprocmask代替               |
     | *sigsetmask | 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替 |
     | *sigmask    | 将给定的信号转化为掩码,已被sigprocmask代替             |
     | *sigpause   | 作用同sigsuspend,已被sigsuspend代替                    |
     | sigvec      | 为兼容BSD而设的信号处理函数,作用类似sigaction          |
     | ssetmask    | ANSI C的信号处理函数,作用类似sigaction                 |

   - 消息队列

     | msgctl | 消息控制操作 |
     | ------ | ------------ |
     | msgget | 获取消息队列 |
     | msgsnd | 发消息       |
     | msgrcv | 取消息       |

   - 管道

     | pipe                            | 无名管道 |
     | ------------------------------- | -------- |
     | read/piperead, write/pipe_write | 有名管道 |

   - 信号量

     | semctl | 信号量控制     |
     | ------ | -------------- |
     | semget | 获取一组信号量 |
     | semop  | 信号量操作     |

   - 共享内存

     | shmctl | 控制共享内存 |
     | ------ | ------------ |
     | shmget | 获取共享内存 |
     | shmat  | 连接共享内存 |
     | shmdt  | 拆卸共享内存 |

### 内存管理

实验6-共享内存的实现

| brk         | 改变数据段空间的分配         |
| ----------- | ---------------------------- |
| sbrk        | 参见brk                      |
| mlock       | 内存页面加锁                 |
| munlock     | 内存页面解锁                 |
| mlockall    | 调用进程所有内存页面加锁     |
| munlockall  | 调用进程所有内存页面解锁     |
| mmap        | 映射虚拟内存页               |
| munmap      | 去除内存页映射               |
| mremap      | 重新映射虚拟内存地址         |
| msync       | 将映射内存中的数据写回磁盘   |
| mprotect    | 设置内存映像保护             |
| getpagesize | 获取页面大小                 |
| sync        | 将内存缓冲区数据写回硬盘     |
| cacheflush  | 将指定缓冲区中的内容写回磁盘 |

### 设备管理

实验7-终端设备的控制

- 字符设备管理-控制台管理（涉及硬件鼠标、键盘、显示器）

  设备结构体包括termios结构用于存储输出到控制台(显示器)的参数，write函数指针用于保存写控制台设备的写函数，对于控制台管理，写函数时con_write函数写到显示器内存（con_write将控制台设备结构体的写缓冲队列的数据转移到控制台的显卡中（这是一段操作系统内存），包括写缓冲队列，读缓冲队列和辅助队列（循环队列）。

  用户程序scanf读数据时，调用read系统调用，read系统调用调用tty_read函数从键盘设备结构体的读缓冲队列读数据，如果发现缓冲队列为空就阻塞到键盘辅助缓冲队列；按下键盘发生键盘中断，键盘扫描码区分使用的键盘中断处理子函数，一般函数是键盘中断函数从键盘端口获取扫描码，键盘中断处理子函数将扫描码用扫描码映射表将扫描码映射到对应的字符之后放入键盘设备结构体的读缓冲队列，然后调用copy_to_cooked函数把键盘读缓冲队列的数据经过规范化转义之后放入辅助队列，如果设置了回显，则还会把这个字符写入到控制台写缓冲队列，然后调用con_write()函数把控制台缓冲队列的数据写到显卡内存中，之后wake_up唤醒阻塞在键盘辅助队列上的进程；当阻塞在键盘辅助队列上的进程被唤醒并重新执行后，进程从辅助缓冲队列读取字符并使用put_fs_char将这个字符写入到用户空间的变量中。

  用户程序printf写控制台的时候，调用write系统调用，write系统调用调用tty_write内核函数，tty_write内核函数检查控制台设备结构体的写缓冲队列是否为满，如果满了就阻塞到控制台写缓冲队列，否则将用户空间的字符串get_fs_char拷贝到控制台设备写缓冲队列，然后调用控制台写函数con_write(控制台write函数指针保存con_write函数地址)将数据写出到控制台。

- 字符设备管理-网络设备管理（涉及硬件网卡）

  计算机网络以来网络管理实现，底层调用的是Linux网络管理提供的socket系统调用。

  1. 主机网络控制

     | getdomainname | 取域名         |
     | ------------- | -------------- |
     | setdomainname | 设置域名       |
     | gethostid     | 获取主机标识号 |
     | sethostid     | 设置主机标识号 |
     | gethostname   | 获取本主机名称 |
     | sethostname   | 设置主机名称   |

  2. Socket控制

  - | socketcall  | socket系统调用             |
    | ----------- | -------------------------- |
    | socket      | 建立socket                 |
    | bind        | 绑定socket到端口           |
    | connect     | 连接远程主机               |
    | accept      | 响应socket连接请求         |
    | send        | 通过socket发送信息         |
    | sendto      | 发送UDP信息                |
    | sendmsg     | 参见send                   |
    | recv        | 通过socket接收信息         |
    | recvfrom    | 接收UDP信息                |
    | recvmsg     | 参见recv                   |
    | listen      | 监听socket端口             |
    | select      | 对多路同步I/O进行轮询      |
    | shutdown    | 关闭socket上的连接         |
    | getsockname | 取得本地socket名字         |
    | getpeername | 获取通信对方的socket名字   |
    | getsockopt  | 取端口设置                 |
    | setsockopt  | 设置端口参数               |
    | sendfile    | 在文件或端口间传输数据     |
    | socketpair  | 创建一对已联接的无名socket |

- 块设备管理-磁盘管理（涉及硬件磁盘）

  磁盘管理没有提供太多系统调用，他大多是内核函数，被文件系统调用构成了文件熊的底层驱动磁盘的模块。数据库系统是基于文件管理提供的系统调用来实现的。数据库文件就是一个普通的文件，通过文件的相关系统调用访问。

  1. 磁盘管理函数

     bread函数/ll_rw_blk等读写磁盘的驱动程序，被文件系统调用来访问磁盘。

#### 文件管理(磁盘块设备; 数据库系统/索引和文件存储)

实验8-虚拟文件系统的实现

- Linux文件系统调用

  Linux文件系统时Linux提供的数据持久化技术。Linux操作系统能提供的数据存储方式有两种，一种是内存管理将数据保存在内存中，随着断电会消失；一种是将数据保存到磁盘文件中，可以实现数据的长期保存，断电不会消失。MySQL等基于磁盘的数据库和Redis等基于内存的数据库的持久化技术都是文件管理系统提供的文件系统调用来操作的。

  1. 文件读写操作

     | fcntl     | 文件控制                     |
     | --------- | ---------------------------- |
     | open      | 打开文件                     |
     | creat     | 创建新文件                   |
     | close     | 关闭文件描述字               |
     | read      | 读文件                       |
     | write     | 写文件                       |
     | readv     | 从文件读入数据到缓冲数组中   |
     | writev    | 将缓冲数组里的数据写入文件   |
     | pread     | 对文件随机读                 |
     | pwrite    | 对文件随机写                 |
     | lseek     | 移动文件指针                 |
     | _llseek   | 在64位地址空间里移动文件指针 |
     | dup       | 复制已打开的文件描述字       |
     | dup2      | 按指定条件复制文件描述字     |
     | flock     | 文件加/解锁                  |
     | poll      | I/O多路转换                  |
     | truncate  | 截断文件                     |
     | ftruncate | 参见truncate                 |
     | umask     | 设置文件权限掩码             |
     | fsync     | 把文件在内存中的部分写回磁盘 |

  2. 文件系统操作

     | access   | 确定文件的可存取性     |
     | -------- | ---------------------- |
     | chdir    | 改变当前工作目录       |
     | fchdir   | 参见chdir              |
     | chmod    | 改变文件方式           |
     | fchmod   | 参见chmod              |
     | chown    | 改变文件的属主或用户组 |
     | fchown   | 参见chown              |
     | lchown   | 参见chown              |
     | chroot   | 改变根目录             |
     | stat     | 取文件状态信息         |
     | lstat    | 参见stat               |
     | fstat    | 参见stat               |
     | statfs   | 取文件系统信息         |
     | fstatfs  | 参见statfs             |
     | readdir  | 读取目录项             |
     | getdents | 读取目录项             |
     | mkdir    | 创建目录               |
     | mknod    | 创建索引节点           |
     | rmdir    | 删除目录               |
     | rename   | 文件改名               |
     | link     | 创建链接               |
     | symlink  | 创建符号链接           |
     | unlink   | 删除链接               |
     | readlink | 读符号链接的值         |
     | mount    | 安装文件系统           |
     | umount   | 卸下文件系统           |
     | ustat    | 取文件系统信息         |
     | utime    | 改变文件的访问修改时间 |
     | utimes   | 参见utime              |
     | quotactl | 控制磁盘配额           |

- C语言文件系统操作函数

  [C library function - fwrite() (tutorialspoint.com)](https://www.tutorialspoint.com/c_standard_library/c_function_fwrite.htm)

  [(108条消息) 【C 语言】文件操作 ( fwrite 函数 )_韩曙亮的博客-CSDN博客_fwrite](https://blog.csdn.net/shulianghan/article/details/117376038)

  [(108条消息) C语言文件操作详解_miqi1227的博客-CSDN博客_c语言文件操作](https://blog.csdn.net/u010994304/article/details/50265681)

  [(108条消息) C语言文件操作（含详细步骤）_zjruiiiiii的博客-CSDN博客_c文件操作](https://blog.csdn.net/ZJRUIII/article/details/120552735)

  [C 库函数 – fscanf() | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-function-fscanf.html)

  C语言文件操作函数是封装Linux操作系统文件系统调用API完成的函数。可以通过C语言文件操作函数实现文件保存和数据持久化技术。

  Linux把输入输出设备都当成文件来处理

  C语言文件结构体FILE定义的内容

  ```
  //Linux0.11 使用的stdio.h
  //其中定义了文件结构体FILE和文件操作函数
  
  #ifndef _STDIO_H
  #define _STDIO_H
  
  /*			s t d i o
   *
   *		Author: C. E. Chew
   *		Date:   August 1989
   *
   * (C) Copyright C E Chew
   *
   * Feel free to copy, use and distribute this software provided:
   *
   *	1. you do not pretend that you wrote it
   *	2. you leave this copyright notice intact.
   *
   * Definitions and user interface for the stream io package.
   *
   * Patchlevel 2.0
   *
   * Edit History:
   */
  
  /* Site specific definitions */
  /*@*/
  #ifndef NULL
  # define NULL	((void *)0)
  #endif
  #define _STDIO_UCHAR_		0
  #define _STDIO_VA_LIST_		char *
  #define _STDIO_SIZE_T_		unsigned int	  /* type returned by sizeof */
  #define _STDIO_USIZE_T_		unsigned int
  /*=*/
  
  /* Definitions based on ANSI compiler */
  #ifdef		__STDC__
  # ifndef	_STDIO_P_
  #   define	_STDIO_P_(x)		x
  # endif
  # ifndef	_STDIO_VA_
  #   define	_STDIO_VA_		, ...
  # endif
  # ifndef	_STDIO_UCHAR_
  #   define	_STDIO_UCHAR_		0
  # endif
  #else
  # ifndef	_STDIO_P_
  #   define	_STDIO_P_(x)		()
  # endif
  # ifndef	_STDIO_VA_
  #   define	_STDIO_VA_
  # endif
  # ifndef	_STDIO_UCHAR_
  #   define	_STDIO_UCHAR_		(0xff)
  # endif
  #endif
  
  #ifndef		_STDIO_VA_LIST_
  #  define	_STDIO_VA_LIST_		void *
  #endif
  
  #ifndef		_STDIO_SIZE_T_
  #  define	_STDIO_SIZE_T_		unsigned int
  #endif
  
  #ifndef		_STDIO_USIZE_T_
  #  define	_STDIO_USIZE_T_		unsigned int
  #endif
  
  /* ANSI Definitions */
  #define BUFSIZ 1024			/* default buffer size */
  
  #ifndef	NULL
  # define NULL		((void *) 0)	/* null pointer */
  #endif
  
  #define EOF		(-1)		/* eof flag */
  #define FOPEN_MAX	16		/* minimum guarantee */
  #define FILENAME_MAX	127		/* maximum length of file name */
  
  #define SEEK_SET	0		/* seek from beginning */
  #define SEEK_CUR	1		/* seek from here */
  #define SEEK_END	2		/* seek from end */
  
  #define TMP_MAX		(0xffff)	/* maximum number of temporaries */
  
  #define L_tmpnam	(5 + 8 + 4 + 1 + 1) /* length of temporary file name */
  
  #ifndef _FPOS_T
  # define _FPOS_T
    typedef long fpos_t;			/* stream positioning */
  #endif
  
  #ifndef	_SIZE_T
  # define _SIZE_T
    typedef _STDIO_SIZE_T_ size_t;	/* sizeof type */
  #endif
  
  #define _IOFBF		000000		/* fully buffered io */
  #define _IOREAD		000001		/* opened for reading */
  #define _IOWRITE	000002		/* opened for writing */
  #define _IONBF		000004		/* unbuffered */
  #define _IOMYBUF	000010		/* allocated buffer */
  #define _IOPOOLBUF	000020		/* buffer belongs to pool */
  #define _IOEOF		000040		/* eof encountered */
  #define _IOERR		000100		/* error encountered */
  #define _IOSTRING	000200		/* strings */
  #define _IOLBF		000400		/* line buffered */
  #define _IORW		001000		/* opened for reading and writing */
  #define _IOAPPEND	002000		/* append mode */
  #define _IOINSERT	004000		/* insert into __iop chain */
  #define _IOSTDX		030000		/* standard stream */
  
  #define _IOSTDIN	010000		/* stdin indication */
  #define _IOSTDOUT	020000		/* stdout indication */
  #define _IOSTDERR	030000		/* stderr indication */
  
  #define _IORETAIN	(_IOSTDX | _IOINSERT)	/* flags to be retained */
  
  /* Implementation Definitions */
  
  typedef char __stdiobuf_t;		/* stdio buffer type */
  typedef _STDIO_USIZE_T_ __stdiosize_t;	/* unsigned size_t */
  
  typedef struct __iobuf {
    __stdiobuf_t *__rptr;			/* pointer into read buffer */
    __stdiobuf_t *__rend;			/* point at end of read buffer */
    __stdiobuf_t *__wptr;			/* pointer into write buffer */
    __stdiobuf_t *__wend;			/* point at end of write buffer */
    __stdiobuf_t *__base;			/* base of buffer */
    __stdiosize_t __bufsiz;		/* size of buffer */
    short __flag;				/* flags */
    char __file;				/* channel number */
    __stdiobuf_t __buf;			/* small buffer */
    int (*__filbuf) _STDIO_P_((struct __iobuf *));      /* fill input buffer */
    int (*__flsbuf) _STDIO_P_((int, struct __iobuf *)); /* flush output buffer */
    int (*__flush) _STDIO_P_((struct __iobuf *));	/* flush buffer */
    struct __iobuf *__next;		/* next in chain */
  } FILE;
  
  extern FILE __stdin;			/* stdin */
  extern FILE __stdout;			/* stdout */
  extern FILE __stderr;			/* stderr */
  
  #define stdin		(&__stdin)
  #define stdout		(&__stdout)
  #define stderr		(&__stderr)
  
  /* ANSI Stdio Requirements */
  
  int	getc		_STDIO_P_((FILE *));
  #if	_STDIO_UCHAR_
  # define getc(p)	((p)->__rptr>=(p)->__rend\
  			 ?(*(p)->__filbuf)(p)\
  			 :(int)(*(p)->__rptr++&_STDIO_UCHAR_))
  #else
  # define getc(p)	((p)->__rptr>=(p)->__rend\
  			 ?(*(p)->__filbuf)(p)\
  			 :(int)((unsigned char)(*(p)->__rptr++)))
  #endif
  
  int	getchar		_STDIO_P_((void));
  #define getchar()	getc(stdin)
  
  int	putc		_STDIO_P_((int, FILE *));
  #if	_STDIO_UCHAR_
  # define putc(x,p)	((p)->__wptr>=(p)->__wend\
                           ?(*(p)->__flsbuf)((x),(p))\
  	                 :(int)(*(p)->__wptr++=(x)&_STDIO_UCHAR_))
  #else
  # define putc(x,p)	((p)->__wptr>=(p)->__wend\
                           ?(*(p)->__flsbuf)((x),(p))\
  	                 :(int)((unsigned char)(*(p)->__wptr++=(x))))
  #endif
  
  int	putchar		_STDIO_P_((int));
  #define	putchar(x)	putc(x,stdout)
  
  int	feof		_STDIO_P_((FILE *));
  #define feof(p)		(((p)->__flag&_IOEOF)!=0)
  
  int	ferror		_STDIO_P_((FILE *));
  #define ferror(p)	(((p)->__flag&_IOERR)!=0)
  
  void	clearerr	_STDIO_P_((FILE *));
  #define clearerr(p)	((p)->__flag&=~(_IOEOF|_IOERR))
  
  FILE 	*fopen		_STDIO_P_((const char *, const char *));
  FILE	*freopen	_STDIO_P_((const char *, const char *, FILE *));
  int	fflush		_STDIO_P_((FILE *));
  int	fclose		_STDIO_P_((FILE *));
  
  int	fgetpos		_STDIO_P_((FILE *, fpos_t *));
  int	fsetpos		_STDIO_P_((FILE *, fpos_t *));
  long	ftell		_STDIO_P_((FILE *));
  int	fseek		_STDIO_P_((FILE *, long, int));
  void	rewind		_STDIO_P_((FILE *));
  
  int	fgetc		_STDIO_P_((FILE *));
  int	fputc		_STDIO_P_((int, FILE *));
  __stdiosize_t	fread	_STDIO_P_((void *, __stdiosize_t,
  				   __stdiosize_t, FILE *));
  __stdiosize_t	fwrite	_STDIO_P_((void *, __stdiosize_t,
  				   __stdiosize_t, FILE *));
  
  int	getw		_STDIO_P_((FILE *));
  int	putw		_STDIO_P_((int, FILE *));
  char	*gets		_STDIO_P_((char *));
  char	*fgets		_STDIO_P_((char *, int, FILE *));
  int	puts		_STDIO_P_((const char *));
  int	fputs		_STDIO_P_((const char *, FILE *));
  
  int	ungetc		_STDIO_P_((int, FILE *));
  
  int	printf		_STDIO_P_((const char * _STDIO_VA_));
  int	fprintf		_STDIO_P_((FILE *, const char * _STDIO_VA_));
  int	sprintf		_STDIO_P_((char *, const char * _STDIO_VA_));
  int	vprintf		_STDIO_P_((const char *, _STDIO_VA_LIST_));
  int	vfprintf	_STDIO_P_((FILE *, const char *, _STDIO_VA_LIST_));
  int	vsprintf	_STDIO_P_((char *, const char *, _STDIO_VA_LIST_));
  int	scanf		_STDIO_P_((const char * _STDIO_VA_));
  int	fscanf		_STDIO_P_((FILE *, const char * _STDIO_VA_));
  int	sscanf		_STDIO_P_((const char *, const char * _STDIO_VA_));
  
  void	setbuf		_STDIO_P_((FILE *, char *));
  int	setvbuf		_STDIO_P_((FILE *, char *, int, __stdiosize_t));
  
  int	rename		_STDIO_P_((const char *, const char *));
  int	remove		_STDIO_P_((const char *));
  
  void	perror		_STDIO_P_((const char *));
  
  char *	tmpnam		_STDIO_P_((char *));
  FILE *	tmpfile		_STDIO_P_((void));
  
  /* Posix Definitions */
  int	unlink		_STDIO_P_((const char *));
  #define remove(x)	unlink((x))
  
  #define L_ctermid	9
  char *	ctermid		_STDIO_P_((char *s));
  
  #define L_cuserid	9
  char *	cuserid		_STDIO_P_((char *s));
  
  FILE	*fdopen		_STDIO_P_((int, const char *));
  
  int	fileno		_STDIO_P_((FILE *));
  #define fileno(p)	((p)->__file)
  
  #undef	_STDIO_P_
  #undef	_STDIO_VA_
  #undef	_STDIO_VA_LIST_
  /*ndef	_STDIO_UCHAR_*/
  #undef	_STDIO_SIZE_T_
  #undef	_STDIO_USIZE_T_
  #endif
  ```

  | 函数原型                                                     | 参数说明和函数作用                                           |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | FILE* fopen(char* pname, char *mode)                         | 打开文件，传递文件名和打开方式（只读、只写、可读写，还有一个概念是访问权限，这是文件inode节点保存的） |
  | int fclose(FILE* fp)                                         | 关闭文件，传递参数要关闭的文件文件指针                       |
  | int fgetc(FILE* fp)                                          | 从文件指针fp中读取一个字符（文件指针fp中有一个变量f_pos指向当前文件读写位置，这个f_pos也是lseek移动的位置，lseek会使用的三个位置变量是文件起始地址，文件结束地址和当前位置） |
  | int fputc(int ch, FILE* fp)                                  | 将字符写入文件                                               |
  | char* fgets(char* str, int n, FILE *fp)                      | 从文件指针fp中读取n-1个字符并放到用户变量str中，并在str中添加'\0'字符代表字符串结束，返回str首地址 |
  | int fputs(char* str, FILE* fp)                               | 将str字符串除去'\0'字符后写入文件指针fp，返回写入成功字符个数 |
  | int fscanf(FILE* fp, const char* format, arg_list)           | 类似scanf，从文件中读格式化数据                              |
  | int fprintf(FILE* fp, char* format, arg_list)                | 类似printf，往文件写格式化数据                               |
  | int fread(void* buff, unsigned size, unsigned elem, FILE* fp) | 从文件指针fp中读取size*elem个字符到buff数据指针中            |
  | int fwite(void* buff, unsigned size, unsigned elem, FILE* fp) | 将数据指针buff的size*elem个字符输出到文件，返回成功个数      |
  | int getw(FILE* fp)                                           | 从文件指针fp中读一个整数                                     |
  | int putw(int n, FILE* fp)                                    | 写一个整数到文件指针fp中，返回写如的整数                     |
  | int feof(FILE* fp)                                           | 判断文件是否结束                                             |
  | int ferror(FILE* fp)                                         | 检查由fp指定的文件在读写啊时是否出错                         |
  | void clearerr(FILE* fp)                                      | 秦楚由fp指定文件的错误标志                                   |
  | long ftell(FILE* fp)                                         | 取得文件读写位置，用和文件开头偏移量表示                     |
  | void rewind(FILE* fp)                                        | 重置文件读写指针到文件开头位置                               |
  | int fseek(FILE* fp, long offset, int base)                   | 使文件指针fp的读写位置移动到base+offset处，返回移动后的读写位置 |
  | void exit(int status)                                        | 进程退出程序，在其中会将缓冲区数据写出到磁盘文件并且关闭文件 |
  | int feof(FILE* fp)                                           | 判断文件是否结束。                                           |

Linux文件系统调用实现：

##### 文件创建/打开/关闭系统调用sys_create/sys_open/sys_close

```c
/*
 *  linux/fs/open.c
 *
 *  (C) 1991  Linus Torvalds
 */

/* #include <string.h> */
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <utime.h>
#include <sys/stat.h>

#include <linux/sched.h>
#include <linux/tty.h>
#include <linux/kernel.h>
#include <asm/segment.h>

int sys_ustat(int dev, struct ustat * ubuf)
{
	return -ENOSYS;
}

int sys_utime(char * filename, struct utimbuf * times)
{
	struct m_inode * inode;
	long actime,modtime;

	if (!(inode=namei(filename)))
		return -ENOENT;
	if (times) {
		actime = get_fs_long((unsigned long *) &times->actime);
		modtime = get_fs_long((unsigned long *) &times->modtime);
	} else
		actime = modtime = CURRENT_TIME;
	inode->i_atime = actime;
	inode->i_mtime = modtime;
	inode->i_dirt = 1;
	iput(inode);
	return 0;
}

/*
 * XXX should we use the real or effective uid?  BSD uses the real uid,
 * so as to make this call useful to setuid programs.
 */
int sys_access(const char * filename,int mode)
{
	struct m_inode * inode;
	int res, i_mode;

	mode &= 0007;
	if (!(inode=namei(filename)))
		return -EACCES;
	i_mode = res = inode->i_mode & 0777;
	iput(inode);
	if (current->uid == inode->i_uid)
		res >>= 6;
	else if (current->gid == inode->i_gid)
		res >>= 6;
	if ((res & 0007 & mode) == mode)
		return 0;
	/*
	 * XXX we are doing this test last because we really should be
	 * swapping the effective with the real user id (temporarily),
	 * and then calling suser() routine.  If we do call the
	 * suser() routine, it needs to be called last. 
	 */
	if ((!current->uid) &&
	    (!(mode & 1) || (i_mode & 0111)))
		return 0;
	return -EACCES;
}

int sys_chdir(const char * filename)
{
	struct m_inode * inode;

	if (!(inode = namei(filename)))
		return -ENOENT;
	if (!S_ISDIR(inode->i_mode)) {
		iput(inode);
		return -ENOTDIR;
	}
	iput(current->pwd);
	current->pwd = inode;
	return (0);
}

int sys_chroot(const char * filename)
{
	struct m_inode * inode;

	if (!(inode=namei(filename)))
		return -ENOENT;
	if (!S_ISDIR(inode->i_mode)) {
		iput(inode);
		return -ENOTDIR;
	}
	iput(current->root);
	current->root = inode;
	return (0);
}

int sys_chmod(const char * filename,int mode)
{
	struct m_inode * inode;

	if (!(inode=namei(filename)))
		return -ENOENT;
	if ((current->euid != inode->i_uid) && !suser()) {
		iput(inode);
		return -EACCES;
	}
	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
	inode->i_dirt = 1;
	iput(inode);
	return 0;
}

int sys_chown(const char * filename,int uid,int gid)
{
	struct m_inode * inode;

	if (!(inode=namei(filename)))
		return -ENOENT;
	if (!suser()) {
		iput(inode);
		return -EACCES;
	}
	inode->i_uid=uid;
	inode->i_gid=gid;
	inode->i_dirt=1;
	iput(inode);
	return 0;
}

/*
打开文件操作：从进程打开文件表中找到一个null的文件句柄fd，从系统打开表file_table找到一个空文件描述符，使用open_namei根据名字从磁盘中加载对应的inode节点到inode表inode_table中，如果不存在并且打开文件方式不是create，那么报错，否则创建一个新inode节点在磁盘中并且加载到inode_table，之后设置文件句柄指向文件描述符，设置文件描述符参数，将inode指针赋值给文件描述符。*/
int sys_open(const char * filename,int flag,int mode)
{
	struct m_inode * inode;
	struct file * f;
	int i,fd;

	mode &= 0777 & ~current->umask;
	for(fd=0 ; fd<NR_OPEN ; fd++)
		if (!current->filp[fd])
			break;
	if (fd>=NR_OPEN)
		return -EINVAL;
	current->close_on_exec &= ~(1<<fd);
	f=0+file_table;
	for (i=0 ; i<NR_FILE ; i++,f++)
		if (!f->f_count) break;
	if (i>=NR_FILE)
		return -EINVAL;
	(current->filp[fd]=f)->f_count++;
	if ((i=open_namei(filename,flag,mode,&inode))<0) {
		current->filp[fd]=NULL;
		f->f_count=0;
		return i;
	}
/* ttys are somewhat special (ttyxx major==4, tty major==5) */
	if (S_ISCHR(inode->i_mode)) {
		if (MAJOR(inode->i_zone[0])==4) {
			if (current->leader && current->tty<0) {
				current->tty = MINOR(inode->i_zone[0]);
				tty_table[current->tty].pgrp = current->pgrp;
			}
		} else if (MAJOR(inode->i_zone[0])==5)
			if (current->tty<0) {
				iput(inode);
				current->filp[fd]=NULL;
				f->f_count=0;
				return -EPERM;
			}
	}
/* Likewise with block-devices: check for floppy_change */
	if (S_ISBLK(inode->i_mode))
		check_disk_change(inode->i_zone[0]);
	f->f_mode = inode->i_mode;
	f->f_flags = flag;
	f->f_count = 1;
	f->f_inode = inode;
	f->f_pos = 0;
	return (fd);
}

//sys_create使用sys_open来创立文件
int sys_creat(const char * pathname, int mode)
{
	return sys_open(pathname, O_CREAT | O_TRUNC, mode);
}

/*
关闭文件：令文件句柄为null，减少对应文件描述符的文件句柄引用数量，如果引用数量为0，那么iput释放这个inode到磁盘。
*/
int sys_close(unsigned int fd)
{	
	struct file * filp;

	if (fd >= NR_OPEN)
		return -EINVAL;
	current->close_on_exec &= ~(1<<fd);
	if (!(filp = current->filp[fd]))
		return -EINVAL;
	current->filp[fd] = NULL;
	if (filp->f_count == 0)
		panic("Close: file count is 0");
	if (--filp->f_count)
		return (0);
	iput(filp->f_inode);
	return (0);
}
```



##### 读写文件和移动文件读写指针系统调用sys_read/sys_write/sys_lseek的实现

**fs/read_write.c**实现了sys_read/sys_write/sys_lseek，对于sys_read/sys_write而言，计算机把所有可以被读写的设备都当成文件来处理，所以sys_read/sys_write是一个顶层函数，具体读取文件的操作会根据文件类型i_node->i_mode来具体调用读写函数。

```c
/*
 *  linux/fs/read_write.c
 *
 *  (C) 1991  Linus Torvalds
 */

#include <sys/stat.h>
#include <errno.h>
#include <sys/types.h>

#include <linux/kernel.h>
#include <linux/sched.h>
#include <asm/segment.h>

extern int rw_char(int rw,int dev, char * buf, int count, off_t * pos);
extern int read_pipe(struct m_inode * inode, char * buf, int count);
extern int write_pipe(struct m_inode * inode, char * buf, int count);
extern int block_read(int dev, off_t * pos, char * buf, int count);
extern int block_write(int dev, off_t * pos, char * buf, int count);
extern int file_read(struct m_inode * inode, struct file * filp,
		char * buf, int count);
extern int file_write(struct m_inode * inode, struct file * filp,
		char * buf, int count);
		
extern int proc_read(int dev,char* buf,int count,unsigned long *pos);

/*
移动文件读写指针系统调用传入参数：文件句柄fd，相对基准位置origin的偏移位置offset。origin有三种类型,SEEK_SET=0代表文件开头，SEEK_CUR=1代表当前文件读写指针位置，SEEK_END=2代表文件尾部，文件尾部可以通过FILE->f_inode->i_size从文件inode结构体获得文件总的size大小得到。
lseek根据origin和offset获取移动的文件指针，然后赋值到系统打开表文件句柄所对应的文件描述符项的文件读写指针FILE->f_pos，最后返回新的读写指针FILE->f-pos。
*/
int sys_lseek(unsigned int fd,off_t offset, int origin)
{
	struct file * file;
	int tmp;

	if (fd >= NR_OPEN || !(file=current->filp[fd]) || !(file->f_inode)
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
		return -EBADF;
	if (file->f_inode->i_pipe)
		return -ESPIPE;
	switch (origin) {
		case 0:
			if (offset<0) return -EINVAL;
			file->f_pos=offset;
			break;
		case 1:
			if (file->f_pos+offset<0) return -EINVAL;
			file->f_pos += offset;
			break;
		case 2:
			if ((tmp=file->f_inode->i_size+offset) < 0)
				return -EINVAL;
			file->f_pos = tmp;
			break;
		default:
			return -EINVAL;
	}
	return file->f_pos;
}

/*
sys_read根据FILE->f_inode->i_mode中文件类型来选择对应的读写函数读写对应的设备
传入的参数是文件句柄fd，读入到用户缓冲区的指针buf，读入的字符个数，在调用对应的读写函数的时候要首先verify_area检查分配的线性空间是否可读，如果存在不可读的用户内存就要write_verify写时复制
*/
int sys_read(unsigned int fd,char * buf,int count)
{
	struct file * file;
	struct m_inode * inode;

	if (fd>=NR_OPEN || count<0 || !(file=current->filp[fd]))
		return -EINVAL;
	if (!count)
		return 0;
	verify_area(buf,count);
	inode = file->f_inode;
	if (inode->i_pipe)
		return (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;
	if (S_ISCHR(inode->i_mode))
		return rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);
	if (S_ISBLK(inode->i_mode))
		return block_read(inode->i_zone[0],&file->f_pos,buf,count);
	if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {
		if (count+file->f_pos > inode->i_size)
			count = inode->i_size - file->f_pos;
		if (count<=0)
			return 0;
		return file_read(inode,file,buf,count);
	}
	if (S_ISPROC(inode->i_mode))
		return proc_read(inode->i_zone[0],&file->f_pos,buf,count);
		
	printk("(Read)inode->i_mode=%06o\n\r",inode->i_mode);
	return -EINVAL;
}

int sys_write(unsigned int fd,char * buf,int count)
{
	struct file * file;
	struct m_inode * inode;
	
	if (fd>=NR_OPEN || count <0 || !(file=current->filp[fd]))
		return -EINVAL;
	if (!count)
		return 0;
	inode=file->f_inode;
	if (inode->i_pipe)
		return (file->f_mode&2)?write_pipe(inode,buf,count):-EIO;
	if (S_ISCHR(inode->i_mode))
		return rw_char(WRITE,inode->i_zone[0],buf,count,&file->f_pos);
	if (S_ISBLK(inode->i_mode))
		return block_write(inode->i_zone[0],&file->f_pos,buf,count);
	if (S_ISREG(inode->i_mode))
		return file_write(inode,file,buf,count);
	printk("(Write)inode->i_mode=%06o\n\r",inode->i_mode);
	return -EINVAL;
}
```

###### sys_read/sys_write读写普通文件的底层读写磁盘的内核函数file_read/file_write的实现

实现了sys_read/sys_write读写普通文件的底层读写磁盘的内核函数file_read/file_write

**进程打开文件表/系统打开表/文件inode结构**

> 进程打开文件表在进程PCB中定义为FILE* filep[NR_OPEN]，其中NR_OPEN=20表示进程最多打开文件数。进程打开文件表在**include/linux/sched.c**中定义为进程PCB结构的变量。进程打开文件表中的文件描述符的指针指向系统打开文件表中的文件描述符表表项，系统打开文件表在**include/linux/fs.h**中定义为外部变量，在**fs/file_table.c**中实际定义为文件描述符数组struct file file_table[NR_FILE]。
>
> 在Linux操作系统启动的时候挂载磁盘，会加载磁盘超级块到超级块数组，加载磁盘i节点位图到缓冲块并且将缓冲块指针赋值给超级块的i节点位图表中，加载逻辑位图到缓冲块并且将缓冲块指针赋值给超级块的逻辑块位图指针中。
>
> 当打开文件的时候，会根据文件名映射到对应的inode节点并从磁盘中读取inode节点信息保存到磁盘中，从系统打开表中找到一个空表项将inode赋值进去，初始化f_pos读写指针，打开文件方式flags，文件句柄数1，然后从进程打开文件表中获取一个空文件句柄，将新建的文件描述符指针赋值给这个文件句柄。
>
> ```
> extern struct m_inode inode_table[NR_INODE]; //inode数组，在fs/inode.c中定义，最多32项，一个inode标记一个记录一个文件的
> 											 //信息，inode数组在Linux操作系统启动的时候创建
> extern struct file file_table[NR_FILE];		 //系统打开表，在fs/file_table.c中定义，最多64项
> extern struct super_block super_block[NR_SUPER];	//超级块数组，一个超级块定义了一个磁盘的信息，最多8项
> extern struct buffer_head * start_buffer;			//内核缓冲块开始的位置，由编译器设置
> ```
>
> ```c
> // include/linux/sched.c中定义了PCB结构包含打开文件表
> struct task_struct {
> /* these are hardcoded - don't touch */
> 	long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
> 	long counter;
> 	long priority;
> 	long signal;
> 	struct sigaction sigaction[32];
> 	long blocked;	/* bitmap of masked signals */
> /* various fields */
> 	int exit_code;
> 	unsigned long start_code,end_code,end_data,brk,start_stack;
> 	long pid,father,pgrp,session,leader;
> 	unsigned short uid,euid,suid;
> 	unsigned short gid,egid,sgid;
> 	long alarm;
> 	long utime,stime,cutime,cstime,start_time;
> 	unsigned short used_math;
> /* file system info */
> 	int tty;		/* -1 if no tty, so it must be signed */
> 	unsigned short umask;
> 	struct m_inode * pwd;
> 	struct m_inode * root;
> 	struct m_inode * executable;
> 	unsigned long close_on_exec;
> 	struct file * filp[NR_OPEN];
> /* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
> 	struct desc_struct ldt[3];
> /* tss for this task */
> 	struct tss_struct tss;
> };
> ```
>
> ```c
> // fs/file_table.c定义了系统打开表（一个文件描述符数组，NR_FILE=64是系统文件最多数目）
> struct file file_table[NR_FILE];
> ```
>
> ```c
> // include/linux/fs.h定义了文件描述符结构体，inode结构体
> /*
>  * This file has definitions for some important file table
>  * structures etc.
>  */
> 
> #ifndef _FS_H
> #define _FS_H
> 
> #include <sys/types.h>
> 
> /* devices are as follows: (same as minix, so we can use the minix
>  * file system. These are major numbers.)
>  *
>  * 0 - unused (nodev)
>  * 1 - /dev/mem
>  * 2 - /dev/fd
>  * 3 - /dev/hd
>  * 4 - /dev/ttyx
>  * 5 - /dev/tty
>  * 6 - /dev/lp
>  * 7 - unnamed pipes
>  */
> 
> #define IS_SEEKABLE(x) ((x)>=1 && (x)<=3)
> 
> #define READ 0
> #define WRITE 1
> #define READA 2		/* read-ahead - don't pause */
> #define WRITEA 3	/* "write-ahead" - silly, but somewhat useful */
> 
> void buffer_init(long buffer_end);
> 
> #define MAJOR(a) (((unsigned)(a))>>8)
> #define MINOR(a) ((a)&0xff)
> 
> #define NAME_LEN 14
> #define ROOT_INO 1
> 
> #define I_MAP_SLOTS 8
> #define Z_MAP_SLOTS 8
> #define SUPER_MAGIC 0x137F
> 
> #define NR_OPEN 20
> #define NR_INODE 32
> #define NR_FILE 64
> #define NR_SUPER 8
> #define NR_HASH 307
> #define NR_BUFFERS nr_buffers
> #define BLOCK_SIZE 1024
> #define BLOCK_SIZE_BITS 10
> #ifndef NULL
> #define NULL ((void *) 0)
> #endif
> 
> #define INODES_PER_BLOCK ((BLOCK_SIZE)/(sizeof (struct d_inode)))
> #define DIR_ENTRIES_PER_BLOCK ((BLOCK_SIZE)/(sizeof (struct dir_entry)))
> 
> #define PIPE_HEAD(inode) ((inode).i_zone[0])
> #define PIPE_TAIL(inode) ((inode).i_zone[1])
> #define PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&(PAGE_SIZE-1))
> #define PIPE_EMPTY(inode) (PIPE_HEAD(inode)==PIPE_TAIL(inode))
> #define PIPE_FULL(inode) (PIPE_SIZE(inode)==(PAGE_SIZE-1))
> #define INC_PIPE(head) \
> __asm__("incl %0\n\tandl $4095,%0"::"m" (head))
> 
> typedef char buffer_block[BLOCK_SIZE];	//一个缓冲块的大小是1K
> 
> //在Linux启动的时候，会在[start_buffer, 4M]的中间位置，从两端向中间依次分配内存一个buffer_head和buffer_block的内存用来存储buffer_head和buffer_block，知道中间的内存无法再分配。这样我们就构建了一个buffer_head双向循环队列（每个buffer_head的b_prev_free和b_next_free被设置）
> // 用来保存从磁盘中读取到的数据块，
> // 缓冲块可以缓冲i节点位图缓冲块，然后把i节点位图缓冲块赋值给超级块表的i节点位图表
> // 缓冲块可以缓冲逻辑块位图，然后把逻辑块位图赋值给超级块表的逻辑块位图表
> struct buffer_head {							//缓冲块头结构，用来管理缓冲块
> 	char * b_data;			/* pointer to data block (1024 bytes) */
>     											//记录缓冲块起始地址
> 	unsigned long b_blocknr;	/* block number */
>     											//缓冲块对应磁盘块逻辑块号
> 	unsigned short b_dev;		/* device (0 = free) */
>     											//缓冲块对应磁盘块的设备，用设备号标识，每个标识含义可以看上面
> 	unsigned char b_uptodate;					//更新标志
> 	unsigned char b_dirt;		/* 0-clean,1-dirty */
>     											//修改标志
> 	unsigned char b_count;		/* users using this block */
>     											//使用这个缓冲块的用户数
> 	unsigned char b_lock;		/* 0 - ok, 1 -locked */
>     											//锁标志
> 	struct task_struct * b_wait;				//等待这个缓冲块的用户进程
> 	struct buffer_head * b_prev;				//哈希链表使用的双向指针
> 	struct buffer_head * b_next;
> 	struct buffer_head * b_prev_free;			//组织缓冲头的循环链表结构
> 	struct buffer_head * b_next_free;
> };
> 
> //存储在磁盘的超级块数据结构，超级块保存磁盘信息
> struct d_super_block {
> 	unsigned short s_ninodes;		//inode数，保存在磁盘的文件个数
> 	unsigned short s_nzones;		//逻辑块数，磁盘一共多少逻辑块
> 	unsigned short s_imap_blocks;	//i节点位图占用的逻辑块数
> 	unsigned short s_zmap_blocks;	//逻辑块位图所占用的逻辑块数
> 	unsigned short s_firstdatazone;	//第一个数据块的逻辑块号
> 	unsigned short s_log_zone_size;	
> 	unsigned long s_max_size;		//一个文件最大字节数
> 	unsigned short s_magic;			//文件魔数
> };
> 
> //存储在内存的超级快数据结构
> //内存有一个超级块表
> struct super_block {
> 	unsigned short s_ninodes;
> 	unsigned short s_nzones;
> 	unsigned short s_imap_blocks;
> 	unsigned short s_zmap_blocks;
> 	unsigned short s_firstdatazone;
> 	unsigned short s_log_zone_size;
> 	unsigned long s_max_size;
> 	unsigned short s_magic;
> /* These are only in memory */
> 	struct buffer_head * s_imap[8];	//i节点位图保存在内存中的缓冲块指针，可以由8个i节点位图缓冲块
>     								//i节点位图的每一个比特位可以用来表明一个i节点是否有效，在磁盘中，磁盘被划分为6块
>     								//引导块：由BIOS加载的驱动读写磁盘的程序
>     								//超级块：记录磁盘信息
>     								//i节点位图：每个比特位标明i节点块中的一个i节点是否有效，是否被分配给一个文件
>     								//逻辑块位图：标明逻辑块是否被分配，主要是用来标明数据块是否被使用
>     								//i节点区：保存i节点
>     								//数据区：保存文件数据的区域，数据区的数据块号和逻辑块号不一样，数据块号是从
>     								//		 第一个数据块开始计数，而逻辑块号是从0开始计数，第一个数据块的逻辑块号被保存在
>     								//		 磁盘超级块中，并且被加载到内存超级块表中
> 	struct buffer_head * s_zmap[8];	//8个逻辑块位图 缓冲块。
> 	unsigned short s_dev;			//超级块所属的设备号
> 	struct m_inode * s_isup;		
> 	struct m_inode * s_imount;
> 	unsigned long s_time;			//修改时间
> 	struct task_struct * s_wait;	//等待磁盘的进程
> 	unsigned char s_lock;			//锁标志
> 	unsigned char s_rd_only;		//只读标志
> 	unsigned char s_dirt;			//修改标志
> };
> 
> 
> 
> //存储再磁盘上的inode结构
> struct d_inode {
> 	unsigned short i_mode;			//访问权限和类型
> 	unsigned short i_uid;			//创建用户
> 	unsigned long i_size;			//文件大小
> 	unsigned long i_time;			//修改时间
> 	unsigned char i_gid;			//创建用户的用户组
> 	unsigned char i_nlinks;			//硬连接数目，当这个为0时文件可以被删除（新建文件的时候可以被用于分配来新建文件）
> 	unsigned short i_zone[9];		//文件使用的数据块表，保存文件使用的数据块的逻辑块号，在MINIX1.0文件系统中，	
>     								//0-6这7个数组项是直接块号，也就是说文件小于7K，那么可以直接使用这7个盘块号访问到使用的
>     								//逻辑块，当文件大于7K，需要间接盘块号辅助来获取盘块号
> };
> 
> //存储在内存的inode结构，他会在内核中新建一个inode表，m_inode inode_table[NR_INODE]，这个inode表会在操作系统启动的时候初始化为磁盘上的文件inode，他会获取磁盘上文件inode信息放到m_inode中，同时增加一些项。
> //内存有一个inode表，在系统启动的时候和超级块表一起被初始化
> struct m_inode {
> 	unsigned short i_mode;
> 	unsigned short i_uid;
> 	unsigned long i_size;
> 	unsigned long i_mtime;
> 	unsigned char i_gid;
> 	unsigned char i_nlinks;
> 	unsigned short i_zone[9];
> /* these are in memory also */
> 	struct task_struct * i_wait;	//等待文件的进程
> 	unsigned long i_atime;			//最后访问时间
> 	unsigned long i_ctime;			//最后修改时间
> 	unsigned short i_dev;			//inode所在的设备（文件所在设备号）
> 	unsigned short i_num;			//inode节点号（inode所在磁盘的inode位图下标）
> 	unsigned short i_count;			//inode被使用的次数（文件被使用的次数）
> 	unsigned char i_lock;			//锁定标识（文件被锁定）
> 	unsigned char i_dirt;			//修改标志
> 	unsigned char i_pipe;			//管道文件标志
> 	unsigned char i_mount;			//安装标志
> 	unsigned char i_seek;			//lseek标志
> 	unsigned char i_update;			//更新标志
> };
> 
> //内存有一个打开文件表file_table
> struct file {
> 	unsigned short f_mode;			//打开文件方式（读写）
> 	unsigned short f_flags;			//打开文件标志（添加/覆盖/没有就创建等）
> 	unsigned short f_count;			//文件句柄数，文件句柄是进程打开文件时将文件对应的inode赋值系统打开表
>     								//file_table中的一个表项，然后把这个表项文件描述符赋值给进程代开文件表filp
>     								//的一个位置，这个位置下标就被称为文件句柄。current->filp[fd]可以获得打开文件表的文件
>     								//描述符指针
> 	struct m_inode * f_inode;		//文件描述符对应的文件inode指针
> 	off_t f_pos;					//本文件描述符对应的读写指针。一个文件可以被多个进程打开，每个进程打开就会在
>     								//系统打开表创建一个文件描述符, 当进程使用fork创建子进程的时候会复制打开文件表，
>     								//同时增加系统打开表的文件描述符的文件句柄数
> };
> 
> struct dir_entry {					//目录结构
> 	unsigned short inode;
> 	char name[NAME_LEN];
> };
> 
> extern struct m_inode inode_table[NR_INODE];
> extern struct file file_table[NR_FILE];
> extern struct super_block super_block[NR_SUPER];
> extern struct buffer_head * start_buffer;
> extern int nr_buffers;
> 
> extern void check_disk_change(int dev);
> extern int floppy_change(unsigned int nr);
> extern int ticks_to_floppy_on(unsigned int dev);
> extern void floppy_on(unsigned int dev);
> extern void floppy_off(unsigned int dev);
> extern void truncate(struct m_inode * inode);
> extern void sync_inodes(void);
> extern void wait_on(struct m_inode * inode);
> extern int bmap(struct m_inode * inode,int block);
> extern int create_block(struct m_inode * inode,int block);
> extern struct m_inode * namei(const char * pathname);
> extern int open_namei(const char * pathname, int flag, int mode,
> 	struct m_inode ** res_inode);
> extern void iput(struct m_inode * inode);
> extern struct m_inode * iget(int dev,int nr);
> extern struct m_inode * get_empty_inode(void);
> extern struct m_inode * get_pipe_inode(void);
> extern struct buffer_head * get_hash_table(int dev, int block);
> extern struct buffer_head * getblk(int dev, int block);
> extern void ll_rw_block(int rw, struct buffer_head * bh);
> extern void brelse(struct buffer_head * buf);
> extern struct buffer_head * bread(int dev,int block);
> extern void bread_page(unsigned long addr,int dev,int b[4]);
> extern struct buffer_head * breada(int dev,int block,...);
> extern int new_block(int dev);
> extern void free_block(int dev, int block);
> extern struct m_inode * new_inode(int dev);
> extern void free_inode(struct m_inode * inode);
> extern int sync_dev(int dev);
> extern struct super_block * get_super(int dev);
> extern int ROOT_DEV;
> 
> extern void mount_root(void);
> 
> #endif
> ```
>
> 

```c
/*
 *  linux/fs/file_dev.c
 *
 *  (C) 1991  Linus Torvalds
 */

#include <errno.h>
#include <fcntl.h>

#include <linux/sched.h>
#include <linux/kernel.h>
#include <asm/segment.h>

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))

//传入参数inode指针和FILE指针，从文件描述符FILE中获得文件读写指针，从inode中获得文件所在设备
//（设备号，文件读写指针）唯一标识磁盘中的一个位置
//file_read向（设备号，文件读写指针）位置写count个字节，返回实际写入的字节个数

int file_read(struct m_inode * inode, struct file * filp, char * buf, int count)
{
	int left,chars,nr;
	struct buffer_head * bh;

	if ((left=count)<=0)
		return 0;
	while (left) {
        //bmap根据文件数据块号获得文件数据块在磁盘上的逻辑块号，nr为读写指针所在的数据块块号
		if ((nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE))) {
            //bread从格局逻辑块号从设备中读取逻辑块到内核缓冲块中，内核缓冲块在内核缓冲区中
            //由Linux操作系统初始化的时候初始化，bh返回为要读的数据块所在缓冲块的缓冲头的地址
			if (!(bh=bread(inode->i_dev,nr)))
				break;
		} else
			bh = NULL;
        //nr获取读写指针在数据快的偏移，加上缓冲块的地址bh->data，得到读写指针在缓冲块的地址
        //从缓冲块的读写指针位置读取数据到用户空间put_fs_byte，并且修改inode修改时间
		nr = filp->f_pos % BLOCK_SIZE;
		chars = MIN( BLOCK_SIZE-nr , left );
		filp->f_pos += chars;
		left -= chars;
		if (bh) {
			char * p = nr + bh->b_data;
			while (chars-->0)
				put_fs_byte(*(p++),buf++);
			brelse(bh);
		} else {
			while (chars-->0)
				put_fs_byte(0,buf++);
		}
	}
	inode->i_atime = CURRENT_TIME;
	return (count-left)?(count-left):-ERROR;
}


//往读写指针位置除添加数据
int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
	off_t pos;
	int block,c;
	struct buffer_head * bh;
	char * p;
	int i=0;

/*
 * ok, append may not work when many processes are writing at the same time
 * but so what. That way leads to madness anyway.
 */
    
	if (filp->f_flags & O_APPEND)
		pos = inode->i_size;
	else
		pos = filp->f_pos;
	while (i<count) {
        //根据读写指针所在的数据块读取逻辑块，如果这个逻辑块没有分配给文件，那么分配一个数据块给文件，返回数据块号
        //接着使用这个数据块号读取磁盘的数据块到内核缓冲区，返回内核缓冲块头指针。
		if (!(block = create_block(inode,pos/BLOCK_SIZE)))
			break;
		if (!(bh=bread(inode->i_dev,block)))
			break;
        
        //计算读写指针在缓冲块的位置p，将用户缓冲数据写入到内核缓冲块中，并且设置缓冲块被修改标志，写完之后释放这个缓冲块
		c = pos % BLOCK_SIZE;
		p = c + bh->b_data;
		bh->b_dirt = 1;
		c = BLOCK_SIZE-c;
		if (c > count-i) c = count-i;
		pos += c;
		if (pos > inode->i_size) {
			inode->i_size = pos;
			inode->i_dirt = 1;
		}
		i += c;
		while (c-->0)
			*(p++) = get_fs_byte(buf++);
		brelse(bh);
	}
    
    //设置文件inode修改时间和使用时间，设置file文件描述符读写指针
	inode->i_mtime = CURRENT_TIME;
	if (!(filp->f_flags & O_APPEND)) {
		filp->f_pos = pos;
		inode->i_ctime = CURRENT_TIME;
	}
	return (i?i:-1);
}
```

###### 管理内核缓冲区的读写函数：bread(getblk)读磁盘块到缓冲块/brelse释放缓冲块/sync将inode节点和置修改标志的缓冲块写回磁盘**

> bread函数首先调用getblk函数分配缓冲块来读取磁盘缓冲块，getblk得到函数有两种情况，一种是磁盘块已经被分配了缓冲块，缓冲块中有一个块就是（设备号，逻辑块号）和我们想要的一样，另外一种情况是分配一个没有被其他程序占用的（没有被锁定lock标志的）、进程占用数为0的空闲缓冲块，getblk函数执行流程如下
>
> > ![Screenshot 2022-10-20 203350](D:\JavaBackend\实验\1 操作系统实验\实验8 虚拟文件系统的实现\Screenshot 2022-10-20 203350.png)
> >
> > getblk函数通过哈希链表寻找，如果发现一个设备号/逻辑块号等于需要的缓冲块直接返回；如果没有找到，就要分配一个空闲缓冲块，他会从空闲队列开始查找空闲链表，判断这个缓冲块是否被进程占用（锁标志），是否被修改过（修改标志），是否在高速缓冲中（中断造成其他进程获得这个缓冲块操作），如果没有通过检查，进程会挂起 等待回到getblk开头位置执行，如果通过检查，就将获得一个没有被其他进程占用的空闲缓冲块，于是将他插入对应哈希链表的头节点和空闲链表的尾部
>
> bread通过getblk获得一个已经在内存的缓冲块或者是一个空缓冲块，这个时候他检查缓冲块更新标志（更新标志标明现在缓冲块是刚从磁盘块读取出来的，这个缓冲块和磁盘块数据一致，当数据被修改时，除了置修改标志为，也会置更更新标志位为非更新），看他是否是最新的，如果不是或者是空缓冲块，就调用磁盘底层io驱动程序ll_rw_blk根据设备号和逻辑号从磁盘中读取需要的磁盘块，否则就直接 返回缓冲块头指针。file_read/file_write会修改缓冲块头的修改标志，以及对应文件的inode节点的修改标志，修改时间和最后读时间。bread函数流程图
>
> > ![Screenshot 2022-10-20 204807](D:\JavaBackend\实验\1 操作系统实验\实验8 虚拟文件系统的实现\Screenshot 2022-10-20 204807.png)
>
> fs/buffer.c定义了bread函数，getblk函数，定义了哈希链表hash_table建立的缓冲头节点指针
>
> ```c
> /*
>  *  linux/fs/buffer.c
>  *
>  *  (C) 1991  Linus Torvalds
>  */
> 
> /*
>  *  'buffer.c' implements the buffer-cache functions. Race-conditions have
>  * been avoided by NEVER letting a interrupt change a buffer (except for the
>  * data, of course), but instead letting the caller do it. NOTE! As interrupts
>  * can wake up a caller, some cli-sti sequences are needed to check for
>  * sleep-on-calls. These should be extremely quick, though (I hope).
>  */
> 
> /*
>  * NOTE! There is one discordant note here: checking floppies for
>  * disk change. This is where it fits best, I think, as it should
>  * invalidate changed floppy-disk-caches.
>  */
> 
> #include <stdarg.h>
> 
> #include <linux/config.h>
> #include <linux/sched.h>
> #include <linux/kernel.h>
> #include <asm/system.h>
> #include <asm/io.h>
> 
> extern int end;
> extern void put_super(int);
> extern void invalidate_inodes(int);
> 
> struct buffer_head * start_buffer = (struct buffer_head *) &end;
> struct buffer_head * hash_table[NR_HASH];
> static struct buffer_head * free_list;
> static struct task_struct * buffer_wait = NULL;
> int NR_BUFFERS = 0;
> 
> static inline void wait_on_buffer(struct buffer_head * bh)
> {
> 	cli();
> 	while (bh->b_lock)
> 		sleep_on(&bh->b_wait);
> 	sti();
> }
> 
> //将缓冲区中修改标志置位的块写入磁盘 ，将inode节点都写入磁盘
> int sys_sync(void)
> {
> 	int i;
> 	struct buffer_head * bh;
> 
> 	sync_inodes();		/* write out inodes into buffers */
> 	bh = start_buffer;
> 	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
> 		wait_on_buffer(bh);
> 		if (bh->b_dirt)
> 			ll_rw_block(WRITE,bh);
> 	}
> 	return 0;
> }
> 
> int sync_dev(int dev)
> {
> 	int i;
> 	struct buffer_head * bh;
> 
> 	bh = start_buffer;
> 	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
> 		if (bh->b_dev != dev)
> 			continue;
> 		wait_on_buffer(bh);
> 		if (bh->b_dev == dev && bh->b_dirt)
> 			ll_rw_block(WRITE,bh);
> 	}
> 	sync_inodes();
> 	bh = start_buffer;
> 	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
> 		if (bh->b_dev != dev)
> 			continue;
> 		wait_on_buffer(bh);
> 		if (bh->b_dev == dev && bh->b_dirt)
> 			ll_rw_block(WRITE,bh);
> 	}
> 	return 0;
> }
> 
> void inline invalidate_buffers(int dev)
> {
> 	int i;
> 	struct buffer_head * bh;
> 
> 	bh = start_buffer;
> 	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
> 		if (bh->b_dev != dev)
> 			continue;
> 		wait_on_buffer(bh);
> 		if (bh->b_dev == dev)
> 			bh->b_uptodate = bh->b_dirt = 0;
> 	}
> }
> 
> /*
>  * This routine checks whether a floppy has been changed, and
>  * invalidates all buffer-cache-entries in that case. This
>  * is a relatively slow routine, so we have to try to minimize using
>  * it. Thus it is called only upon a 'mount' or 'open'. This
>  * is the best way of combining speed and utility, I think.
>  * People changing diskettes in the middle of an operation deserve
>  * to loose :-)
>  *
>  * NOTE! Although currently this is only for floppies, the idea is
>  * that any additional removable block-device will use this routine,
>  * and that mount/open needn't know that floppies/whatever are
>  * special.
>  */
> void check_disk_change(int dev)
> {
> 	int i;
> 
> 	if (MAJOR(dev) != 2)
> 		return;
> 	if (!floppy_change(dev & 0x03))
> 		return;
> 	for (i=0 ; i<NR_SUPER ; i++)
> 		if (super_block[i].s_dev == dev)
> 			put_super(super_block[i].s_dev);
> 	invalidate_inodes(dev);
> 	invalidate_buffers(dev);
> }
> 
> #define _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)
> #define hash(dev,block) hash_table[_hashfn(dev,block)]
> 
> static inline void remove_from_queues(struct buffer_head * bh)
> {
> /* remove from hash-queue */
> 	if (bh->b_next)
> 		bh->b_next->b_prev = bh->b_prev;
> 	if (bh->b_prev)
> 		bh->b_prev->b_next = bh->b_next;
> 	if (hash(bh->b_dev,bh->b_blocknr) == bh)
> 		hash(bh->b_dev,bh->b_blocknr) = bh->b_next;
> /* remove from free list */
> 	if (!(bh->b_prev_free) || !(bh->b_next_free))
> 		panic("Free block list corrupted");
> 	bh->b_prev_free->b_next_free = bh->b_next_free;
> 	bh->b_next_free->b_prev_free = bh->b_prev_free;
> 	if (free_list == bh)
> 		free_list = bh->b_next_free;
> }
> 
> static inline void insert_into_queues(struct buffer_head * bh)
> {
> /* put at end of free list */
> 	bh->b_next_free = free_list;
> 	bh->b_prev_free = free_list->b_prev_free;
> 	free_list->b_prev_free->b_next_free = bh;
> 	free_list->b_prev_free = bh;
> /* put the buffer in new hash-queue if it has a device */
> 	bh->b_prev = NULL;
> 	bh->b_next = NULL;
> 	if (!bh->b_dev)
> 		return;
> 	bh->b_next = hash(bh->b_dev,bh->b_blocknr);
> 	hash(bh->b_dev,bh->b_blocknr) = bh;
> 	bh->b_next->b_prev = bh;
> }
> 
> static struct buffer_head * find_buffer(int dev, int block)
> {		
> 	struct buffer_head * tmp;
> 
> 	for (tmp = hash(dev,block) ; tmp != NULL ; tmp = tmp->b_next)
> 		if (tmp->b_dev==dev && tmp->b_blocknr==block)
> 			return tmp;
> 	return NULL;
> }
> 
> /*
>  * Why like this, I hear you say... The reason is race-conditions.
>  * As we don't lock buffers (unless we are readint them, that is),
>  * something might happen to it while we sleep (ie a read-error
>  * will force it bad). This shouldn't really happen currently, but
>  * the code is ready.
>  */
> struct buffer_head * get_hash_table(int dev, int block)
> {
> 	struct buffer_head * bh;
> 
> 	for (;;) {
> 		if (!(bh=find_buffer(dev,block)))
> 			return NULL;
> 		bh->b_count++;
> 		wait_on_buffer(bh);
> 		if (bh->b_dev == dev && bh->b_blocknr == block)
> 			return bh;
> 		bh->b_count--;
> 	}
> }
> 
> /*
>  * Ok, this is getblk, and it isn't very clear, again to hinder
>  * race-conditions. Most of the code is seldom used, (ie repeating),
>  * so it should be much more efficient than it looks.
>  *
>  * The algoritm is changed: hopefully better, and an elusive bug removed.
>  */
> #define BADNESS(bh) (((bh)->b_dirt<<1)+(bh)->b_lock)
> struct buffer_head * getblk(int dev,int block)
> {
> 	struct buffer_head * tmp, * bh;
> 
> repeat:
> 	if ((bh = get_hash_table(dev,block)))
> 		return bh;
> 	tmp = free_list;
> 	do {
> 		if (tmp->b_count)
> 			continue;
> 		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
> 			bh = tmp;
> 			if (!BADNESS(tmp))
> 				break;
> 		}
> /* and repeat until we find something good */
> 	} while ((tmp = tmp->b_next_free) != free_list);
> 	if (!bh) {
> 		sleep_on(&buffer_wait);
> 		goto repeat;
> 	}
> 	wait_on_buffer(bh);
> 	if (bh->b_count)
> 		goto repeat;
> 	while (bh->b_dirt) {
> 		sync_dev(bh->b_dev);
> 		wait_on_buffer(bh);
> 		if (bh->b_count)
> 			goto repeat;
> 	}
> /* NOTE!! While we slept waiting for this block, somebody else might */
> /* already have added "this" block to the cache. check it */
> 	if (find_buffer(dev,block))
> 		goto repeat;
> /* OK, FINALLY we know that this buffer is the only one of it's kind, */
> /* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
> 	bh->b_count=1;
> 	bh->b_dirt=0;
> 	bh->b_uptodate=0;
> 	remove_from_queues(bh);
> 	bh->b_dev=dev;
> 	bh->b_blocknr=block;
> 	insert_into_queues(bh);
> 	return bh;
> }
> 
> void brelse(struct buffer_head * buf)
> {
> 	if (!buf)
> 		return;
> 	wait_on_buffer(buf);
> 	if (!(buf->b_count--))
> 		panic("Trying to free free buffer");
> 	wake_up(&buffer_wait);
> }
> 
> /*
>  * bread() reads a specified block and returns the buffer that contains
>  * it. It returns NULL if the block was unreadable.
>  */
> struct buffer_head * bread(int dev,int block)
> {
> 	struct buffer_head * bh;
> 
> 	if (!(bh=getblk(dev,block)))
> 		panic("bread: getblk returned NULL\n");
> 	if (bh->b_uptodate)
> 		return bh;
> 	ll_rw_block(READ,bh);
> 	wait_on_buffer(bh);
> 	if (bh->b_uptodate)
> 		return bh;
> 	brelse(bh);
> 	return NULL;
> }
> 
> #define COPYBLK(from,to) \
> __asm__("cld\n\t" \
> 	"rep\n\t" \
> 	"movsl\n\t" \
> 	::"c" (BLOCK_SIZE/4),"S" (from),"D" (to) \
> 	)
> 
> /*
>  * bread_page reads four buffers into memory at the desired address. It's
>  * a function of its own, as there is some speed to be got by reading them
>  * all at the same time, not waiting for one to be read, and then another
>  * etc.
>  */
> void bread_page(unsigned long address,int dev,int b[4])
> {
> 	struct buffer_head * bh[4];
> 	int i;
> 
> 	for (i=0 ; i<4 ; i++)
> 		if (b[i]) {
> 			if ((bh[i] = getblk(dev,b[i])))
> 				if (!bh[i]->b_uptodate)
> 					ll_rw_block(READ,bh[i]);
> 		} else
> 			bh[i] = NULL;
> 	for (i=0 ; i<4 ; i++,address += BLOCK_SIZE)
> 		if (bh[i]) {
> 			wait_on_buffer(bh[i]);
> 			if (bh[i]->b_uptodate)
> 				COPYBLK((unsigned long) bh[i]->b_data,address);
> 			brelse(bh[i]);
> 		}
> }
> 
> /*
>  * Ok, breadaaaaa can be used as bread, but additionally to mark other
>  * blocks for reading as well. End the argument list with a negative
>  * number.
>  */
> struct buffer_head * breada(int dev,int first, ...)
> {
> 	va_list args;
> 	struct buffer_head * bh, *tmp;
> 
> 	va_start(args,first);
> 	if (!(bh=getblk(dev,first)))
> 		panic("bread: getblk returned NULL\n");
> 	if (!bh->b_uptodate)
> 		ll_rw_block(READ,bh);
> 	while ((faaaaaaaaaairst=va_arg(args,int))>=0) {
> 		tmp=getblk(dev,first);
> 		if (tmp) {
> 			if (!tmp->b_uptodate)
> 				ll_rw_block(READA,bh);
> 			tmp->b_count--;
> 		}
> 	}
> 	va_end(args);
> 	wait_on_buffer(bh);
> 	if (bh->b_uptodate)
> 		return bh;
> 	
>     
> 	return (NULL);
> }
> 
> void buffer_init(long buffer_end)
> {
> 	struct buffer_head * h = start_buffer;
> 	void * b;
> 	int i;
> 
> 	if (buffer_end == 1<<20)
> 		b = (void *) (640*1024);
> 	else
> 		b = (void *) buffer_end;
> 	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {
> 		h->b_dev = 0;
> 		h->b_dirt = 0;
> 		h->b_count = 0;
> 		h->b_lock = 0;
> 		h->b_uptodate = 0;
> 		h->b_wait = NULL;
> 		h->b_next = NULL;
> 		h->b_prev = NULL;
> 		h->b_data = (char *) b;
> 		h->b_prev_free = h-1;
> 		h->b_next_free = h+1;
> 		h++;
> 		NR_BUFFERS++;
> 		if (b == (void *) 0x100000)
> 			b = (void *) 0xA0000;
> 	}
> 	h--;
> 	free_list = start_buffer;
> 	free_list->b_prev_free = h;
> 	h->b_next_free = free_list;
> 	for (i=0;i<NR_HASH;i++)
> 		hash_table[i]=NULL;
> }	
> ```
>
> brelse函数释放一个缓冲块，首先等待这个缓冲块解锁**while(bh->block) sleep_on(bh->wait)**，当缓冲块被解锁（被进程释放）之后，他会减少缓冲块进程引用次数bh->count--，然后唤醒等待分配缓冲块的进程队列中的进程buffer_wait(在fs/buffer中定义为全局变量)

###### 管理i节点读写的函数：iget/iput将inode节点读取或者写回磁盘

> iget函数根据设备号和i节点号nr（i节点位图下标），从磁盘中读取i节点号为nr的i节点到inode表inode_table，置引用次数为1，如果inode表中已经存在这个inode节点，就增加他的引用次数。iput将inode节点写回磁盘。
>
> bmap函数根据根据文件设备号和数据块号（读写指针/BLOCK_SIZE一个数据块大小)将文件数据块映射到磁盘数据块的逻辑块号。
>
> 寻找根据i节点号nr（i节点位图下标）获取i节点所在磁盘块号：i节点nr所在磁盘块=引导块数+超级块数+i节点位图数据块数+逻辑块位图数据块数+nr*i节点大小/BLOCK_SIZE每个数据块大小，这样就可以根据i节点号nr获得对应的i节点文件信息，这在iget和iput中根据i节点号nr获取对应的i节点所在数据块得到使用。iget和iput获取超级块/i节点位图/逻辑块位图/i节点数据块（inode数据，存储文件元信息）/逻辑块数据块（普通数据块（存储文件数据））等都通过bread函数获取对应的数据块，bread读取的时候需要使用设备号和逻辑块号，逻辑块号的获得对inode节点来说是通过超级块的磁盘信息（存放逻辑块位图数据块数和i节点位图数据块数）等来计算的，对于给定i节点号nr的i节点所在的逻辑块的逻辑块号是**引导快数+超级块数+i节点位图数据块数+逻辑块位图数据块数+nr\*inode节点大小/BLOCK_SIZE**；对于文件数据块来说获得对应逻辑块号是**bmap**函数获得的，bmap函数传入文件i节点和数据块号f_pos/BLOCK_SIZE。
>
> bmap函数根据文件数据块号获取对应的盘块号，基本操作是文件i节点保存的i_zone[9]数组是文件使用的逻辑块数组，他保存了文件使用的数据块的逻辑号，对于nr=f_pos/BLOCK_SIZE的数据块，他对应的逻辑号是inode->i_zone[nr]，这里要保证nr<7，因为大于他会使用到间接盘块号，就不能像使用inode->i_zone[nr]直接映射得到了。
>
> ```c
> /*
>  *  linux/fs/inode.c
>  *
>  *  (C) 1991  Linus Torvalds
>  */
> 
> #include <string.h> 
> #include <sys/stat.h>
> 
> #include <linux/sched.h>
> #include <linux/kernel.h>
> #include <linux/mm.h>
> #include <asm/system.h>
> 
> struct m_inode inode_table[NR_INODE]={{0,},};
> 
> static void read_inode(struct m_inode * inode);
> static void write_inode(struct m_inode * inode);
> 
> static inline void wait_on_inode(struct m_inode * inode)
> {
> 	cli();
> 	while (inode->i_lock)
> 		sleep_on(&inode->i_wait);
> 	sti();
> }
> 
> static inline void lock_inode(struct m_inode * inode)
> {
> 	cli();
> 	while (inode->i_lock)
> 		sleep_on(&inode->i_wait);
> 	inode->i_lock=1;
> 	sti();
> }
> 
> static inline void unlock_inode(struct m_inode * inode)
> {
> 	inode->i_lock=0;
> 	wake_up(&inode->i_wait);
> }
> 
> void invalidate_inodes(int dev)
> {
> 	int i;
> 	struct m_inode * inode;
> 
> 	inode = 0+inode_table;
> 	for(i=0 ; i<NR_INODE ; i++,inode++) {
> 		wait_on_inode(inode);
> 		if (inode->i_dev == dev) {
> 			if (inode->i_count)
> 				printk("inode in use on removed disk\n\r");
> 			inode->i_dev = inode->i_dirt = 0;
> 		}
> 	}
> }
> 
> void sync_inodes(void)
> {
> 	int i;
> 	struct m_inode * inode;
> 
> 	inode = 0+inode_table;
> 	for(i=0 ; i<NR_INODE ; i++,inode++) {
> 		wait_on_inode(inode);
> 		if (inode->i_dirt && !inode->i_pipe)
> 			write_inode(inode);
> 	}
> }
> 
> static int _bmap(struct m_inode * inode,int block,int create)
> {
> 	struct buffer_head * bh;
> 	int i;
> 
> 	if (block<0)
> 		panic("_bmap: block<0");
> 	if (block >= 7+512+512*512)
> 		panic("_bmap: block>big");
> 	if (block<7) {
> 		if (create && !inode->i_zone[block])
> 			if ((inode->i_zone[block]=new_block(inode->i_dev))) {
> 				inode->i_ctime=CURRENT_TIME;
> 				inode->i_dirt=1;
> 			}
> 		return inode->i_zone[block];
> 	}
> 	block -= 7;
> 	if (block<512) {
> 		if (create && !inode->i_zone[7])
> 			if ((inode->i_zone[7]=new_block(inode->i_dev))) {
> 				inode->i_dirt=1;
> 				inode->i_ctime=CURRENT_TIME;
> 			}
> 		if (!inode->i_zone[7])
> 			return 0;
> 		if (!(bh = bread(inode->i_dev,inode->i_zone[7])))
> 			return 0;
> 		i = ((unsigned short *) (bh->b_data))[block];
> 		if (create && !i)
> 			if ((i=new_block(inode->i_dev))) {
> 				((unsigned short *) (bh->b_data))[block]=i;
> 				bh->b_dirt=1;
> 			}
> 		brelse(bh);
> 		return i;
> 	}
> 	block -= 512;
> 	if (create && !inode->i_zone[8])
> 		if ((inode->i_zone[8]=new_block(inode->i_dev))) {
> 			inode->i_dirt=1;
> 			inode->i_ctime=CURRENT_TIME;
> 		}
> 	if (!inode->i_zone[8])
> 		return 0;
> 	if (!(bh=bread(inode->i_dev,inode->i_zone[8])))
> 		return 0;
> 	i = ((unsigned short *)bh->b_data)[block>>9];
> 	if (create && !i)
> 		if ((i=new_block(inode->i_dev))) {
> 			((unsigned short *) (bh->b_data))[block>>9]=i;
> 			bh->b_dirt=1;
> 		}
> 	brelse(bh);
> 	if (!i)
> 		return 0;
> 	if (!(bh=bread(inode->i_dev,i)))
> 		return 0;
> 	i = ((unsigned short *)bh->b_data)[block&511];
> 	if (create && !i)
> 		if ((i=new_block(inode->i_dev))) {
> 			((unsigned short *) (bh->b_data))[block&511]=i;
> 			bh->b_dirt=1;
> 		}
> 	brelse(bh);
> 	return i;
> }
> 
> int bmap(struct m_inode * inode,int block)
> {
> 	return _bmap(inode,block,0);
> }
> 
> int create_block(struct m_inode * inode, int block)
> {
> 	return _bmap(inode,block,1);
> }
> 		
> void iput(struct m_inode * inode)
> {
> 	if (!inode)
> 		return;
> 	wait_on_inode(inode);
> 	if (!inode->i_count)
> 		panic("iput: trying to free free inode");
> 	if (inode->i_pipe) {
> 		wake_up(&inode->i_wait);
> 		if (--inode->i_count)
> 			return;
> 		free_page(inode->i_size);
> 		inode->i_count=0;
> 		inode->i_dirt=0;
> 		inode->i_pipe=0;
> 		return;
> 	}
> 	if (!inode->i_dev) {
> 		inode->i_count--;
> 		return;
> 	}
> 	if (S_ISBLK(inode->i_mode)) {
> 		sync_dev(inode->i_zone[0]);
> 		wait_on_inode(inode);
> 	}
> repeat:
> 	if (inode->i_count>1) {
> 		inode->i_count--;
> 		return;
> 	}
> 	if (!inode->i_nlinks) {
> 		truncate(inode);
> 		free_inode(inode);
> 		return;
> 	}
> 	if (inode->i_dirt) {
> 		write_inode(inode);	/* we can sleep - so do again */
> 		wait_on_inode(inode);
> 		goto repeat;
> 	}
> 	inode->i_count--;
> 	return;
> }
> 
> struct m_inode * get_empty_inode(void)
> {
> 	struct m_inode * inode;
> 	static struct m_inode * last_inode = inode_table;
> 	int i;
> 
> 	do {
> 		inode = NULL;
> 		for (i = NR_INODE; i ; i--) {
> 			if (++last_inode >= inode_table + NR_INODE)
> 				last_inode = inode_table;
> 			if (!last_inode->i_count) {
> 				inode = last_inode;
> 				if (!inode->i_dirt && !inode->i_lock)
> 					break;
> 			}
> 		}
> 		if (!inode) {
> 			for (i=0 ; i<NR_INODE ; i++)
> 				printk("%04x: %6d\t",inode_table[i].i_dev,
> 					inode_table[i].i_num);
> 			panic("No free inodes in mem");
> 		}
> 		wait_on_inode(inode);
> 		while (inode->i_dirt) {
> 			write_inode(inode);
> 			wait_on_inode(inode);
> 		}
> 	} while (inode->i_count);
> 	memset(inode,0,sizeof(*inode));
> 	inode->i_count = 1;
> 	return inode;
> }
> 
> struct m_inode * get_pipe_inode(void)
> {
> 	struct m_inode * inode;
> 
> 	if (!(inode = get_empty_inode()))
> 		return NULL;
> 	if (!(inode->i_size=get_free_page())) {
> 		inode->i_count = 0;
> 		return NULL;
> 	}
> 	inode->i_count = 2;	/* sum of readers/writers */
> 	PIPE_HEAD(*inode) = PIPE_TAIL(*inode) = 0;
> 	inode->i_pipe = 1;
> 	return inode;
> }
> 
> struct m_inode * iget(int dev,int nr)
> {
> 	struct m_inode * inode, * empty;
> 
> 	if (!dev)
> 		panic("iget with dev==0");
> 	empty = get_empty_inode();
> 	inode = inode_table;
> 	while (inode < NR_INODE+inode_table) {
> 		if (inode->i_dev != dev || inode->i_num != nr) {
> 			inode++;
> 			continue;
> 		}
> 		wait_on_inode(inode);
> 		if (inode->i_dev != dev || inode->i_num != nr) {
> 			inode = inode_table;
> 			continue;
> 		}
> 		inode->i_count++;
> 		if (inode->i_mount) {
> 			int i;
> 
> 			for (i = 0 ; i<NR_SUPER ; i++)
> 				if (super_block[i].s_imount==inode)
> 					break;
> 			if (i >= NR_SUPER) {
> 				printk("Mounted inode hasn't got sb\n");
> 				if (empty)
> 					iput(empty);
> 				return inode;
> 			}
> 			iput(inode);
> 			dev = super_block[i].s_dev;
> 			nr = ROOT_INO;
> 			inode = inode_table;
> 			continue;
> 		}
> 		if (empty)
> 			iput(empty);
> 		return inode;
> 	}
> 	if (!empty)
> 		return (NULL);
> 	inode=empty;
> 	inode->i_dev = dev;
> 	inode->i_num = nr;
> 	read_inode(inode);
> 	return inode;
> }
> 
> static void read_inode(struct m_inode * inode)
> {
> 	struct super_block * sb;
> 	struct buffer_head * bh;
> 	int block;
> 
> 	lock_inode(inode);
> 	if (!(sb=get_super(inode->i_dev)))
> 		panic("trying to read inode without dev");
> 	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
> 		(inode->i_num-1)/INODES_PER_BLOCK;
> 	if (!(bh=bread(inode->i_dev,block)))
> 		panic("unable to read i-node block");
> 	*(struct d_inode *)inode =
> 		((struct d_inode *)bh->b_data)
> 			[(inode->i_num-1)%INODES_PER_BLOCK];
> 	brelse(bh);
> 	unlock_inode(inode);
> }
> 
> static void write_inode(struct m_inode * inode)
> {
> 	struct super_block * sb;
> 	struct buffer_head * bh;
> 	int block;
> 
> 	lock_inode(inode);
> 	if (!inode->i_dirt || !inode->i_dev) {
> 		unlock_inode(inode);
> 		return;
> 	}
> 	if (!(sb=get_super(inode->i_dev)))
> 		panic("trying to write inode without device");
> 	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
> 		(inode->i_num-1)/INODES_PER_BLOCK;
> 	if (!(bh=bread(inode->i_dev,block)))
> 		panic("unable to read i-node block");
> 	((struct d_inode *)bh->b_data)
> 		[(inode->i_num-1)%INODES_PER_BLOCK] =
> 			*(struct d_inode *)inode;
> 	bh->b_dirt=1;
> 	inode->i_dirt=0;
> 	brelse(bh);
> 	unlock_inode(inode);
> }
> ```

###### 根据文件名映射到对应inode节点的函数namei, open_namei

> Linux系统中目录也是一个文件，用i节点来标记一个目录文件。1进程开始的时候会加载磁盘，设置进程根目录和工作目录执行目录的i节点,current->root, current->pwd, current->exct。在解析路径的时候如果"/xxx"以"/"开始的目录会从current->root根目录开始，其他的会从crrent->pwd当前工作目录开始找，当获得一级目录的时候，通过目录i节点的i_zone获得文件使用的数据块，加载这些数据块保存到内存里面的内容是目录项数据，目录项结构在**include/linux/fs.h**中定义为 **struct dir_entry{ int inode, char name[LEN]}**，也就是目录文件中保存的一个目录项是目录项文件的i节点号和目录项文件的文件名称。就这样通过find_entry函数可以一级一级获取目录文件，匹配目录项结构，从目录项结构获得下一级目录的i节点号号，iget函数根据设备号和i节点号加载i节点信息到i节点表中，根据这个目录i节点访问目录文件获得下一级目录。最后我们访问到我们需要的文件的i节点，返回这个i节点。
>
> ```c
> /*
>  *  linux/fs/namei.c
>  *
>  *  (C) 1991  Linus Torvalds
>  */
> 
> /*
>  * Some corrections by tytso.
>  */
> 
> #include <linux/sched.h>
> #include <linux/kernel.h>
> #include <asm/segment.h>
> 
> #include <string.h> 
> #include <fcntl.h>
> #include <errno.h>
> #include <const.h>
> #include <sys/stat.h>
> 
> #define ACC_MODE(x) ("\004\002\006\377"[(x)&O_ACCMODE])
> 
> /*
>  * comment out this line if you want names > NAME_LEN chars to be
>  * truncated. Else they will be disallowed.
>  */
> /* #define NO_TRUNCATE */
> 
> #define MAY_EXEC 1
> #define MAY_WRITE 2
> #define MAY_READ 4
> 
> /*
>  *	permission()
>  *
>  * is used to check for read/write/execute permissions on a file.
>  * I don't know if we should look at just the euid or both euid and
>  * uid, but that should be easily changed.
>  */
> static int permission(struct m_inode * inode,int mask)
> {
> 	int mode = inode->i_mode;
> 
> /* special case: not even root can read/write a deleted file */
> 	if (inode->i_dev && !inode->i_nlinks)
> 		return 0;
> 	else if (current->euid==inode->i_uid)
> 		mode >>= 6;
> 	else if (current->egid==inode->i_gid)
> 		mode >>= 3;
> 	if (((mode & mask & 0007) == mask) || suser())
> 		return 1;
> 	return 0;
> }
> 
> /*
>  * ok, we cannot use strncmp, as the name is not in our data space.
>  * Thus we'll have to use match. No big problem. Match also makes
>  * some sanity tests.
>  *
>  * NOTE! unlike strncmp, match returns 1 for success, 0 for failure.
>  */
> static int match(int len,const char * name,struct dir_entry * de)
> {
> 	register int same ;
> 
> 	if (!de || !de->inode || len > NAME_LEN)
> 		return 0;
> 	if (len < NAME_LEN && de->name[len])
> 		return 0;
> 	__asm__("cld\n\t"
> 		"fs ; repe ; cmpsb\n\t"
> 		"setz %%al"
> 		:"=a" (same)
> 		:"0" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
> 		);
> 	return same;
> }
> 
> /*
>  *	find_entry()
>  *
>  * finds an entry in the specified directory with the wanted name. It
>  * returns the cache buffer in which the entry was found, and the entry
>  * itself (as a parameter - res_dir). It does NOT read the inode of the
>  * entry - you'll have to do that yourself if you want to.
>  *
>  * This also takes care of the few special cases due to '..'-traversal
>  * over a pseudo-root and a mount point.
>  */
> static struct buffer_head * find_entry(struct m_inode ** dir,
> 	const char * name, int namelen, struct dir_entry ** res_dir)
> {
> 	int entries;
> 	int block,i;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 	struct super_block * sb;
> 
> #ifdef NO_TRUNCATE
> 	if (namelen > NAME_LEN)
> 		return NULL;
> #else
> 	if (namelen > NAME_LEN)
> 		namelen = NAME_LEN;
> #endif
> 	entries = (*dir)->i_size / (sizeof (struct dir_entry));
> 	*res_dir = NULL;
> 	if (!namelen)
> 		return NULL;
> /* check for '..', as we might have to do some "magic" for it */
> 	if (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {
> /* '..' in a pseudo-root results in a faked '.' (just change namelen) */
> 		if ((*dir) == current->root)
> 			namelen=1;
> 		else if ((*dir)->i_num == ROOT_INO) {
> /* '..' over a mount-point results in 'dir' being exchanged for the mounted
>    directory-inode. NOTE! We set mounted, so that we can iput the new dir */
> 			sb=get_super((*dir)->i_dev);
> 			if (sb->s_imount) {
> 				iput(*dir);
> 				(*dir)=sb->s_imount;
> 				(*dir)->i_count++;
> 			}
> 		}
> 	}
> 	if (!(block = (*dir)->i_zone[0]))
> 		return NULL;
> 	if (!(bh = bread((*dir)->i_dev,block)))
> 		return NULL;
> 	i = 0;
> 	de = (struct dir_entry *) bh->b_data;
> 	while (i < entries) {
> 		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
> 			brelse(bh);
> 			bh = NULL;
> 			if (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||
> 			    !(bh = bread((*dir)->i_dev,block))) {
> 				i += DIR_ENTRIES_PER_BLOCK;
> 				continue;
> 			}
> 			de = (struct dir_entry *) bh->b_data;
> 		}
> 		if (match(namelen,name,de)) {
> 			*res_dir = de;
> 			return bh;
> 		}
> 		de++;
> 		i++;
> 	}
> 	brelse(bh);
> 	return NULL;
> }
> 
> /*
>  *	add_entry()
>  *
>  * adds a file entry to the specified directory, using the same
>  * semantics as find_entry(). It returns NULL if it failed.
>  *
>  * NOTE!! The inode part of 'de' is left at 0 - which means you
>  * may not sleep between calling this and putting something into
>  * the entry, as someone else might have used it while you slept.
>  */
> static struct buffer_head * add_entry(struct m_inode * dir,
> 	const char * name, int namelen, struct dir_entry ** res_dir)
> {
> 	int block,i;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 
> 	*res_dir = NULL;
> #ifdef NO_TRUNCATE
> 	if (namelen > NAME_LEN)
> 		return NULL;
> #else
> 	if (namelen > NAME_LEN)
> 		namelen = NAME_LEN;
> #endif
> 	if (!namelen)
> 		return NULL;
> 	if (!(block = dir->i_zone[0]))
> 		return NULL;
> 	if (!(bh = bread(dir->i_dev,block)))
> 		return NULL;
> 	i = 0;
> 	de = (struct dir_entry *) bh->b_data;
> 	while (1) {
> 		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
> 			brelse(bh);
> 			bh = NULL;
> 			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);
> 			if (!block)
> 				return NULL;
> 			if (!(bh = bread(dir->i_dev,block))) {
> 				i += DIR_ENTRIES_PER_BLOCK;
> 				continue;
> 			}
> 			de = (struct dir_entry *) bh->b_data;
> 		}
> 		if (i*sizeof(struct dir_entry) >= dir->i_size) {
> 			de->inode=0;
> 			dir->i_size = (i+1)*sizeof(struct dir_entry);
> 			dir->i_dirt = 1;
> 			dir->i_ctime = CURRENT_TIME;
> 		}
> 		if (!de->inode) {
> 			dir->i_mtime = CURRENT_TIME;
> 			for (i=0; i < NAME_LEN ; i++)
> 				de->name[i]=(i<namelen)?get_fs_byte(name+i):0;
> 			bh->b_dirt = 1;
> 			*res_dir = de;
> 			return bh;
> 		}
> 		de++;
> 		i++;
> 	}
> 	brelse(bh);
> 	return NULL;
> }
> 
> /*
>  *	get_dir()
>  *
>  * Getdir traverses the pathname until it hits the topmost directory.
>  * It returns NULL on failure.
>  */
> static struct m_inode * get_dir(const char * pathname)
> {
> 	char c;
> 	const char * thisname;
> 	struct m_inode * inode;
> 	struct buffer_head * bh;
> 	int namelen,inr,idev;
> 	struct dir_entry * de;
> 
> 	if (!current->root || !current->root->i_count)
> 		panic("No root inode");
> 	if (!current->pwd || !current->pwd->i_count)
> 		panic("No cwd inode");
> 	if ((c=get_fs_byte(pathname))=='/') {
> 		inode = current->root;
> 		pathname++;
> 	} else if (c)
> 		inode = current->pwd;
> 	else
> 		return NULL;	/* empty name is bad */
> 	inode->i_count++;
> 	while (1) {
> 		thisname = pathname;
> 		if (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {
> 			iput(inode);
> 			return NULL;
> 		}
> 		for(namelen=0;(c=get_fs_byte(pathname++))&&(c!='/');namelen++)
> 			/* nothing */ ;
> 		if (!c)
> 			return inode;
> 		if (!(bh = find_entry(&inode,thisname,namelen,&de))) {
> 			iput(inode);
> 			return NULL;
> 		}
> 		inr = de->inode;
> 		idev = inode->i_dev;
> 		brelse(bh);
> 		iput(inode);
> 		if (!(inode = iget(idev,inr)))
> 			return NULL;
> 	}
> }
> 
> /*
>  *	dir_namei()
>  *
>  * dir_namei() returns the inode of the directory of the
>  * specified name, and the name within that directory.
>  */
> static struct m_inode * dir_namei(const char * pathname,
> 	int * namelen, const char ** name)
> {
> 	char c;
> 	const char * basename;
> 	struct m_inode * dir;
> 
> 	if (!(dir = get_dir(pathname)))
> 		return NULL;
> 	basename = pathname;
> 	while ((c=get_fs_byte(pathname++)))
> 		if (c=='/')
> 			basename=pathname;
> 	*namelen = pathname-basename-1;
> 	*name = basename;
> 	return dir;
> }
> 
> /*
>  *	namei()
>  *
>  * is used by most simple commands to get the inode of a specified name.
>  * Open, link etc use their own routines, but this is enough for things
>  * like 'chmod' etc.
>  */
> struct m_inode * namei(const char * pathname)
> {
> 	const char * basename;
> 	int inr,dev,namelen;
> 	struct m_inode * dir;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 
> 	if (!(dir = dir_namei(pathname,&namelen,&basename)))
> 		return NULL;
> 	if (!namelen)			/* special case: '/usr/' etc */
> 		return dir;
> 	bh = find_entry(&dir,basename,namelen,&de);
> 	if (!bh) {
> 		iput(dir);
> 		return NULL;
> 	}
> 	inr = de->inode;
> 	dev = dir->i_dev;
> 	brelse(bh);
> 	iput(dir);
> 	dir=iget(dev,inr);
> 	if (dir) {
> 		dir->i_atime=CURRENT_TIME;
> 		dir->i_dirt=1;
> 	}
> 	return dir;
> }
> 
> /*
>  *	open_namei()
>  *
>  * namei for open - this is in fact almost the whole open-routine.
>  */
> int open_namei(const char * pathname, int flag, int mode,
> 	struct m_inode ** res_inode)
> {
> 	const char * basename;
> 	int inr,dev,namelen;
> 	struct m_inode * dir, *inode;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 
> 	if ((flag & O_TRUNC) && !(flag & O_ACCMODE))
> 		flag |= O_WRONLY;
> 	mode &= 0777 & ~current->umask;
> 	mode |= I_REGULAR;
> 	if (!(dir = dir_namei(pathname,&namelen,&basename)))
> 		return -ENOENT;
> 	if (!namelen) {			/* special case: '/usr/' etc */
> 		if (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {
> 			*res_inode=dir;
> 			return 0;
> 		}
> 		iput(dir);
> 		return -EISDIR;
> 	}
> 	bh = find_entry(&dir,basename,namelen,&de);
> 	if (!bh) {
> 		if (!(flag & O_CREAT)) {
> 			iput(dir);
> 			return -ENOENT;
> 		}
> 		if (!permission(dir,MAY_WRITE)) {
> 			iput(dir);
> 			return -EACCES;
> 		}
> 		inode = new_inode(dir->i_dev);
> 		if (!inode) {
> 			iput(dir);
> 			return -ENOSPC;
> 		}
> 		inode->i_uid = current->euid;
> 		inode->i_mode = mode;
> 		inode->i_dirt = 1;
> 		bh = add_entry(dir,basename,namelen,&de);
> 		if (!bh) {
> 			inode->i_nlinks--;
> 			iput(inode);
> 			iput(dir);
> 			return -ENOSPC;
> 		}
> 		de->inode = inode->i_num;
> 		bh->b_dirt = 1;
> 		brelse(bh);
> 		iput(dir);
> 		*res_inode = inode;
> 		return 0;
> 	}
> 	inr = de->inode;
> 	dev = dir->i_dev;
> 	brelse(bh);
> 	iput(dir);
> 	if (flag & O_EXCL)
> 		return -EEXIST;
> 	if (!(inode=iget(dev,inr)))
> 		return -EACCES;
> 	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
> 	    !permission(inode,ACC_MODE(flag))) {
> 		iput(inode);
> 		return -EPERM;
> 	}
> 	inode->i_atime = CURRENT_TIME;
> 	if (flag & O_TRUNC)
> 		truncate(inode);
> 	*res_inode = inode;
> 	return 0;
> }
> 
> int sys_mknod(const char * filename, int mode, int dev)
> {
> 	const char * basename;
> 	int namelen;
> 	struct m_inode * dir, * inode;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 	
> 	if (!suser())
> 		return -EPERM;
> 	if (!(dir = dir_namei(filename,&namelen,&basename)))
> 		return -ENOENT;
> 	if (!namelen) {
> 		iput(dir);
> 		return -ENOENT;
> 	}
> 	if (!permission(dir,MAY_WRITE)) {
> 		iput(dir);
> 		return -EPERM;
> 	}
> 	bh = find_entry(&dir,basename,namelen,&de);
> 	if (bh) {
> 		brelse(bh);
> 		iput(dir);
> 		return -EEXIST;
> 	}
> 	inode = new_inode(dir->i_dev);
> 	if (!inode) {
> 		iput(dir);
> 		return -ENOSPC;
> 	}
> 	inode->i_mode = mode;
> 	if (S_ISBLK(mode) || S_ISCHR(mode)  || S_ISPROC(mode) )
> 		inode->i_zone[0] = dev;
> 	inode->i_mtime = inode->i_atime = CURRENT_TIME;
> 	inode->i_dirt = 1;
> 	bh = add_entry(dir,basename,namelen,&de);
> 	if (!bh) {
> 		iput(dir);
> 		inode->i_nlinks=0;
> 		iput(inode);
> 		return -ENOSPC;
> 	}
> 	de->inode = inode->i_num;
> 	bh->b_dirt = 1;
> 	iput(dir);
> 	iput(inode);
> 	brelse(bh);
> 	return 0;
> }
> 
> int sys_mkdir(const char * pathname, int mode)
> {
> 	const char * basename;
> 	int namelen;
> 	struct m_inode * dir, * inode;
> 	struct buffer_head * bh, *dir_block;
> 	struct dir_entry * de;
> 
> 	if (!suser())
> 		return -EPERM;
> 	if (!(dir = dir_namei(pathname,&namelen,&basename)))
> 		return -ENOENT;
> 	if (!namelen) {
> 		iput(dir);
> 		return -ENOENT;
> 	}
> 	if (!permission(dir,MAY_WRITE)) {
> 		iput(dir);
> 		return -EPERM;
> 	}
> 	bh = find_entry(&dir,basename,namelen,&de);
> 	if (bh) {
> 		brelse(bh);
> 		iput(dir);
> 		return -EEXIST;
> 	}
> 	inode = new_inode(dir->i_dev);
> 	if (!inode) {
> 		iput(dir);
> 		return -ENOSPC;
> 	}
> 	inode->i_size = 32;
> 	inode->i_dirt = 1;
> 	inode->i_mtime = inode->i_atime = CURRENT_TIME;
> 	if (!(inode->i_zone[0]=new_block(inode->i_dev))) {
> 		iput(dir);
> 		inode->i_nlinks--;
> 		iput(inode);
> 		return -ENOSPC;
> 	}
> 	inode->i_dirt = 1;
> 	if (!(dir_block=bread(inode->i_dev,inode->i_zone[0]))) {
> 		iput(dir);
> 		free_block(inode->i_dev,inode->i_zone[0]);
> 		inode->i_nlinks--;
> 		iput(inode);
> 		return -ERROR;
> 	}
> 	de = (struct dir_entry *) dir_block->b_data;
> 	de->inode=inode->i_num;
> 	strcpy(de->name,".");
> 	de++;
> 	de->inode = dir->i_num;
> 	strcpy(de->name,"..");
> 	inode->i_nlinks = 2;
> 	dir_block->b_dirt = 1;
> 	brelse(dir_block);
> 	inode->i_mode = I_DIRECTORY | (mode & 0777 & ~current->umask);
> 	inode->i_dirt = 1;
> 	bh = add_entry(dir,basename,namelen,&de);
> 	if (!bh) {
> 		iput(dir);
> 		free_block(inode->i_dev,inode->i_zone[0]);
> 		inode->i_nlinks=0;
> 		iput(inode);
> 		return -ENOSPC;
> 	}
> 	de->inode = inode->i_num;
> 	bh->b_dirt = 1;
> 	dir->i_nlinks++;
> 	dir->i_dirt = 1;
> 	iput(dir);
> 	iput(inode);
> 	brelse(bh);
> 	return 0;
> }
> 
> /*
>  * routine to check that the specified directory is empty (for rmdir)
>  */
> static int empty_dir(struct m_inode * inode)
> {
> 	int nr,block;
> 	int len;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 
> 	len = inode->i_size / sizeof (struct dir_entry);
> 	if (len<2 || !inode->i_zone[0] ||
> 	    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {
> 	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
> 		return 0;
> 	}
> 	de = (struct dir_entry *) bh->b_data;
> 	if (de[0].inode != inode->i_num || !de[1].inode || 
> 	    strcmp(".",de[0].name) || strcmp("..",de[1].name)) {
> 	    	printk("warning - bad directory on dev %04x\n",inode->i_dev);
> 		return 0;
> 	}
> 	nr = 2;
> 	de += 2;
> 	while (nr<len) {
> 		if ((void *) de >= (void *) (bh->b_data+BLOCK_SIZE)) {
> 			brelse(bh);
> 			block=bmap(inode,nr/DIR_ENTRIES_PER_BLOCK);
> 			if (!block) {
> 				nr += DIR_ENTRIES_PER_BLOCK;
> 				continue;
> 			}
> 			if (!(bh=bread(inode->i_dev,block)))
> 				return 0;
> 			de = (struct dir_entry *) bh->b_data;
> 		}
> 		if (de->inode) {
> 			brelse(bh);
> 			return 0;
> 		}
> 		de++;
> 		nr++;
> 	}
> 	brelse(bh);
> 	return 1;
> }
> 
> int sys_rmdir(const char * name)
> {
> 	const char * basename;
> 	int namelen;
> 	struct m_inode * dir, * inode;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 
> 	if (!suser())
> 		return -EPERM;
> 	if (!(dir = dir_namei(name,&namelen,&basename)))
> 		return -ENOENT;
> 	if (!namelen) {
> 		iput(dir);
> 		return -ENOENT;
> 	}
> 	if (!permission(dir,MAY_WRITE)) {
> 		iput(dir);
> 		return -EPERM;
> 	}
> 	bh = find_entry(&dir,basename,namelen,&de);
> 	if (!bh) {
> 		iput(dir);
> 		return -ENOENT;
> 	}
> 	if (!(inode = iget(dir->i_dev, de->inode))) {
> 		iput(dir);
> 		brelse(bh);
> 		return -EPERM;
> 	}
> 	if ((dir->i_mode & S_ISVTX) && current->euid &&
> 	    inode->i_uid != current->euid) {
> 		iput(dir);
> 		iput(inode);
> 		brelse(bh);
> 		return -EPERM;
> 	}
> 	if (inode->i_dev != dir->i_dev || inode->i_count>1) {
> 		iput(dir);
> 		iput(inode);
> 		brelse(bh);
> 		return -EPERM;
> 	}
> 	if (inode == dir) {	/* we may not delete ".", but "../dir" is ok */
> 		iput(inode);
> 		iput(dir);
> 		brelse(bh);
> 		return -EPERM;
> 	}
> 	if (!S_ISDIR(inode->i_mode)) {
> 		iput(inode);
> 		iput(dir);
> 		brelse(bh);
> 		return -ENOTDIR;
> 	}
> 	if (!empty_dir(inode)) {
> 		iput(inode);
> 		iput(dir);
> 		brelse(bh);
> 		return -ENOTEMPTY;
> 	}
> 	if (inode->i_nlinks != 2)
> 		printk("empty directory has nlink!=2 (%d)",inode->i_nlinks);
> 	de->inode = 0;
> 	bh->b_dirt = 1;
> 	brelse(bh);
> 	inode->i_nlinks=0;
> 	inode->i_dirt=1;
> 	dir->i_nlinks--;
> 	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
> 	dir->i_dirt=1;
> 	iput(dir);
> 	iput(inode);
> 	return 0;
> }
> 
> int sys_unlink(const char * name)
> {
> 	const char * basename;
> 	int namelen;
> 	struct m_inode * dir, * inode;
> 	struct buffer_head * bh;
> 	struct dir_entry * de;
> 
> 	if (!(dir = dir_namei(name,&namelen,&basename)))
> 		return -ENOENT;
> 	if (!namelen) {
> 		iput(dir);
> 		return -ENOENT;
> 	}
> 	if (!permission(dir,MAY_WRITE)) {
> 		iput(dir);
> 		return -EPERM;
> 	}
> 	bh = find_entry(&dir,basename,namelen,&de);
> 	if (!bh) {
> 		iput(dir);
> 		return -ENOENT;
> 	}
> 	if (!(inode = iget(dir->i_dev, de->inode))) {
> 		iput(dir);
> 		brelse(bh);
> 		return -ENOENT;
> 	}
> 	if ((dir->i_mode & S_ISVTX) && !suser() &&
> 	    current->euid != inode->i_uid &&
> 	    current->euid != dir->i_uid) {
> 		iput(dir);
> 		iput(inode);
> 		brelse(bh);
> 		return -EPERM;
> 	}
> 	if (S_ISDIR(inode->i_mode)) {
> 		iput(inode);
> 		iput(dir);
> 		brelse(bh);
> 		return -EPERM;
> 	}
> 	if (!inode->i_nlinks) {
> 		printk("Deleting nonexistent file (%04x:%d), %d\n",
> 			inode->i_dev,inode->i_num,inode->i_nlinks);
> 		inode->i_nlinks=1;
> 	}
> 	de->inode = 0;
> 	bh->b_dirt = 1;
> 	brelse(bh);
> 	inode->i_nlinks--;
> 	inode->i_dirt = 1;
> 	inode->i_ctime = CURRENT_TIME;
> 	iput(inode);
> 	iput(dir);
> 	return 0;
> }
> 
> int sys_link(const char * oldname, const char * newname)
> {
> 	struct dir_entry * de;
> 	struct m_inode * oldinode, * dir;
> 	struct buffer_head * bh;
> 	const char * basename;
> 	int namelen;
> 
> 	oldinode=namei(oldname);
> 	if (!oldinode)
> 		return -ENOENT;
> 	if (S_ISDIR(oldinode->i_mode)) {
> 		iput(oldinode);
> 		return -EPERM;
> 	}
> 	dir = dir_namei(newname,&namelen,&basename);
> 	if (!dir) {
> 		iput(oldinode);
> 		return -EACCES;
> 	}
> 	if (!namelen) {
> 		iput(oldinode);
> 		iput(dir);
> 		return -EPERM;
> 	}
> 	if (dir->i_dev != oldinode->i_dev) {
> 		iput(dir);
> 		iput(oldinode);
> 		return -EXDEV;
> 	}
> 	if (!permission(dir,MAY_WRITE)) {
> 		iput(dir);
> 		iput(oldinode);
> 		return -EACCES;
> 	}
> 	bh = find_entry(&dir,basename,namelen,&de);
> 	if (bh) {
> 		brelse(bh);
> 		iput(dir);
> 		iput(oldinode);
> 		return -EEXIST;
> 	}
> 	bh = add_entry(dir,basename,namelen,&de);
> 	if (!bh) {
> 		iput(dir);
> 		iput(oldinode);
> 		return -ENOSPC;
> 	}
> 	de->inode = oldinode->i_num;
> 	bh->b_dirt = 1;
> 	brelse(bh);
> 	iput(dir);
> 	oldinode->i_nlinks++;
> 	oldinode->i_ctime = CURRENT_TIME;
> 	oldinode->i_dirt = 1;
> 	iput(oldinode);
> 	return 0;
> }
> 
> ```

###### ll_rw_blk：读写块设备的底层驱动程序，被bread调用读取数据，被sync调用回写覆盖磁盘数据，iget使用bread读数据，iput使用sync_dev回写i节点到磁盘

> 内核管理块设备的数据结构是块设备表和请求项队列，块设备结构体blk_dev_struct和请求项结构体request在include/blk_dev/blk.h中定义。块设备表和请求项队列组成一个数组链表结构，他的结构见下图，
>
> ![Screenshot 2022-10-21 023240](实验\1 操作系统实验\实验8 虚拟文件系统的实现\Screenshot 2022-10-21 023240.png)
>
> ```c
> // include/blk_drv.h，定义了块设备结构体，块设备表，请求项结构体，请求项表，组织块设备表和请求项表构成数组链表结构
> // include/chr_drv.h, 定义了字符设备结构体，字符设备表
> 
> #ifndef _BLK_H
> #define _BLK_H
> 
> #define NR_BLK_DEV	7
> /*
>  * NR_REQUEST is the number of entries in the request-queue.
>  * NOTE that writes may use only the low 2/3 of these: reads
>  * take precedence.
>  *
>  * 32 seems to be a reasonable number: enough to get some benefit
>  * from the elevator-mechanism, but not so much as to lock a lot of
>  * buffers when they are in the queue. 64 seems to be too many (easily
>  * long pauses in reading when heavy writing/syncing is going on)
>  */
> #define NR_REQUEST	32
> 
> /*
>  * Ok, this is an expanded form so that we can use the same
>  * request for paging requests when that is implemented. In
>  * paging, 'bh' is NULL, and 'waiting' is used to wait for
>  * read/write completion.
>  */
> struct request {
> 	int dev;		/* -1 if no request */				//请求项请求读写的设备号。
> 	int cmd;		/* READ or WRITE */					//读或写命令
> 	int errors;											//执行的错误数
> 	unsigned long sector;								//起始扇区号
> 	unsigned long nr_sectors;							//读写扇区数
> 	char * buffer;										//数据缓冲区（磁盘一次读写一个扇区，而一个数据块不仅一个扇区，需要缓冲
>     													//区缓冲，当读磁盘的时候每读完一个扇区会放到缓冲区中，磁盘发出磁盘
>     													//读中断，读中断会将缓冲区拷贝到内核缓冲块，如果还有扇区没有读完会
>     													//继续，否则会唤醒阻塞在本请求项的进程和唤醒一个阻塞在磁盘等待队列
>     													//的进程，执行下一个请求项。
> 	struct task_struct * waiting;						//等待该请求项的进程
> 	struct buffer_head * bh;							//缓冲块头指针
> 	struct request * next;								//下一个请求项
> };
> extern struct request request[NR_REQUEST];				//请求项队列
> struct blk_dev_struct {
> 	void (*request_fn)(void);							//设备操作函数（根据请求想的cmd来判断操作函数是读还是写）
> 	struct request * current_request;					//请求项指针
> };						
> extern struct blk_dev_struct blk_dev[NR_BLK_DEV];		//块设备表
> extern struct task_struct * wait_for_request;			//等待设备的进程
> 
> /*
>  * This is used in the elevator algorithm: Note that
>  * reads always go before writes. This is natural: reads
>  * are much more time-critical than writes.
>  */
> #define IN_ORDER(s1,s2) \
> ((s1)->cmd<(s2)->cmd || ((s1)->cmd==(s2)->cmd && \
> ((s1)->dev < (s2)->dev || ((s1)->dev == (s2)->dev && \
> (s1)->sector < (s2)->sector))))
> 
> #ifdef MAJOR_NR
> 
> /*
>  * Add entries as needed. Currently the only block devices
>  * supported are hard-disks and floppies.
>  */
> 
> #if (MAJOR_NR == 1)
> /* ram disk */
> #define DEVICE_NAME "ramdisk"
> #define DEVICE_REQUEST do_rd_request
> #define DEVICE_NR(device) ((device) & 7)
> #define DEVICE_ON(device) 
> #define DEVICE_OFF(device)
> 
> #elif (MAJOR_NR == 2)
> /* floppy */
> #define DEVICE_NAME "floppy"
> #define DEVICE_INTR do_floppy
> #define DEVICE_REQUEST do_fd_request
> #define DEVICE_NR(device) ((device) & 3)
> #define DEVICE_ON(device) floppy_on(DEVICE_NR(device))
> #define DEVICE_OFF(device) floppy_off(DEVICE_NR(device))
> 
> #elif (MAJOR_NR == 3)
> /* harddisk */
> #define DEVICE_NAME "harddisk"
> #define DEVICE_INTR do_hd
> #define DEVICE_REQUEST do_hd_request
> #define DEVICE_NR(device) (MINOR(device)/5)
> #define DEVICE_ON(device)
> #define DEVICE_OFF(device)
> 
> #elif
> /* unknown blk device */
> #error "unknown blk device"
> 
> #endif
> 
> #define CURRENT (blk_dev[MAJOR_NR].current_request)
> #define CURRENT_DEV DEVICE_NR(CURRENT->dev)
> 
> #ifdef DEVICE_INTR
> void (*DEVICE_INTR)(void) = NULL;
> #endif
> static void (DEVICE_REQUEST)(void);
> 
> static inline void unlock_buffer(struct buffer_head * bh)
> {
> 	if (!bh->b_lock)
> 		printk(DEVICE_NAME ": free buffer being unlocked\n");
> 	bh->b_lock=0;
> 	wake_up(&bh->b_wait);
> }
> 
> static inline void end_request(int uptodate)
> {
> 	DEVICE_OFF(CURRENT->dev);
> 	if (CURRENT->bh) {
> 		CURRENT->bh->b_uptodate = uptodate;
> 		unlock_buffer(CURRENT->bh);
> 	}
> 	if (!uptodate) {
> 		printk(DEVICE_NAME " I/O error\n\r");
> 		printk("dev %04x, block %d\n\r",CURRENT->dev,
> 			CURRENT->bh->b_blocknr);
> 	}
> 	wake_up(&CURRENT->waiting);
> 	wake_up(&wait_for_request);
> 	CURRENT->dev = -1;
> 	CURRENT = CURRENT->next;
> }
> 
> #define INIT_REQUEST \
> repeat: \
> 	if (!CURRENT) \
> 		return; \
> 	if (MAJOR(CURRENT->dev) != MAJOR_NR) \
> 		panic(DEVICE_NAME ": request list destroyed"); \
> 	if (CURRENT->bh) { \
> 		if (!CURRENT->bh->b_lock) \
> 			panic(DEVICE_NAME ": block not locked"); \
> 	}
> 
> #endif
> 
> #endif
> ```
>
> ll_rw_blk函数根据块设备号和逻辑块号和读写命令组织起一个请求项，检查请求项列表是否有空间存放，如果没有那么进程阻塞到块设备阻塞队列wait_request上。否则，将请求项添加到请求项队列中去，这个添加按照电梯调度算法添加，目的是减少磁头移动次数。如果添加请求项的位置是头节点，那么直接执行这个请求项的操作函数request_fn，对于磁盘来说，这个操作函数是do_hd_request，定义在kernel/blk_drv/hd.c中，执行磁盘操作函数的时候，进程给磁盘控制器传递参数和控制命令，然后自己阻塞到请求项的阻塞队列上。当磁盘控制器读写完一个扇区之后，触发磁盘中断，分为磁盘读中断和磁盘写中断，如果是磁盘都终端read_intr，他会把请求项缓冲区的一个扇区数据拷贝到内核缓冲区，然后检查有没有还有数据，如果还有会继续读数据到请求项缓冲区，然后触发读中断，知道所有扇区读完，读中断会唤醒阻塞在这个请求项和阻塞在磁盘上的进程；如果是写磁盘，进程调用do_hd_request之后会项控制器传递参数和写磁盘控制命令，然后阻塞自己到请求项阻塞队列中，磁盘控制器在写完一个扇区之后会发生写中断，发现还有数据要写会继续调用写磁盘，直到缓冲块数据写完到磁盘。读写磁盘中断完成的最后，是唤醒阻塞在请求项的进程和阻塞在磁盘上的进程，之后删除这个请求项，执行下一个请求项的。在执行do_hd_request的开头是锁定内核缓冲块（在缓冲块头设置锁标志），如果发现是写磁盘并且文件没有修改或读磁盘但是文件被更新，那么说明这个缓冲块可以直接用，直接返回，否则才会触发磁盘读写函数do_hd_request.
>
> ```
> //ll_rw_request.c
> /*
>  *  linux/kernel/blk_dev/ll_rw.c
>  *
>  * (C) 1991 Linus Torvalds
>  */
> 
> /*
>  * This handles all read/write requests to block devices
>  */
> #include <errno.h>
> #include <linux/sched.h>
> #include <linux/kernel.h>
> #include <asm/system.h>
> 
> #include "blk.h"
> 
> /*
>  * The request-struct contains all necessary data
>  * to load a nr of sectors into memory
>  */
> struct request request[NR_REQUEST];
> 
> /*
>  * used to wait on when there are no free requests
>  */
> struct task_struct * wait_for_request = NULL;
> 
> /* blk_dev_struct is:
>  *	do_request-address
>  *	next-request
>  */
> struct blk_dev_struct blk_dev[NR_BLK_DEV] = {
> 	{ NULL, NULL },		/* no_dev */
> 	{ NULL, NULL },		/* dev mem */
> 	{ NULL, NULL },		/* dev fd */
> 	{ NULL, NULL },		/* dev hd */
> 	{ NULL, NULL },		/* dev ttyx */
> 	{ NULL, NULL },		/* dev tty */
> 	{ NULL, NULL }		/* dev lp */
> };
> 
> static inline void lock_buffer(struct buffer_head * bh)
> {
> 	cli();
> 	while (bh->b_lock)
> 		sleep_on(&bh->b_wait);
> 	bh->b_lock=1;
> 	sti();
> }
> 
> static inline void unlock_buffer(struct buffer_head * bh)
> {
> 	if (!bh->b_lock)
> 		printk("ll_rw_block.c: buffer not locked\n\r");
> 	bh->b_lock = 0;
> 	wake_up(&bh->b_wait);
> }
> 
> /*
>  * add-request adds a request to the linked list.
>  * It disables interrupts so that it can muck with the
>  * request-lists in peace.
>  */
> static void add_request(struct blk_dev_struct * dev, struct request * req)
> {
> 	struct request * tmp;
> 
> 	req->next = NULL;
> 	cli();
> 	if (req->bh)
> 		req->bh->b_dirt = 0;
> 	if (!(tmp = dev->current_request)) {
> 		dev->current_request = req;
> 		sti();
> 		(dev->request_fn)();
> 		return;
> 	}
> 	for ( ; tmp->next ; tmp=tmp->next)
> 		if ((IN_ORDER(tmp,req) || 
> 		    !IN_ORDER(tmp,tmp->next)) &&
> 		    IN_ORDER(req,tmp->next))
> 			break;
> 	req->next=tmp->next;
> 	tmp->next=req;
> 	sti();
> }
> 
> static void make_request(int major,int rw, struct buffer_head * bh)
> {
> 	struct request * req;
> 	int rw_ahead;
> 
> /* WRITEA/READA is special case - it is not really needed, so if the */
> /* buffer is locked, we just forget about it, else it's a normal read */
> 	if ((rw_ahead = (rw == READA || rw == WRITEA))) {
> 		if (bh->b_lock)
> 			return;
> 		if (rw == READA)
> 			rw = READ;
> 		else
> 			rw = WRITE;
> 	}
> 	if (rw!=READ && rw!=WRITE)
> 		panic("Bad block dev command, must be R/W/RA/WA");
> 	lock_buffer(bh);
> 	if ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {
> 		unlock_buffer(bh);
> 		return;
> 	}
> repeat:
> /* we don't allow the write-requests to fill up the queue completely:
>  * we want some room for reads: they take precedence. The last third
>  * of the requests are only for reads.
>  */
> 	if (rw == READ)
> 		req = request+NR_REQUEST;
> 	else
> 		req = request+((NR_REQUEST*2)/3);
> /* find an empty request */
> 	while (--req >= request)
> 		if (req->dev<0)
> 			break;
> /* if none found, sleep on new requests: check for rw_ahead */
> 	if (req < request) {
> 		if (rw_ahead) {
> 			unlock_buffer(bh);
> 			return;
> 		}
> 		sleep_on(&wait_for_request);
> 		goto repeat;
> 	}
> /* fill up the request-info, and add it to the queue */
> 	req->dev = bh->b_dev;
> 	req->cmd = rw;
> 	req->errors=0;
> 	req->sector = bh->b_blocknr<<1;
> 	req->nr_sectors = 2;
> 	req->buffer = bh->b_data;
> 	req->waiting = NULL;
> 	req->bh = bh;
> 	req->next = NULL;
> 	add_request(major+blk_dev,req);
> }
> 
> void ll_rw_block(int rw, struct buffer_head * bh)
> {
> 	unsigned int major;
> 
> 	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
> 	!(blk_dev[major].request_fn)) {
> 		printk("Trying to read nonexistent block-device\n\r");
> 		return;
> 	}
> 	make_request(major,rw,bh);
> }
> 
> void blk_dev_init(void)
> {
> 	int i;
> 
> 	for (i=0 ; i<NR_REQUEST ; i++) {
> 		request[i].dev = -1;
> 		request[i].next = NULL;
> 	}
> }
> ```
>
> ```
> //hd.c
> /*
>  *  linux/kernel/hd.c
>  *
>  *  (C) 1991  Linus Torvalds
>  */
> 
> /*
>  * This is the low-level hd interrupt support. It traverses the
>  * request-list, using interrupts to jump between functions. As
>  * all the functions are called within interrupts, we may not
>  * sleep. Special care is recommended.
>  * 
>  *  modified by Drew Eckhardt to check nr of hd's from the CMOS.
>  */
> 
> #include <linux/config.h>
> #include <linux/sched.h>
> #include <linux/fs.h>
> #include <linux/kernel.h>
> #include <linux/hdreg.h>
> #include <asm/system.h>
> #include <asm/io.h>
> #include <asm/segment.h>
> 
> #define MAJOR_NR 3
> #include "blk.h"
> 
> #define CMOS_READ(addr) ({ \
> outb_p(0x80|addr,0x70); \
> inb_p(0x71); \
> })
> 
> /* Max read/write errors/sector */
> #define MAX_ERRORS	7
> #define MAX_HD		2
> 
> static void recal_intr(void);
> 
> static int recalibrate = 1;
> static int reset = 1;
> 
> /*
>  *  This struct defines the HD's and their types.
>  */
> struct hd_i_struct {
> 	int head,sect,cyl,wpcom,lzone,ctl;
> 	};
> #ifdef HD_TYPE
> struct hd_i_struct hd_info[] = { HD_TYPE };
> #define NR_HD ((sizeof (hd_info))/(sizeof (struct hd_i_struct)))
> #else
> struct hd_i_struct hd_info[] = { {0,0,0,0,0,0},{0,0,0,0,0,0} };
> static int NR_HD = 0;
> #endif
> 
> static struct hd_struct {
> 	long start_sect;
> 	long nr_sects;
> } hd[5*MAX_HD]={{0,0},};
> 
> #define port_read(port,buf,nr) \
> __asm__("cld;rep;insw"::"d" (port),"D" (buf),"c" (nr))
> 
> #define port_write(port,buf,nr) \
> __asm__("cld;rep;outsw"::"d" (port),"S" (buf),"c" (nr))
> 
> extern void hd_interrupt(void);
> extern void rd_load(void);
> 
> /* This may be used only once, enforced by 'static int callable' */
> int sys_setup(void * BIOS)
> {
> 	static int callable = 1;
> 	int i,drive;
> 	unsigned char cmos_disks;
> 	struct partition *p;
> 	struct buffer_head * bh;
> 
> 	if (!callable)
> 		return -1;
> 	callable = 0;
> #ifndef HD_TYPE
> 	for (drive=0 ; drive<2 ; drive++) {
> 		hd_info[drive].cyl = *(unsigned short *) BIOS;
> 		hd_info[drive].head = *(unsigned char *) (2+BIOS);
> 		hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);
> 		hd_info[drive].ctl = *(unsigned char *) (8+BIOS);
> 		hd_info[drive].lzone = *(unsigned short *) (12+BIOS);
> 		hd_info[drive].sect = *(unsigned char *) (14+BIOS);
> 		BIOS += 16;
> 	}
> 	if (hd_info[1].cyl)
> 		NR_HD=2;
> 	else
> 		NR_HD=1;
> #endif
> 	for (i=0 ; i<NR_HD ; i++) {
> 		hd[i*5].start_sect = 0;
> 		hd[i*5].nr_sects = hd_info[i].head*
> 				hd_info[i].sect*hd_info[i].cyl;
> 	}
> 
> 	/*
> 		We querry CMOS about hard disks : it could be that 
> 		we have a SCSI/ESDI/etc controller that is BIOS
> 		compatable with ST-506, and thus showing up in our
> 		BIOS table, but not register compatable, and therefore
> 		not present in CMOS.
> 
> 		Furthurmore, we will assume that our ST-506 drives
> 		<if any> are the primary drives in the system, and 
> 		the ones reflected as drive 1 or 2.
> 
> 		The first drive is stored in the high nibble of CMOS
> 		byte 0x12, the second in the low nibble.  This will be
> 		either a 4 bit drive type or 0xf indicating use byte 0x19 
> 		for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.
> 
> 		Needless to say, a non-zero value means we have 
> 		an AT controller hard disk for that drive.
> 
> 		
> 	*/
> 
> 	if ((cmos_disks = CMOS_READ(0x12)) & 0xf0)
> 		if (cmos_disks & 0x0f)
> 			NR_HD = 2;
> 		else
> 			NR_HD = 1;
> 	else
> 		NR_HD = 0;
> 	for (i = NR_HD ; i < 2 ; i++) {
> 		hd[i*5].start_sect = 0;
> 		hd[i*5].nr_sects = 0;
> 	}
> 	for (drive=0 ; drive<NR_HD ; drive++) {
> 		if (!(bh = bread(0x300 + drive*5,0))) {
> 			printk("Unable to read partition table of drive %d\n\r",
> 				drive);
> 			panic("");
> 		}
> 		if (bh->b_data[510] != 0x55 || (unsigned char)
> 		    bh->b_data[511] != 0xAA) {
> 			printk("Bad partition table on drive %d\n\r",drive);
> 			panic("");
> 		}
> 		p = 0x1BE + (void *)bh->b_data;
> 		for (i=1;i<5;i++,p++) {
> 			hd[i+5*drive].start_sect = p->start_sect;
> 			hd[i+5*drive].nr_sects = p->nr_sects;
> 		}
> 		brelse(bh);
> 	}
> 	if (NR_HD)
> 		printk("Partition table%s ok.\n\r",(NR_HD>1)?"s":"");
> 	rd_load();
> 	mount_root();
> 	return (0);
> }
> 
> static int controller_ready(void)
> {
> 	int retries=10000;
> 
> 	while (--retries && (inb_p(HD_STATUS)&0xc0)!=0x40);
> 	return (retries);
> }
> 
> static int win_result(void)
> {
> 	int i=inb_p(HD_STATUS);
> 
> 	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
> 		== (READY_STAT | SEEK_STAT))
> 		return(0); /* ok */
> 	if (i&1) i=inb(HD_ERROR);
> 	return (1);
> }
> 
> static void hd_out(unsigned int drive,unsigned int nsect,unsigned int sect,
> 		unsigned int head,unsigned int cyl,unsigned int cmd,
> 		void (*intr_addr)(void))
> {
> 	register int port asm("dx");
> 
> 	if (drive>1 || head>15)
> 		panic("Trying to write bad sector");
> 	if (!controller_ready())
> 		panic("HD controller not ready");
> 	do_hd = intr_addr;
> 	outb_p(hd_info[drive].ctl,HD_CMD);
> 	port=HD_DATA;
> 	outb_p(hd_info[drive].wpcom>>2,++port);
> 	outb_p(nsect,++port);
> 	outb_p(sect,++port);
> 	outb_p(cyl,++port);
> 	outb_p(cyl>>8,++port);
> 	outb_p(0xA0|(drive<<4)|head,++port);
> 	outb(cmd,++port);
> }
> 
> static int drive_busy(void)
> {
> 	unsigned int i;
> 
> 	for (i = 0; i < 10000; i++)
> 		if (READY_STAT == (inb_p(HD_STATUS) & (BUSY_STAT|READY_STAT)))
> 			break;
> 	i = inb(HD_STATUS);
> 	i &= BUSY_STAT | READY_STAT | SEEK_STAT;
> 	if (i == (READY_STAT | SEEK_STAT))
> 		return(0);
> 	printk("HD controller times out\n\r");
> 	return(1);
> }
> 
> static void reset_controller(void)
> {
> 	int	i;
> 
> 	outb(4,HD_CMD);
> 	for(i = 0; i < 100; i++) nop();
> 	outb(hd_info[0].ctl & 0x0f ,HD_CMD);
> 	if (drive_busy())
> 		printk("HD-controller still busy\n\r");
> 	if ((i = inb(HD_ERROR)) != 1)
> 		printk("HD-controller reset failed: %02x\n\r",i);
> }
> 
> static void reset_hd(int nr)
> {
> 	reset_controller();
> 	hd_out(nr,hd_info[nr].sect,hd_info[nr].sect,hd_info[nr].head-1,
> 		hd_info[nr].cyl,WIN_SPECIFY,&recal_intr);
> }
> 
> void unexpected_hd_interrupt(void)
> {
> 	printk("Unexpected HD interrupt\n\r");
> }
> 
> static void bad_rw_intr(void)
> {
> 	if (++CURRENT->errors >= MAX_ERRORS)
> 		end_request(0);
> 	if (CURRENT->errors > MAX_ERRORS/2)
> 		reset = 1;
> }
> 
> static void read_intr(void)
> {
> 	if (win_result()) {
> 		bad_rw_intr();
> 		do_hd_request();
> 		return;
> 	}
> 	port_read(HD_DATA,CURRENT->buffer,256);
> 	CURRENT->errors = 0;
> 	CURRENT->buffer += 512;
> 	CURRENT->sector++;
> 	if (--CURRENT->nr_sectors) {
> 		do_hd = &read_intr;
> 		return;
> 	}
> 	end_request(1);
> 	do_hd_request();
> }
> 
> static void write_intr(void)
> {
> 	if (win_result()) {
> 		bad_rw_intr();
> 		do_hd_request();
> 		return;
> 	}
> 	if (--CURRENT->nr_sectors) {
> 		CURRENT->sector++;
> 		CURRENT->buffer += 512;
> 		do_hd = &write_intr;
> 		port_write(HD_DATA,CURRENT->buffer,256);
> 		return;
> 	}
> 	end_request(1);
> 	do_hd_request();
> }
> 
> static void recal_intr(void)
> {
> 	if (win_result())
> 		bad_rw_intr();
> 	do_hd_request();
> }
> 
> void do_hd_request(void)
> {
> 	int i,r = 0;
> 	unsigned int block,dev;
> 	unsigned int sec,head,cyl;
> 	unsigned int nsect;
> 
> 	INIT_REQUEST;
> 	dev = MINOR(CURRENT->dev);
> 	block = CURRENT->sector;
> 	if (dev >= 5*NR_HD || block+2 > hd[dev].nr_sects) {
> 		end_request(0);
> 		goto repeat;
> 	}
> 	block += hd[dev].start_sect;
> 	dev /= 5;
> 	__asm__("divl %4":"=a" (block),"=d" (sec):"0" (block),"1" (0),
> 		"r" (hd_info[dev].sect));
> 	__asm__("divl %4":"=a" (cyl),"=d" (head):"0" (block),"1" (0),
> 		"r" (hd_info[dev].head));
> 	sec++;
> 	nsect = CURRENT->nr_sectors;
> 	if (reset) {
> 		reset = 0;
> 		recalibrate = 1;
> 		reset_hd(CURRENT_DEV);
> 		return;
> 	}
> 	if (recalibrate) {
> 		recalibrate = 0;
> 		hd_out(dev,hd_info[CURRENT_DEV].sect,0,0,0,
> 			WIN_RESTORE,&recal_intr);
> 		return;
> 	}	
> 	if (CURRENT->cmd == WRITE) {
> 		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&write_intr);
> 		for(i=0 ; i<3000 && !(r=inb_p(HD_STATUS)&DRQ_STAT) ; i++)
> 			/* nothing */ ;
> 		if (!r) {
> 			bad_rw_intr();
> 			goto repeat;
> 		}
> 		port_write(HD_DATA,CURRENT->buffer,256);
> 	} else if (CURRENT->cmd == READ) {
> 		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);
> 	} else
> 		panic("unknown hd-command");
> }
> 
> void hd_init(void)
> {
> 	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
> 	set_intr_gate(0x2E,&hd_interrupt);
> 	outb_p(inb_p(0x21)&0xfb,0x21);
> 	outb(inb_p(0xA1)&0xbf,0xA1);
> }
> ```

##### 执行可执行文件系统调用exec



#### 网络管理(网卡字符设备; TCP/IP,HTTP, socket)

Linux网络管理是基于设备管理的网络设备管理的。类似于文件系统管理，文件系统管理提供了文件系统调用，他是基于磁盘设备管理的。磁盘管理提供了底层数据的存储，而文件系统基于底层数据的存储的内核函数设计了文件相关的系统调用；同样，Linux网络管理系统调用也是基于字符设备网络设备的读写内核函数实现的；控制台IO系统调用底层实现内核函数是控制台设备读写函数tty_read/tty_write/keyboard_interrupt/con_write等完成的，普通文件系统调用底层实现函数是file_read/file_write，管道文件底层实现内核函数是pipe_read/pipe_write，块设备读写函数blk_read/blk_write，同样网络设备读写内核底层函数是网络设备读写函数，这些涉及到外部设备（控制台/键盘，网卡，磁盘）的读写函数因为要等待外部设备资源服务，基本都需要阻塞在读写函数内。网络管理系统调用socket/connect/

#### 控制台设备(键盘/显示器字符设备; scanf/printf)

控制台字符设备（键盘显示器）提供scanf/printf的底层调用函数操作键盘和显示器。

### 其他不重要的

#### Linux操作系统启动

实验1-Linux操作系统启动

**Linux操作系统启动**

计算机加电启动执行BIOS提供的自检程序，加载BIOS中断到中断向量表中，然后执行BIOS操作系统启动中断，转入操作系统启动；Linux操作系统启动，会先调用boot/bootsect.s, boot/setup.s, boot/head.c等程序设置内存结构，将内存结构划分为内核区、缓冲区、虚拟盘区、主存区，设置内核区地址划分（页目录表4k一页，页表4K*4页，head.c部分代码，中断描述符表2k，全局秒描述符表2k，init/main.c代码，kernel代码，mm代码，fs代码，lib代码）。然后调用init/main.c函数执行系统初始化和进程0，1，2的创建工作，init/main.c前部分执行代码是处于进程0的内核态，当使用move_to_user_mode之后进入进程0的用户态执行，在任务0的内核态时，会调用进程初始化，内存初始化，设备初始化（字符设备，块设备，控制台初始化，磁盘初始化hd_init）等初始化工作，在进程初始化过程中，会设置进程0任务数据结构（任务0任务数据结构的数据被宏定义在sched.h中），设置任务0数据结构的数据段在内核0地址开始处，设置任务0用户空间在user_stack处(内核内存kernel/sche.c的那个部分)，任务0进程的线性地址空间0-640K，内核地址空间0-16M，内核代码在0-4M之间，end-16M之间分配内核缓冲区。

init/main.c初始化设置完成之后move_to_user_mode进入任务0用户态执行，处在用户态的任务0会使用内嵌fork系统调用创建任务1执行init函数，任务1的init函数会加载磁盘文件系统并且打开stdin，stdout，stderr三个标准输入输出错误输出文件，最后创建任务2调用execve系统调用加载并执行shell程序，进程1等待任务2的执行完毕。任务2执行完毕以后任务1循环继续创建任务2加载shell程序执行。

任务0在创建任务1进程后的代码时执行一个循环**while(1) pause**不断调用pause系统调用刺激调度程序调度。

init/main.c执行的过程加下图和下面代码

![Screenshot 2022-10-21 151411](实验\1 操作系统实验\实验8 虚拟文件系统的实现\Screenshot 2022-10-21 151411.png)

```c
/*
 *  linux/init/main.c
 *
 *  (C) 1991  Linus Torvalds
 */

#define __LIBRARY__
#include <unistd.h>
#include <time.h>

/*
 * we need this inline - forking from kernel space will result
 * in NO COPY ON WRITE (!!!), until an execve is executed. This
 * is no problem, but for the stack. This is handled by not letting
 * main() use the stack at all after fork(). Thus, no function
 * calls - which means inline code for fork too, as otherwise we
 * would use the stack upon exit from 'fork()'.
 *
 * Actually only pause and fork are needed inline, so that there
 * won't be any messing with the stack from main(), but we define
 * some others too.
 */
static inline _syscall0(int,fork)
static inline _syscall0(int,pause)
static inline _syscall1(int,setup,void *,BIOS)
static inline _syscall0(int,sync)

/*新增mkdir和mknode系统调用*/
_syscall2(int,mkdir,const char*,name,mode_t,mode)
_syscall3(int,mknod,const char *,filename,mode_t,mode,dev_t,dev)
    

#include <linux/tty.h>
#include <linux/sched.h>
#include <linux/head.h>
#include <asm/system.h>
#include <asm/io.h>

#include <stddef.h>
#include <stdarg.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

#include <linux/fs.h>

static char printbuf[1024];

extern int vsprintf();
extern void init(void);
extern void blk_dev_init(void);
extern void chr_dev_init(void);
extern void hd_init(void);
extern void floppy_init(void);
extern void mem_init(long start, long end);
extern long rd_init(long mem_start, int length);
extern long kernel_mktime(struct tm * tm);
extern long startup_time;

/*
 * This is set up by the setup-routine at boot-time
 */
#define EXT_MEM_K (*(unsigned short *)0x90002)
#define DRIVE_INFO (*(struct drive_info *)0x90080)
#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)

/*
 * Yeah, yeah, it's ugly, but I cannot find how to do this correctly
 * and this seems to work. I anybody has more info on the real-time
 * clock I'd be interested. Most of this was trial and error, and some
 * bios-listing reading. Urghh.
 */

#define CMOS_READ(addr) ({ \
outb_p(0x80|addr,0x70); \
inb_p(0x71); \
})

#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)

static void time_init(void)
{
	struct tm time;

	do {
		time.tm_sec = CMOS_READ(0);
		time.tm_min = CMOS_READ(2);
		time.tm_hour = CMOS_READ(4);
		time.tm_mday = CMOS_READ(7);
		time.tm_mon = CMOS_READ(8);
		time.tm_year = CMOS_READ(9);
	} while (time.tm_sec != CMOS_READ(0));
	BCD_TO_BIN(time.tm_sec);
	BCD_TO_BIN(time.tm_min);
	BCD_TO_BIN(time.tm_hour);
	BCD_TO_BIN(time.tm_mday);
	BCD_TO_BIN(time.tm_mon);
	BCD_TO_BIN(time.tm_year);
	time.tm_mon--;
	startup_time = kernel_mktime(&time);
}

static long memory_end = 0;
static long buffer_memory_end = 0;
static long main_memory_start = 0;

struct drive_info { char dummy[32]; } drive_info;

void main(void)		/* This really IS void, no error here. */
{			/* The startup routine assumes (well, ...) this */
/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
 	ROOT_DEV = ORIG_ROOT_DEV;
 	drive_info = DRIVE_INFO;
	memory_end = (1<<20) + (EXT_MEM_K<<10);
	memory_end &= 0xfffff000;
	if (memory_end > 16*1024*1024)
		memory_end = 16*1024*1024;
	if (memory_end > 12*1024*1024) 
		buffer_memory_end = 4*1024*1024;
	else if (memory_end > 6*1024*1024)
		buffer_memory_end = 2*1024*1024;
	else
		buffer_memory_end = 1*1024*1024;
	main_memory_start = buffer_memory_end;
#ifdef RAMDISK
	main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
#endif
	mem_init(main_memory_start,memory_end);
	trap_init();
	blk_dev_init();
	chr_dev_init();
	tty_init();
	time_init();
	sched_init();
	buffer_init(buffer_memory_end);
	hd_init();
	floppy_init();
	sti();
	move_to_user_mode();
	if (!fork()) {		/* we count on this going ok */
		init();
	}
/*
 *   NOTE!!   For any other task 'pause()' would mean we have to get a
 * signal to awaken, but task0 is the sole exception (see 'schedule()')
 * as task 0 gets activated at every idle moment (when no other tasks
 * can run). For task0 'pause()' just means we go check if some other
 * task can run, and if not we return here.
 */
	for(;;) pause();
}

static int printf(const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
	write(1,printbuf,i=vsprintf(printbuf, fmt, args));
	va_end(args);
	return i;
}

static char * argv_rc[] = { "/bin/sh", NULL };
static char * envp_rc[] = { "HOME=/", NULL };

static char * argv[] = { "-/bin/sh",NULL };
static char * envp[] = { "HOME=/usr/root", NULL };

void init(void)
{
	int pid,i;

	setup((void *) &drive_info);
	(void) open("/dev/tty0",O_RDWR,0);
	(void) dup(0);
	(void) dup(0);
	
	mkdir("/proc",0755);
	mknod("/proc/psinfo",S_IFPROC|0444,0);
	mknod("/proc/hdinfo",S_IFPROC|0444,1);
	mknod("/proc/inodeinfo",S_IFPROC|0444,2);

	printf("%d buffers = %d bytes buffer space\n\r",NR_BUFFERS,
		NR_BUFFERS*BLOCK_SIZE);
	printf("Free mem: %d bytes\n\r",memory_end-main_memory_start);
	if (!(pid=fork())) {
		close(0);
		if (open("/etc/rc",O_RDONLY,0))
			_exit(1);
		execve("/bin/sh",argv_rc,envp_rc);
		_exit(2);
	}
	if (pid>0)
		while (pid != wait(&i))
			/* nothing */;
	while (1) {
		if ((pid=fork())<0) {
			printf("Fork failed in init\r\n");
			continue;
		}
		if (!pid) {
			close(0);close(1);close(2);
			setsid();
			(void) open("/dev/tty0",O_RDWR,0);
			(void) dup(0);
			(void) dup(0);
			_exit(execve("/bin/sh",argv,envp));
		}
		while (1)
			if (pid == wait(&i))
				break;
		printf("\n\rchild %d died with code %04x\n\r",pid,i);
		sync();
	}
	_exit(0);	/* NOTE! _exit, not exit() */
}
```

#### Linux系统调用编写

实验2-编写系统调用

- **系统控制系统调用**

  | ioctl            | I/O总控制函数                            |
  | ---------------- | ---------------------------------------- |
  | _sysctl          | 读/写系统参数                            |
  | acct             | 启用或禁止进程记账                       |
  | getrlimit        | 获取系统资源上限                         |
  | setrlimit        | 设置系统资源上限                         |
  | getrusage        | 获取系统资源使用情况                     |
  | uselib           | 选择要使用的二进制函数库                 |
  | ioperm           | 设置端口I/O权限                          |
  | iopl             | 改变进程I/O权限级别                      |
  | outb             | 低级端口操作                             |
  | reboot           | 重新启动                                 |
  | swapon           | 打开交换文件和设备                       |
  | swapoff          | 关闭交换文件和设备                       |
  | bdflush          | 控制bdflush守护进程                      |
  | sysfs            | 取核心支持的文件系统类型                 |
  | sysinfo          | 取得系统信息                             |
  | adjtimex         | 调整系统时钟                             |
  | alarm            | 设置进程的闹钟                           |
  | getitimer        | 获取计时器值                             |
  | setitimer        | 设置计时器值                             |
  | gettimeofday     | 取时间和时区                             |
  | settimeofday     | 设置时间和时区                           |
  | stime            | 设置系统日期和时间                       |
  | time             | 取得系统时间                             |
  | times            | 取进程运行时间                           |
  | uname            | 获取当前UNIX系统的名称、版本和主机等信息 |
  | vhangup          | 挂起当前终端                             |
  | nfsservctl       | 对NFS守护进程进行控制                    |
  | vm86             | 进入模拟8086模式                         |
  | create_module    | 创建可装载的模块项                       |
  | delete_module    | 删除可装载的模块项                       |
  | init_module      | 初始化模块                               |
  | query_module     | 查询模块信息                             |
  | *get_kernel_syms | 取得核心符号,已被query_module代替        |

#### Linux向C程序提供的服务

C语言程序执行需要的服务主要又两种，一种时编译器提供的将C语言转换成对应的汇编语言和可执行程序，一种是Linxu对可执行程序的系统调用支持。编译器服务主要是对C语言关键字的解析和翻译成汇编语言，比如对存储类型分配数据区内存和栈区内存，使用变量的逻辑地址替换指令中的符号变量，使用Linux或者其他C语言函数库替换C原因指令翻译成汇编指令，对指令的翻译重点有循环结构的翻译、条件语句的翻译、函数调用的翻译。Linxu对C语言程序提供的系统调用支持主要分为五个模块: **进程系统调用-fork/vfork/wait/waitpid/pause/(sleep)/信号/信号量/共享内存/消息队列/管道、内存系统调用-malloc堆区分配内存、文件系统调用（Linux提供的持久化方式，可用于数据库系统持久化数据，底层是磁盘设备管理提供IO）-fopen/fscanf/fprintf/fclose/exec加载器、网络系统调用（Linux提供远程进程通信方式，底层是网卡设备管理提供IO）-socket/bind/listen/accept/connect/send(write)/recv(read)/close、控制台系统调用（控制台IO方式，底层是键盘中断和控制台设备管理读写程序tty_read/tty_write/keyboard_interrupt/con_write）-scanf/printf。**

## 进程管理 CPU管理

- 系统调用write很耗时，耗时是普通用户程序加法运算的1e6，IO指令执行非常慢。也就是IO为主的进程和计算为主的进程他们要多道程序设计的原因。后来因为多用户，引入了分时系统，这两个本质都是多进程，核心是进程调度和切换。

- 并发：一个CPU在多个程序上交替执行

  并行：多个任务在多个CPU或计算机上同时执行，每个CPU执行一个任务

  并发和并行都是为了提高CPU执行效率

- 每个任务（进程）需要一个PCB存放当前寄存器的数据和PC指针，这样才能切换任务。

- 操作系统在执行main.c的main函数时i，会初始化操作系统管理的设备，同时fork一个进程执行init()，init函数执行的是shell程序，shell程序在获得一个命令之后会fork一个进程来执行这个命令。所以任何时刻计算机系统存在main进程和shell进程，当执行用户程序的时候会创建新进程

- 操作系统组织、管理、感知进程依赖PCB，操作系统组织进程方式，就绪队列、磁盘等待队列等把进程PCB组织成一个链表

### 进程状态-怎么组织进程

新建态的进程PCB被放入就绪队列，进入就绪态；CPU调度获得这个进程之后进入执行态；执行完毕进入终止态；执行态划分时间片用完或者等待IO进入阻塞态，进入阻塞队列

- 新建态
- 就绪态
- 运行态
- 终止态
- 阻塞态

### 进程创建和切换-用户级线程、核心级线程、多进程

##### 用户级线程 

基于栈和Yield函数的线程切换

这种线程切换是用户自己管理的线程切换，而不管内核线程，是用户级线程，线程切换的Yield函数需要用户自己编写

线程TCB只包含一个栈，他不仅保存函数调用返回地址，也包含线程切换返回地址。

这种用户级线程是在用户态执行的，用户自己编写的线程切换，内核无法感知到这种线程。他的缺点是当一个线程发生IO阻塞，那么用户级线程的进程会陷入系统内核态去执行IO，造成一个线程阻塞而其他线程跟着阻塞的情况。好处是用户可以精确控制线程的切换。

所有的进程都是内核进程，因为进程需要分配资源，分配资源的工作是收到操作系统管理的，在setup.s, head.s 和main.c中初始化的功能。没有用户级进程，因为进程总是要分配资源，必须处于内核态，就只能是内核级进程。

线程切换只是切换指令PC，而不涉及切换资源。

用户级线程是并发执行的，不是并行执行的，一个线程阻塞会导致其他线程阻塞

用户级线程需要用户自己编写切换函数，实际上是一种调度算法，用户级线程可以实现用户自己调度线程，很灵活，而内核级线程是内核实现的调度算法。

- 切换过程

  用户进程包含多个线程，这些线程相互之间运用Yield函数进行切换到另外的线程，每个线程只需要拥有一个栈来保存返回地址，在切换的时候只需要从要被切换的线程的栈弹出返回地址给PC指针就行，而不需要在线程TCB中保存一个PC指针。

  ```
  //A线程
  100: A()
  101: {
  102: call B() //执行这句话会在A线程的栈esp压入103返回地址，然后PC指针跳转到200
  103: ...
  }
  200: B()
  201: {
  202: yeild C线程 //执行这句话会把203压入A线程栈esp，然后PC跳转到C线程首地址，同时CPU.esp=TCBc.esp
  203: 
  }
  
  //C线程
  300: C()
  301: {
  302: call D() //执行这句话会在C线程栈压入303，并且PC跳转到400
  303:
  }
  400: D()
  401: {
  402: yeild A线程 //执行这句话会让403压入C线程栈TCBc.esp,同时CPU.esp=TCBa.esp,同时从TCBa.esp弹出返回地址给CPU.PC
  403:
  }
  ```

- 配合上述切换过程的线程控制块TCB的创建

  ```
  void ThreadCreate(A){
  	TCB *tcb = malloc() ; //分配内存给A线程TCB
  	*stack = malloc() ; //分配栈
  	*statk = A; //把线程A的代码首地址A放入栈，CPU加载A线程TCB的时候会从TCB.esp栈指针返回线程A的程序地址。
  	tcb.esp = stack ; //tcb只包含一个栈
  }
  
  这样内存布局是:
  Yield代码区
  TCBa.esp所在的栈内存
  TCBc.esp所在的栈内存
  剩余的heap堆区
  AC线程所在进程的数据区
  AC线程所在进程的代码区，分别保存A线程代码和C线程代码
  
  在创建线程的时候实际只是创建了一个TCBa的stack指针TCBa.esp和TCBc，放到内存
  让CPU获取TCBa, CPU.esp = TCBa.esp,CPU.PC=TCBa.esp弹出的地址，这样就能执行TCBa
  当TCBa要切换到TCBc，首先让CPU.esp=TCBc.esp，然后CPU.PC = TCBc.PC，执行TCBc
  ```

##### 核心级线程

- 多处理器是多进程的基础，一个进程运行在一个处理器上，一个处理器包括内存映射表MMU、高速缓存Cache以及一个或者多个核心CPU。如果一个处理器包含多个核心CPU，那么他是多核处理器，多核处理器是多线程的基础。如果不是多处理器，俺么进程只能并发执行，如果没有多核处理器，那么线程只能并发执行。一个进程被分配给一个处理器，他的线程被分给多个核心进行并行处理

  如果系统不支持核心级线程的化，多核是没有用的，因为一个处理器被分配给一个进程，之后实现了核心级线程才能让多核共享MMU地址映射设备。

  用户级线程和多进程都不能发挥多核的效用，前者是计算机不能感知到多线程，后者是一个进程占用一个处理器。要利用多核，必须支持核心级线程

- 用户级线程使用内核级线程进行线程切换的时候需要切换两套栈，一套是用户级线程的切换，另外一套是内核级线程的切换

- 用户栈是用来利用用户程序调用，内核栈是用来支持内核函数调用，比如系统调用sys_fork会调用copy_process等内核函数，所以要添加内核栈来执行内核函数。每个用户线程要有两套栈，一个是用户栈，一个是内核栈，分别用来执行用户程序和内核程序，TCB会保存这两个栈的地址到esp和esp0.

- 核心级线程一定支持用户级线程，在创建线程的时候会调用系统中断创建用户栈和内核栈以及TCB，用户栈被压入用户程序的入口地址，TCP的esp和esp0分别指向用户栈和内核栈。当TCB被分配到CPU执行，他会初始化CPU的各个变量和count时钟，当他执行到一个系统调用的时候，调用int 0x80中断进入中断处理程序sys_...，同时把用户栈的地址放到内核栈0、1位置，把当前执行的用户代码的位置放到内核栈3、4位置，然后执行对应的系统调用。当从系统调用返回的时候，会从系统调用返回IRET，IRET会把内核栈的用户栈地址和用户代码地址重新赋值给CPU，从而实现CPU切换回用户代码。

- 当内核态的线程切换的时候，内核态的线程TCB tCur的当前执行的代码的位置放到tCur的内核栈的位置，然后从tNew的内核线程弹出另外内核线程的旧的PC值。

- 用户线程切换的是用户栈，而内核级线程切换的是内核栈，TCB只用保存一个内核栈就行。核心级线程的切换只需要切换内核栈，内核栈的顶部存放被调度时正在执行的内核函数的地址，可以内核栈顶部地址恢复内核线程PC，当执行完内核函数的时候，可以通过内核栈3、4位置恢复用户代码位置，通过0、1位置恢复用户栈位置。

- 核心级线程的切换

  ```
  TCB[cur].esp = %esp ;
  %esp=TCB[next].esp ;
  cur 的TCB入队
  
  如果设计到两个不同进程的线程的切换，还需要切换地址引射表
  TCB[cur].ldtr = %ldtr
  %ldtr = TCB[next].ldtr
  ```

- 核心级线程的创建

  ```
  ThreadCreate(){
  	TCB tcb = get_free_page(); //用户程序调用c语言库函数malloc分配内存，在内核中执行内核函数get_free_page分配内存
  							   //这里分配内存是在setup时期初始化的mem_map位图进行管理的内存，
  							   //创建tcb
  	*krlstack = get_free_page();//创建内核栈
  	*userstack用户栈地址如*krlstack的0、1位置，返回用户程序地址放入*krlstack的3、4位置
  	tcb.esp=krlstack; //tcb栈指针到内核栈指针
  	tcb入队
  }
  ```

##### 多进程系统

```c
int main(){ //打印AB进程
	if(!fork()){
		while(1){
			printf("A") ; //打印A进程
		}
	}
	if(!fork()){
		while(1){
			printf("B") ; //打印B进程
		}
	}
    wait();
}
```

在Linux系统启动的时候会启动shell

```c
int main(){
	while( cmp!= null){
		if(!fork()){
			exec(cmp) ;
		}
	}
}
```

当在shell中启动AB.exe的时候，c语言库函数会调用系统中断sys_fork来处理，sys_fork是Linux系统调用，他的方法是

```
sys_fork:
	pushl ... //创建AB京城的用户栈并把AB程序内存首地址压入用户栈，同时创建AB进程的内核栈并且内核栈的0、1地址指向AB进程用户栈					的地址，内核栈的3、4位置存放返回AB进程的返回地址
	call copy_process //创建AB进程的PCB，其中包括eip指向AB线程执行地址，esp指向用户栈，esp0指向内核栈
	ret        //返回调用c语言fork库函数的地址
```

调用fork库函数创建好AB进程的PCB之后，AB进程PCB被加入就绪队列，AB进程可以被调度

当AB进程被调度时，他创建了打印A和B进程，创建好打印A进程的用户栈和内核栈以及打印A和B进程PCB。之后AB进程调用c语言库函数wait，这个库函数调用Linux系统调用sys_waitpid，这个系统调用的功能是

```c
sys_waitpid()
	current->state=TSK_INTERRUPTIBLY;
	schedule()
```

他会把当前运行进程的state变成阻塞状态，然后执行schedule内核函数执行CPU调度. 也就是AB进程会被阻塞，此时就绪队列只有A和B进程。执行schedule内核函数CPU调度

CPU调度会把当前CPU执行进程的PCB赋值给pCur，然后放到就绪队列，同时从就绪队列拿到一个PCB把他赋值给CPU，这样就完成了CPU的调度和进程的切换。

导致CPU调度除了进程主动抛弃CPU进入调度函数schedule，还有一种情况是时间片用完，这种情况的实现是依赖时钟中断

CPU里面在调度的时候除了初始化PCB中的参数，还有一个初始化count参数记录时间片。

```
do_timer:
	if( --current->counter>0 ) 
		return ;
	current->counter  =0 ;
	schedule()
```

时钟中断会在将CPU的count不断减1，直到count为0会触发新的CPU调度。如此上面的AB进程会执行交替打印A和B

### 进程调度-怎么切换进程 CPU调度

- 为什么要C语言嵌入汇编代码？可以使用汇编代码更加精细的控制，因为汇编代码使用的寄存器和使用的内存是确定的

- **对于一个IO进程进行切换的过程**

  设置当前PCB pCur的state状态为waiting，并且放入IO阻塞队列

  然后从就绪队列中按调度算法获取一个PCB pNew

  然后CPU切换到pNew执行，先按照pNew的PC指针和各种寄存器恢复现场，然后按照PC进行执行。

  ```
  switch_to(pCur, pNew){
  	pCur.ax = CPU.ax ;
  	pcur.bx = CPU.bx ;
  	...
  	pCur.cs = pNew.cs ;
  	pCur.retpc = pNew.pc ;
  
  	CPU.ax = pNew.ax ;
  	CPU.bx = pNew.bx ;
  	...
  	CPU.cs = pNew.cs ;
  	CPU.retpc = pNew.pc ;
  }
  ```

- 线程资源包括代码、栈、PCB、现场、映射表

- 评判调度算法好坏的标准

  - 周转时间：从任务开始到结束的时间。想要快点完成任务，就让周转时间小
  - 响应时间：从操作发生到响应的时间。想要实时性就要响应时间短
  - 吞吐量：完成的任务量。CPU执行用户代码时间站总时间比，因为有IO等阻塞时间

- 评判标准的矛盾

  - 响应时间短就要切换频繁，切换频繁造成大量时间用于线程或者进程切换，从而系统执行代码时间少，吞吐量小
  - 前台任务关注效应时间，后台任务关注周转时间

- 优先级调度坏处可能会导致饥饿

#### 先来先服务FIFO

取就绪队列的第一个进程执行，缺点是没有优先级

#### 短作业优先SJF

执行时间越短的先执行。相较于先来先服务降低了平均周转时间

#### 时间片轮转RR

每个进程执行一个时间片之后就放入就绪队列，好处是保证响应时间小，一个进程最多等n*t，n时前面任务数，t时时间片，要保证响应时间很小，那么限制n的个数并且让t很小

### 进程内存分离-内存管理

通过映射表实现地址空间分离，防止实际地址错误，各个进程操纵自己的内存空间而不能访问到其他进程的内存空间-地址映射

```
//A进程
mov [100],ax ;//将ax送到内存100位置

//B进程
100: 00101

如果没有内存分离，A进程的A[100]会访问到B进程的100内存地址，造成错误。
因此要分离A进程和B进程使用的内存地址，在进程中给出的是虚拟地址100，而不是
实际地址100，虚拟地址要添加映射表中的项获得真正的地址
```

### 进程同步-多进程合作完成任务

多进程共享内存变量造成共享变量不同步

#### 生产者消费者模型-信号量

信号量标记可以被使用的资源的数目，当一个进程申请信号量的时候要信号量-1，当一个进程释放信号量的时候信号量+1，当进程发现信号量小于等于0就阻塞。如果为-n，表示有n个进程正在等待。信号量为正可以用来标记还有多少可用资源，信号量为辐可以用来标记还有多少个进程在等待

```java
//使用信号零实现生产者消费者模型
class Producer implements Runnable{
	Semaphore empty ; //标记还有多少个空位可以供生产者使用
	Semaphore mutex ;//互斥信号量，同步阻塞
	Semaphore full ;//标记生产者生产了多少个产品
	//生产品每次生产一个产品，就要唤醒一个消费者进行消费
	
	ArrayList<String> list ;
	
	public Producer(Semaphore empty, Semaphore mutex,
					Semaphore full, ArrayList<String> list) {
		this.empty = empty ;
		this.mutex = mutex ;
		this.full = full ;
		this.list = list ;
	}
	
	public void run() {
		try {
			this.empty.acquire();
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}//还有多少个空位
		try {
			this.mutex.acquire();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}//互斥信号量
		
		list.add( String.valueOf(Thread.currentThread().getName() ) ) ;
		
		mutex.release();//互斥信号量释放
		full.release();//唤醒一个消费者线程
	}
}
class Consumer implements Runnable{
	Semaphore empty ; //标记还有多少个空位可以供生产者使用
	Semaphore mutex ;//互斥信号量，同步阻塞
	Semaphore full ;//标记生产者生产了多少个产品
	//生产品每次生产一个产品，就要唤醒一个消费者进行消费
	
	ArrayList<String> list ;
	
	String name ;
	
	public Consumer(Semaphore empty, Semaphore mutex,
					Semaphore full, ArrayList<String> list,
					String name) {
		this.empty = empty ;
		this.mutex = mutex ;
		this.full = full ;
		this.list = list ;
		this.name = name ;
	}
	
	public void run() {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			full.acquire();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		try {
			mutex.acquire();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		String s = list.get(0) ;
		list.remove(0) ;
		System.out.println(name+" consumes "+ s) ;
		
		mutex.release();
		empty.release();
	}
}
public class Main {
	
	public static void main(String[] args) throws InterruptedException {
		ArrayList<String> s =new ArrayList<String>(2) ;
		Semaphore empty = new Semaphore(2) ;
		Semaphore mutex = new Semaphore(1) ;
		Semaphore full = new Semaphore(0) ;
		
		
		ArrayList<Thread> threadList = new ArrayList<Thread>(100) ;
		for(int i=0;i<4;i++) {
			Thread thread = new Thread(new Producer(empty, mutex, full, s)) ;
			thread.start(); 			
			threadList.add(thread) ;
		}
		
		ArrayList<Thread> consumerList = new ArrayList<Thread>(100) ;
		for( int i=0;i<5;i++) {
			new Thread( new Consumer(empty, mutex, full, s, "Consumer "+i)).start() ;
		}
		
		Thread.sleep(500);
		for(Thread thread: threadList) {
			System.out.println(thread.getName()+" "+thread.getState() ) ;
		}
		
		
		Thread.sleep(2000);
		for(Thread thread: threadList) {
			System.out.println(thread.getName()+" "+thread.getState() ) ;
		}
			
	}
}
```

```java
//阻塞队列实现生产者消费者模型

class Producer implements Runnable{
	BlockingQueue<Integer> que ;
	
	public Producer(BlockingQueue<Integer> q) {
		que = q ;
	}
	
	public void run() {
		for( int i=0;i<10;i++) {
			try {
				que.put(i) ;
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
class Consumer implements Runnable{
	BlockingQueue<Integer> que ;
	public Consumer(BlockingQueue<Integer> q) {
		que = q ;
	}
	@Override
	public void run() {
		for(int i=0;i<10;i++) {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			int a = 0;
			try {
				a = que.take();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			System.out.println(a) ;
		}
	}
}
public class Main {
	
	public static void main(String[] args) throws InterruptedException {
		
		BlockingQueue<Integer> que = new ArrayBlockingQueue<Integer>(3) ;
		
		Thread producer = new Thread(new Producer(que)) ;
		producer.start();
		Thread consumer = new Thread(new Consumer(que)) ;
		consumer.start();
		
	}
}
```

#### 同步互斥方法

##### 信号量为1保证原子性

```java
class MyRunnable implements Runnable{
	Semaphore mutex ;
	
	public MyRunnable(Semaphore mutex) {
		this.mutex = mutex ;
	}
	
	@Override
	public void run() {
		try {
			mutex.acquire();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println(1);
		System.out.println(2) ;
		System.out.println(3) ;
		
		mutex.release();
	}
}
public class Main {
	
	public static void main(String[] args) throws InterruptedException {
		Semaphore mutex = new Semaphore(1) ;
		
		for(int i=0;i<3;i++) {
			new Thread(new MyRunnable(mutex)).start();
		}
			
	}
}
```

信号量的加减使用的时Unsafe类的直接内存的state变量，是CAS基于CPU原语的原子操作。信号量不能重入，如果信号量调用了一个同样使用信号量互斥同步的代码，那么他会死锁

临界区用来保护信号量，用信号量来保证进程同步

**信号保护**

只能是临界区代码才能修改信号量

**临界区代码保护原则**

- 互斥进入，如果一个临界区在执行，则其他进程不能执行，这保证了临界区执行
- 有空让进：有若干进程要求进入临界区时就尽快使进程进入临界区
- 有限等待：从进程发出进入请求到允许进入，不能无限等待，方正进程饥饿

**进入临界区的方法**

- 轮换法

  ```
  //进程p0
  while(turn != 0);
  临界区
  turn = 1 ;
  
  //进程p1
  while(turn != 1);
  临界区
  turn = 0;
  
  上述进程依赖turn的转换，每转换一次就触发一次临界区，这种方法只适合两个进程
  ```

- 标记法

  ```
  每个进程维护自己的标记，他试图进入临界区就将标记变成true，然后检查其他地方标记，如果其他地方标记都是false，那么他才执行临界区
  
  //A进程
  flag[0] = true ;
  while(flag[1]) ;
  临界区
  flag[0] = false ;
  
  //B进程
  flag[1] = true ; //B想进入设置
  while(flag[0]); //查看A是否已经进入
  临界区
  flag[1] = false ;
  ```

- Peterson算法

  ```
  //A进程
  flag[0] = true ;
  turn = 1 ;
  while( flag[1] && turn == 1) ;
  临界区
  flag[0] = false ;
  
  //B进程
  flag[1] = true ;
  turn = 0 ;
  while(flag[0] && turn == 0) ;
  临界区
  flag[1] = false ;
  
  皮特森算法才能真正保护临界区，前面两个可能死锁，这里介绍的三个算法都只能用于两个进程。多进程版本看下一个算法，面包店算法
  ```

- 面包店算法

  多进程实现对临界区（修改临界变量的代码）互斥同步（临界区原子操作）的代码

  ```
  //进程Pi
  choosing[i] = true; //如果进程在选号，那么要进入临界区的进程自旋等待
  num[i] = max(num[j])+1; j=1,2,...,n //给第i号进程选号为当前最大的+1
  choosing[i] = false;
  for(int i=0;i<n;i++){
  	while( choosing[j]) ; //如果有进程在选号，那么进程自旋等待
  	while( num[j] !=0 && (num[j]<num[i] ||(num[j]==num[i] && j<i)) ) ; 
  		//如果进程被分配了号并且不是最小的号，那么自旋等待，如果分配到了同样的号并且不是下表最小的进程，那么自选等待
  }
  临界区
  num[i] = 0 ;
  
  
  面包店算法显示给每个进程分配一个号码，每次总是选择最小的那个号码的进程执行，如果最小的号码有多个进程，那么选择
  下表最小的那个进程执行。
  ```

- 关中断

  上面的算法是软件算法，关中断是硬件设计

  关中断的思想是关掉CPU调度，从而让一个进程得到执行。

  CPU调度是部分基于中断实现的，只要来子多方面

  - 时钟中断，每个CPU有一个count寄存器保存时间，每过一定时间时钟中断发生让count-1，当count为0，会置CPU的INTR寄存器（中断寄存器）为1，从而让CPU执行响应的中断处理程序
  - IO中断

  ```
  cli(): //关中断指令
  临界区
  sti(); //开中断指令
  ```

  关中断只能在单CPU上表现好，因为关中断总是关一个进程的中断，但是在多处理器的时候，你关一个CPU中断并不能组织其他进程不能进入临界区

- 硬件原子指令

  类似Java的Unsafe类的原子操作CAS，利用的是CPU原语，如cmpxchg

##### 基于锁的方法

- synchronized 重锁悲观锁
- ReentrantLock重锁悲观锁

##### 基于CAS的方法

CAS是一种乐观锁，他底层使用Unsafe类的CAS操作，是一种CPU原语，可以保证操作原子性

#### 死锁

多个进程互相等待对方持有的资源造成谁都没法执行的情况就是死锁

##### 死锁产生的四个必要条件

- 互斥使用

  资源只能被一个进程使用

- 不可抢占

  占有资源的进程不能被抢占资源，只能自己释放

- 请求保持

  进程必须占有资源并去申请新资源

- 循环等待

  形成循环等待链

##### 死锁处理

###### 死锁预防

破坏死锁的必要条件

**具体方法**

- **破坏请求保持条件**

  在进程开始前一次性分配资源，而不是占有一些资源还去申请新的资源

  **缺点1：** 需要预知所有需要的资源，变成困难

  **缺点2：** 资源被进程占用但是要过很久才会被使用，资源利用率第

- **破坏循环等待条件**

  对资源进行排序，资源申请必须按序进行，不会出现环路等待

  **缺点：** 造成资源浪费 

###### 死锁避免

每次请求资源的时候判断是否会产生死锁，如果造成死锁就拒绝这次资源请求

**具体方法- 银行家算法 **

判断是否有一个安全序列可以让进程继续执行

```
available //资源剩余量列表
allocation[1,2,...,n] //资源已经分配了的列表
need[1,2,...,n] //进程请求资源列表
work //保存资源量
finish[1,2,3,...,n] = false//记录进程是否执行完毕

while(1){
	for( int i=1;i<=n;i++){
		if(!finish[i] && need[i]<work){//如果进程要求的资源小于work，就分配给他让他执行完毕，之后回收他的资源
			work = work+need[i] ;
			finish[i] = true ;//进程执行完毕
			break ;
		}
		else{
			goto end;//如果没有死锁或者产生死锁不能need[i]<work
		}
	}
}
end:
	for(int i=1;i<=n;i++){//如果还存在没有执行完成的进程，就死锁
		if( !finish[i])
			return "deadlock" ;
	}
	

```

上面的方法是O(mn^2)，缺点是每次申请资源都要执行，会造成CPU浪费

###### 死锁检测和死锁恢复

检测到发生死锁，就让一些进程回滚让出资源

因为死锁避免每申请资源就执行浪费CPU资源，所以考虑把银行家算法放到后面。

死锁检测和恢复定期执行，先调用银行家算法发现是否产生死锁并且记录死锁的进程，然后选择几个占有资源多的进程回滚。

死锁检测和恢复算法需要对进程进行回滚，回滚算法是核心也是难点，恢复很难

###### 死锁忽略

为什么可以忽略死锁

- 死锁忽略效率高，死锁避免（一次性分配资源和按序分配资源）资源利用率低，死锁预防（银行家算法）没分配资源都要执行浪费CPU资源；死锁检测和恢复需要进程回滚，这很困难。
- 发生死锁概率低
- 可以通过重启电脑解决死锁

## 内存管理

在编译的时候编译器会把程序转成汇编语言，在汇编语言中，会把调用函数安排到对应的地方，并且产生一个行号（偏移）作为程序调用的跳转的位置。每个指令在汇编里都会分配一个相较于程序入口地址的偏移量作为执行这个语句跳转的地址。如果我们把这个地址放到真实的物理地址，就会从0地址开始存放这个代码，会占用操作系统代码地址，这是不被允许的。分配内存的时候应该应该找一块空闲内存分配内存让他进来，同时修改代码的逻辑地址为真实的物理地址（重定位）。程序编译器编译之后放到磁盘，在执行的时候会被载入到内存。

**重定位方式**

编译时重定位，适合嵌入式系统，比如航天系统，程序被放到内存固定位置，效率高，不灵活

载入时重定位，载入时根据空闲内存替换逻辑地址为真实地址，比编译时重定位灵活。载入程序内就不能动了

运行时重定位，因为载入时重定位载入之后程序在内存就不能动了，而内存很宝贵，一些不常用的进程应该被返回磁盘，所以程序的逻辑地址不应该直接替换，应该在运行时重定位。实现方式是使用基址寄存器base记录程序占用的物理内存的起始地址，每次执行一条指令就使用基址base+逻辑地址（偏移量）得到真正的物理地址。基址寄存器的数值base在创建进程的时候进程代码会被加载到内存，创建进程的时候会把加载到内存的起始地址放到PCB的基址寄存器里面，每次切换PCB的时候会切换基址寄存器

**交换**

内存资源很宝贵，如果一个进程代码长时间不使用，应该把他放回磁盘

### 内存分段

分段后程序执行情况

操作 赋值给进程LDT表，然后把进程LDT表保存到进程PCB中，创建用户栈，把代码段基址放到用户栈，然后把PCB加入到就绪队列等待CPU调度。当进程从代码段获得一个逻辑地址，如果他是数据段地址，会查找LDT表获得数据段基址，然后把这个数据逻辑地址加上数据段基址得到物理地址。

- 分段符合用户逻辑习惯，程序划分为代码段（不会增长）、数据段（不增长，常量池，方法区）、堆栈段等

- 比较高效，如果程序被放入一起，而不是分段，那么对于栈这一块，他会增长，当他因为分配的内存不够时，需要重新定位程序，这个过程旧的程序代码段数据段堆栈段和新的程序地址需要复制数据并且不可被使用，这很浪费内存

- 内存分段之后不能和之前不分段直接分配一个大内存一样只需要一个基址寄存器存放程序入口地址，而是需要保存每个段的地址，因此分段进程的PCB要保存每个段的地址的基址，这个就是进程段表。

  操作系统也有一个段表，就是GDT表

  操作系统GDT表不仅保存操作系统所有的段，而且存放进程LDT表，进程给出一个逻辑地址，操作系统查找进程的在GDT表中的LDT表，从而找到进程逻辑地址的段基址，段基址加上逻辑地址变成逻辑地址的物理地址，完成重定位。

  用户程序段表时LDT表，LDT表实际上就是地址映射表MMU

  | 段号 | 基址 | 长度 | 保护 |
  | ---- | ---- | ---- | ---- |
  | 0`   | 180k | 140k | R/W  |



将每个段载入到空闲内存，怎么载入。

**固定分区和可变分区**

固定分区：操作系统吧内存分为大小相同的分区，每次以多个分区分配给进程的每个段

可变分区：操作系统不区分内存分区，只是每次来请求一个段，就分配一个段的大小

#### 可变分区实现

**实现方法**

操作系统维护一个空闲分区表，每次分配一个段的大小。如果有内存发生释放，那就再空闲分区表中添一项新的空闲分区项。空闲分区表不是现代操作系统实现的方法，现代操作系统时用分页解决内存分区。

空闲分区表

| 始址 | 长度 |
| ---- | ---- |
| 350k | 150K |
| 200K | 50K  |

已分配分区表

| 始址 | 长度 | 标志 |
| ---- | ---- | ---- |
| 0    | 100K | OS   |
| 100K | 200K | seg0 |

**空闲分区表产生问题**

像上面的空闲分区表，如果有一个段需要分配地址所有项都可以分配，那么使用哪一个项去分配。

- 首次适配

  扫描空闲分区表找到第一个可以被分配的项

  首次适配速度快

- 最佳适配

  扫描空闲分区表找到最小的可以分配的项分配

  最佳适配和最差适配都是线性复杂度，最佳适配会产生很多小内存，发生外部碎片

- 最差适配

  总是选择最大的可悲分配的项

**可变分区产生的问题**

使用空闲列表进行内存分配的方式会造成内存碎片，当来了一个比较大的段，空闲分区表没有一个表项可以给这个段分配内存，而实际上总的内存是足够的，这个时候就会产生外部碎片。

解决内存碎片（外部碎片的方法）：内存紧缩。

当无法分配一个大的段的时候，将内存中已经分配的表项都移动到一起，变成紧密的内存块，然后可以得到一个大的空闲分区，在这个空闲分区上分配内存给段。

但是内存紧缩是很耗时的行为，如果内存复制1M内存用1s，那么复制1G内存就要17分钟，在这个过程用户进程得不到执行，用户体验很不好。

### 内存分页

操作系统把内存分页，在mem_map中每一项都是4K大小，内存分配以一页（4K）进行分配。

当给用户段分配内存时，总是以一页分配，这样每个段被划分为多个页。

用户程序被划分为多个页，操作系统内存被划分为多个页，用户程序被分配内存时总是以一个页被分配内存，并且建立页表保存用户页号和内存页框号之间的映射关系

| 页号 | 页框号 | 模式 |
| ---- | ------ | ---- |
| 0··  | 3      | R    |
| 1    | 2      | R    |
| 2    | 5      | R    |

用户程序的逻辑地址，比如0x2240，会被MMU操作0x2240/4K（4K是操作系统页大小）=0x2 ... 0x240 ；

也就是这个逻辑地址对应用户程序分页页号2，我们查页表发现是内存页号5，而页内偏移是0x240，这样我们可以获得实际物理地址0x5*4K+0x24 = 0x524

分页存储用户的页表存放在PCB的CR3寄存器。

**内存分页问题**

为了提高空间利用率，页大小应该尽量小，但是这样会造成页表变大。多级页表+TLB表

分页是存储器用户程序给出的逻辑地址是不连续的地址，也就是说他的地址新城的页号是不连续的，不是0、1、2、3、4...这种连续的，他的某些部分的页号是没有对应的页框号的，比如2号没有对应的页框号，这样造成的结果是如果我们想要保证一次访存获得页框号，我们必须保证随机访问，就要保留这些没有页框号的页表项，这样会增大页表，如果极端情况一个进程的逻辑地址从内存最后一个到内存第一个，对于32为内存（4G），我们要为这个进程维护的页表的大小是4M(4G/4K，4K是每个页面大小)，这样很浪费内存。如果我们不保证随机访问，可以将没有页框号的页表项删除，那么我们可以遍历整个页表或者二分查找整个页表来找到页号对应的页表项，这样会增加访存次数，而访存是很浪费时间的，时间效率太低。因此我们宁愿牺牲空间保证时间。

这样我们可以引出多级页表，对于刚刚的4M的页表，他的中间很多是没有页框号的，我们可以用4K作为一个单位，重新建立一个对这个页表的页表，只是这个页表对没有页框号的那部分表项没有分配页框号，也就不用分配内存个哪些页表项。这样我们的二级页表的大学是4M/4K = 1K，而一级页表里有页表项的哪些页都被二级页表按4K大小保存，加入这个1K的二级页表中有15个项有页框号，那么整个一级和二级页表加起来大小是15*4K + 1K=61K，远远小于4M大小的页表。按照这个道理，可以划分多级页表

除了多级页表，我们可以之家把逻辑地址页号到物理地址页框号的映射放到TLB里面，当应用程序给出逻辑地址的时候，直接在TLB里面查找到页框号，然后利用这个页框号组成内存物理地址访问一次内存

使用多级页表访问物理内存如果是2级页表，那么会访问三次内存，一次是取以及页表页框号，第二次根据前面的页框号访问一级页表得到页框号，最后组成这个物理地址访问物理内存，三次访问内存

使用一级页表和TLB访问内存期望时间

T = HitR*(TLB+MA) + (1-HitR)*(TLB+2MA)

其中HitR是命中TLB概率，MA是访问内存时间

为什么TLB有用，TLB基于程序空间局部性原理，最近访问过的内存区域在未来可能还会被访问。

### 段页式存储器（分段+分页）

操作系统维护了空闲列表来分配段，这个内存分配是虚拟空间的内存分配，实际的内存分配采用的是分页分配，虚拟空间的分配只是形成了一个虚拟地址。操作系统维护了这个虚拟地址空间，然后操作系统对这个虚拟空间的每个段按照页进行分配内存并且保存在内存中。这样段也是存储器分配内存，进程PCB有段寄存器和页表寄存器。用户程序给出的是一个逻辑地址，这个逻辑地址是根据段的逻辑偏移，比如mov [0x24] %eax; 这个0x24是相对于数据段的偏移0x24，操作系统首先获取段表的数据段基址，把0x24加到这个段基址获得虚拟地址；这个虚拟地址被按照分页方式计算实际地址。假设至于一个页表，虚拟地址%4K=页号...页内偏移，可以获得页号，然后查找这个页号在页表中可以获得页框号，然后根据页框号*4K+页内偏移我们可以获得实际物理地址。（页目录号，页号）（页号，页框号）

段页式存储器用于自动转换地址的部件是MMU，他需要放入LDT表（段表）和页表才能计算，而段表和页表是进程相关的。

**写时复制**

把父进程fork到子进程的时候，子进程的LDT表和页表复制为父进程的段表和页表保存在MMU，并且设置子进程的页表为只读。当子进程写变量的时候会查找到父进程的页表并且发现是只读，这样就会分配一个新的页框并且复制到子进程的页表，从而重新按照新页框号计算得到实际物理地址，这样就完成了写时复制。

### 内存换入和换出

通过内存换入和换出可以实现虚拟内存，让用户感觉自己可以使用4G完整的内存。

#### 内存换入

在创建用户程序PCB的过程会分配PCB、用户栈、内核栈、同时分配内存加载用户程序到内存，建立用户程序的段表和页表。建立用户程序段表是完整的，但是建立并加载用户程序页表可能是不完整的，他只会从磁盘中读取应用程序的一个页加载到内存并且建立页表。这样造成的结果是，CPU通过用户栈获得用户程序的程序入口地址，给出程序的逻辑地址发送给MMU，MMU通过逻辑地址其分成段号和段内偏移，查找MMU内的GDT表找到段号对应的段基址，通过段基址+段内偏移找到虚拟内存地址虚拟地址，通过虚拟地址%4K=页号...页内偏移，用页号去查找页表发现页表里面没有页号对应的项，发生缺页中断。缺页中断会从磁盘中找到缺失的页并把那个页加载到内存，同时建立好页表中对应的缺失项。从而通过MMC可以在内存中访问到需要的指令和数据。

缺页中断是在setup.s head.s main.c初始化的时候创建的，在main.c里面与一个trap_init()方法设置缺页中断处理程序。当发生缺页中断时，MMU设置CPU的INTR中断寄存器位1，CPU发生缺页中断并且执行缺页中断指令。

#### 内存换出

**选择哪一页换出-页面置换算法**

评价页面置换算法的标准-缺页次数

- 先入先出

  选择最先换入的页

- 最远被使用

  选择将来最远被使用的也换出，这是最优的算法，但是不能实现，因为你要预测未来到达的页

- 最近最少使用-LRU算法

  选择最近的最少使用的页换出

  **LRU算法**

  - 基于时间戳的算法

    每一页维护一个时间戳，如果发生缺页，就把时间戳最小的那一项替换，这种方法在计算机是不能实现的，这是因为首先每次缺页都要计算时间戳并且遍历页框找到最小的那一项替换，这很耗时，同时你的时间戳会溢出，导致不能用。

  - 基于页码栈的算法（实际上的LinkedHashMap)

    维护一个页码栈，如果页码栈有空余空间就压入，如果没有，检查当前要压入的代码是否在压栈存在，如果存在就把那个页码浮到栈顶，如果不存在，就把这个页码压入栈，而栈底元素会被压出删除。

- 近似LRU算法- Clock算法

**给进程分配多少页框-决定页表大小**

如果分配的太多，那么能够容纳的进程个数减少，内存利用率降低

如果分配太少，缺页率增大，造成频繁内存和外存换页，在进程很多的时候，进程总是等待调页，CPU利用率降低，造成系统抖动颠簸。CPU效率低。

Linux的Swap分区就是用来处理缺页中断的换页的。

内存换入换出时实现虚拟内存的核心，实现虚拟内存是实现段页式存储器的关键。

CPU管理和内存管理是操作系统核心。



1. 异步同步、阻塞非阻塞，他们之间有联系吗，synchronized，放在各个地方锁的是啥，一个synchronized静态方法，一个普通的synchronized方法，访问静态方法后还能访问普通方法吗，锁的对象是一样的吗。

2. synchronized底层原理讲解（3分钟）

3. ReentrantLock底层原理（1.5分钟）

4. 线程池处理任务的流程（2分钟）

5. HashMap底层数据结构（2.5分钟）

6. ConcurrentHashMap底层原理（1分钟）

7. 并发情况下HashMap什么时候会修改失败（1分钟）

8. 

9. 进程线程的区别，进程的切换过程

10. 虚拟内存，为什么要有虚拟内存，进程的虚拟内存联系起来

11. 线程池的参数

    1. 每个参数解释一遍
    2. 然后面试官设置了每个参数，给了是个线程，让描述出完整的线程池执行的流程

12. Linux了解么

    1. 怎么查看系统负载
    2. Cpu load的参数如果为4，描述一下现在系统处于什么情况
    3. Linux，查找磁盘上最大的文件的命令
    4. Linux，如何查看系统日志文件
    5. Linux关于网络的指令
    6. Linux内存管理

13. 线程有哪些实现方式

14. 线程池有哪些

15. 锁有哪些

16. 可重入锁机制

17. 

18. 线程的状态 ： { new ,runnalbe , wait , time-wait , block , terminated }

19.  进程 、 线程 、 协程 的含义和区别   // 个人理解 是一组渐进提出的概念

20. 进程间通信方式 ： { 管道 、FIFO 、 信号量 、 共享内存 、 消息队列 、 Socket }

21. 如何避免死锁 ？ 死锁的四个必要条件

22.  Sleep和wait的区别

23. Sychronized 和 lock 的区别 ？Sychronized的底层优化 ： { 无锁、偏向锁、轻量级锁 、重量级锁 }

24. volatile的作用 : { 指令重拍 、 保证变量的可见性（设计JMM）}

25.  ThreadLocal 底层原理

26. 线程池

    线程池构造器涉及哪些参数 : { corePoolSize , maximumPoolSzie , timeout ， timeUnit ， RejectHandler ， 等待队列 ， 线程工厂 } 

       介绍线程池工作过程?
        线程池拒绝策略那些？ 
        适用Executor创建线程池的弊端？

27. AQS 框架原理和 源码理解

28. Select poll epoll的区别

29. 用户态和内核态的区别

30. fork()作用

31. 虚拟内存作用？ 内存分页的作用？

32. 缺页异常的介绍

33. OOM问题和 StackOverFlow的区别



# 数据库相关

视频资料

[哈工大战德臣数据库系统](https://www.bilibili.com/video/BV1PJ411F78b?spm_id_from=333.337.search-card.all.click)

[马士兵数据库视频](https://www.bilibili.com/video/BV1eb4y1h7mf?p=2&spm_id_from=pageDriver)

[世界数据库排名-技术选型](https://db-engines.com/en/ranking/relational+dbms)

## 数据库系统实验

### 实验1-最基本的SQL/索引/存储数据库

[数据库的最简单实现 - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2014/07/database_implementation.html)

**数据库功能**

最基本的两个功能是存储方式和索引方式，其他高级功能包括SQL语言解析、数据库连接、数据库事务、数据库备份、远程操作

- 存储方式。基于磁盘的数据库以文件来保存数据库（MySQL，SQLServer，Oracle），基于内存的数据库以虚拟磁盘的方式保存数据在内存中（Redis）。磁盘数据库依赖Linux操作系统的文件管理系统调用，Linux文件相关系统调用和函数有文件创建/打开/关闭/删除，文件读写（file_read/file_write)，文件执行（exec)。一般将表的每个记录设为等长方便查询数据。create table这个MySQL语句相当于创建了一个结构体，而整个数据库文件相当于table结构体的数组。

- 索引方式。访问数据库中的某一条记录，我们不是直接从磁盘中获得的，因为磁盘是块设备存储，块设备的访问需要使用硬盘中断传入（读写操作命令r/w，磁盘号，磁道号，扇区号，es:[ebx]内存缓冲块地址）这几项参数，然后硬件中断设置进程阻塞状态，等待磁盘控制器将es:[ebx]指向的缓冲区的512个字节写入到磁盘或者将磁盘一个扇区（512B）写入到es:[ebx]所指向的内核缓冲区。CPU只能随机访问内存，不能随机访问磁盘，CPU总是使用硬盘中断读入磁盘一个扇区到内存或者写入内存一个扇区的数据到磁盘。因此CPU要访问数据库数据必须将存储在磁盘中的数据读入内存进行处理。数据库在磁盘中以文件进行存储，实际上是被分散到不同的扇区，MySQL数据库总是以一页内存大小的单位来组织数据块，也就是以8个扇区作为一个数据块，每次读取磁盘的时候总是以8个连续扇区读取到一个内存页中。4K大小的数据块被组织成一个链表，数据块的末尾是指向下一个数据块的指针（这个指针以（磁盘/磁道/扇区来表示和存储））。一般情况下要获取一条记录，我们只知道记录的主键，想要通过主键访问到数据库文件中的记录，我们只有不断把数据库的磁盘数据块读入内核缓冲区，然后读入一条记录到用户空间，主键，如果是就停止，否则移动文件指针lseek（inode, sizeof(entry) ）到下一条记录，重新file_read一条记录sizeof(entry)个字符串到用户空间。这种遍历的方式，有size/blk_size次将磁盘数据块拷贝到内核缓冲区的操作，以及size/sizeof(entry)次将内核缓冲区数据拷贝到用户空间put_fs_char进行比较的操作，这种遍历的方式很耗时。这种方式的伪代码是

  ```c
  for i in size/sizeof(entry):  
  	record=file_read(inode, sizeof(entry) ); 
  	if record == key: 
  		return record; 
  	lseek(inode, sizeof(entry) ;
  ```

  为了获得主键对应的记录，主要是获得记录的文件指针，我们可以用B+树建立索引来保存记录的文件指针。这种把主键进行组织成B+树的形式并且只要在B+树中找到主键就能从主键中获取对应的文件指针，从而根据这个文件指针直接file_read这个文件指针所对应的记录，可以减少访问磁盘的次数和比较的次数。B+数的深度是log(记录数)，每个B+树节点是主键key值，每个主键key值对应一个文件指针指向这个key所对应的条目的地址。我们通过**log(记录数)**次读取磁盘到内存并比较**log(记录数)*每个B+树节点对应记录数**次就可以找到主键和主键对应的文件指针，我们通过文件指针file_read这个文件指针就可以找到那一条记录，这样我们实际读取磁盘块的次数是**log(记录数)\*节点度数+1**和比较次数**log(记录数)\*节点度数**，远远小于遍历的方式。B+树文件需要额外存储为一个索引文件，可以放到数据库文件对应的文件夹里面，每个B+树节点占用一个磁盘数据块。B+树节点有参数（主键，文件指针），为了方便数据库文件在磁盘块上连续存储。这种实现方式伪代码

  ```c
  find_filep(B_node):
  	for record in B_node:
  		if record.key== key:
  			return record.filep
  		if record.key>key:
  			return find_filep(newB_node= record.blkp)
  filep= find_filep(B_node)
  record = file_read(filep, sizeof(entry) )
  return record
  ```

- SQL语言解析。将SQL语句转换成对应的ISAM（Indexed Sequential Access Method 索引顺序访问方法）方法，执行数据库的访问。select对应读数据库，具体实现是按照上诉索引查找到主键位置和对应的文件指针，然后通过文件指针file_read访问磁盘数据库文件，读取对应的记录put_fs_char到用户空间；update对应更新数据库，首先按照上诉的索引找到主键对应的文件指针，file_wirte（文件指针，用户空间更新数组，字节数）将数据写入到内核缓冲块，最后调用iput将缓冲块写到磁盘文件；delete只需要修改B+树索引文件就可以了，我们可以增加主键结构的一位用来保存这个主键是否可用，这样我们在select和update查询B+树的时候发现有主键不可用，那么就返回失败没有那一个主键条目；insert对应增加一个条目到数据库中他首先获取数据库末尾指针把这个末尾指针和主键一起加入B+树，然后file_write文件末尾增加一个记录到数据库文件。

- 数据库连接：将两个数据库表合并到一起，包括左连右连全外连接内连接等等。数据库连接通过SQL的join语句完成。数据库连接优化怎么做需要自己实现

- 数据库事务：保证原子性执行的一段数据库指令。当事务不能执行的时候需要回滚操作

- 数据库备份：保存数据库副本的操作。远程数据库备份需要哨兵机制

- 远程操作：远程访问数据库，需要实现TCP/IP等通信协议。

**scanf/gets/编译器字面值 都会添加\0字符，忽略\n字符**

https://www.runoob.com/cprogramming/c-function-sscanf.html

sscanf/sprintf读写字符串, scanf/printf/gets/puts读写控制台stdio，fscanf/fprintf/fgets/fputs读写文件

```c
#include <stdio.h>

int main () {
	char a[10] ;
	scanf("%s", a) ;
	if( a[1]=='\0'){
		printf("scanf will add \\0 into char list\n");
	}else{
		printf("scanf will not add \\0 into char list\n") ;
	}
	return 0; 
}
```

![Screenshot 2022-10-18 155158](实验\操作系统实验\实验5 信号量的实现和应用\Screenshot 2022-10-18 155158.png)

**获取文件读写位置函数fgetpos/fsetpos，可以被索引文件保存为对应主键的读写位置**

https://www.tutorialspoint.com/c_standard_library/c_function_fgetpos.htm

https://www.javatpoint.com/fprintf-fscanf-in-c

```c
// test1.c
#include <stdio.h>
int main () {
   FILE *fp;
   fpos_t position;

   fp = fopen("file.txt","w+");
   fgetpos(fp, &position);
   fputs("Hello, World!", fp);
  
   fsetpos(fp, &position);
   fputs("This is going to override previous content", fp);
   fclose(fp);
   
   return(0);
}

//test2.c
#include <stdio.h>

int main () {
   FILE *fp;
   int c;
   int n = 0;

   fp = fopen("file.txt","r");
   
   while(1) {
      c = fgetc(fp);
      if( feof(fp) ) {
         break ;
      }
      printf("%c", c);
   }

   fclose(fp);

   return(0);
}
```

fscanf/fprintf

```c
#include <stdio.h>  
main(){  
   FILE *fp;  
   fp = fopen("file.txt", "w");//opening file  
   fprintf(fp, "Hello file by fprintf...\n");//writing data into file  
   fclose(fp);//closing file  
}  



///
#include <stdio.h>  
main(){  
   FILE *fp;  
   char buff[255];//creating char array to store data of file  
   fp = fopen("file.txt", "r");  
   while(fscanf(fp, "%s", buff)!=EOF){  
   printf("%s ", buff );  
   }  
   fclose(fp);  
}  
```

**数据库实验-实现SQL语言解析/索引/数据库文件存储的数据库**

```c


#include<stdio.h>


#define NOT_VALID 0
#define VALID 1


typedef struct {
	int key;
	long Fpos;
	long Ipos ;
	int valid;	
}Index;
Index index[10] ;



void select(FILE* fp, int key){
	int col1, col2 ;
	long pos= index[key].Fpos;
	fseek(fp, pos, SEEK_SET) ;
	fscanf(fp, "%d %d %d",&key,&col1,&col2) ;
	//printf("%d: %ld\n",key, pos) ;
	
	printf("%d %d %d\n", key, col1, col2) ;
}
int main(){
/*
	sql interpreter
		C a.db: create file a.db as database
			char fname[10]
			scanf("%c %s", &op, fname) ;
			FILE* fp = fopen(fname, "rw") ; 
			FILE* ifp= fopen(fname.index,"rw");
			
			idx=0;
			while(!feof(fp)){
				fgets("%d%d%d",index[idx].key, index[idx].pos, index[idx].val) ;
				idx++;
			}
		I a.db 1 2 3: insert into a.db values(1,2,3)
			fseek(fp,0, SEEK_END);    // move rw position to the end to write
			int pos = ftell( fp) ;    // rw postion
			index[key]={key,pos,1} ;  // 1 indicates that the index of key is 
						   // valid, key has not been deleted
			fputs("%d,%d,%d",key,col1,col2) ;	
			
		D 1 from a.db: delete from a.db where key=1
			int valid = index[key].valid;
			if not valid:
				printf("dont exit") ;
				return ;
			index[key].valid = NOT_VALID
		U 1 (3,4) from a.db: update a.db set col1=3, col2=4 where key=1
			int valid=index[1].valid;
			if not valid:
				printf("dont exit") ;
				return ;
			int pos = index[1].pos;
			fseek(fp, pos, SEEK_SET);
			fputs(%d,%d,%d",key,col1,col2) ;
	 	S 1 from a.db: select * from a.db where key=1
	 		int valid=index[1].valid;
	 		if not valid:
	 			printf("don't exist")    ;
	 			return ;
	 		int pos= index[1].pos;
	 		fseek(fp, pos, SEEK_SET) ;
	 		fgets("%d,%d,%d",&key,&col1,&col2) ;
	
	index
		use hash table to index
		in MySQl, use B+ tree to index
	
	storage
		use file to store database file
*/
	/*
	stdio/stderr, scanf/printf, gets/puts
	fileio, fscanf/fprintf, fgets/fputs
	*/
	char fname[20] ;
	char idxname[40] ;
	char row[100];
	FILE *fp, *ifp ;
	char op ;
	int cnt ;
	while(1){
		printf("Command C, I, D, U, S, P, Q: ") ;
		gets(row);
		
		if( row[0] == 'Q'){
			break ;
		}else if( row[0]=='C' ){
			sscanf(row, "C %s", fname) ;
			
			sprintf(idxname, "%s.idx", fname) ;
		
			if( !(fp = fopen(fname,"r") ) ){
				fp = fopen(fname,"w") ;
				fclose(fp) ;
			}
			fp = fopen(fname,"r+") ;
			
			if( !(ifp = fopen(idxname,"r") ) ){
				ifp = fopen(idxname,"w") ;
				fclose(ifp) ;
			}
			ifp = fopen(idxname,"r+") ;
			 
			int idx=1;
			//printf("Index:\n") ;
			while(!feof(ifp)){
				fscanf(ifp,"%d %ld %ld %d",&index[idx].key, &index[idx].Fpos, &index[idx].Ipos, &index[idx].valid) ;
			
				idx++;
			}
			cnt = idx-1 ;
			printf("Comand C: cnt=%d\n",cnt) ;
		}else if( row[0] == 'I'){
			int key= cnt++, col1, col2 ;
			sscanf(row, "I %d %d", &col1, &col2) ;
		
			fseek(fp,0, SEEK_END);    // move rw position to the end to write
			long pos = ftell( fp) ;    // rw postion
			
			fseek(ifp,0, SEEK_END);
			long Ipos = ftell( ifp) ;
			index[key].key = key ;
			index[key].Fpos = pos ;
			index[key].Ipos = Ipos ;
			index[key].valid = VALID ;  // 1 indicates that the index of key is 
						   // valid, key has not been deleted
			fprintf(fp, "%d %d %d\n",key,col1,col2) ;
			
			fprintf(ifp, "%d %ld %ld %d\n", key, pos, Ipos, VALID) ;
			
			printf("%d: %d %d, Fpos=%ld Ipos=%ld %d\n", key, col1, col2, pos, Ipos, VALID) ;
		}else if( row[0] == 'D'){
			int key, col1, col2 ;
			sscanf(row, "D %d", &key) ;
		
			int valid = index[key].valid;
			if( key<1 || key>=cnt || !valid){
				printf("invalid id\n") ;
				continue ;
			}
			index[key].valid = NOT_VALID ;
			fseek(ifp, index[key].Ipos, SEEK_SET) ;
			fprintf(ifp, "%d %ld %ld %d\n", key, index[key].Fpos, index[key].Ipos, NOT_VALID) ;
			
			printf("%d: de-Valid\n",key) ;
		}else if( row[0] == 'U'){
			int key, col1, col2 ;
			sscanf(row, "U %d %d %d", &key, &col1, &col2) ;
			
			int valid = index[key].valid;
			if( key<1 || key>=cnt || !valid){
				printf("invalid id\n") ;
				continue ;
			}
			
			long pos = index[key].Fpos;
			fseek(fp, pos, SEEK_SET);
			fprintf(fp, "%d %d %d\n",key,col1,col2) ;
			
			printf("%d: update\n",key) ;
		}else if( row[0] == 'S'){
			int key, col1, col2 ;
			sscanf(row, "S %d", &key) ;
			
			int valid = index[key].valid;
			if( key<1 || key>=cnt || !valid){
				printf("invalid id\n") ;
				continue ;
			}
			
			select(fp, key) ;
	 	}else if( row[0] == 'P'){
			if( row[1]=='F'){ //display databasea
				for( int i=1;i<cnt;i++){
		 			if( index[i].valid == VALID){
		 				select(fp, i) ;
		 			}
		 		}
		 	}else if( row[1]=='I'){//display index file
		 		for(int i=1;i<cnt;i++){
		 			
		 			if( index[i].valid == VALID){
		 				printf("%d %ld %ld %d\n",index[i].key, index[i].Fpos, index[i].Ipos, index[i].valid) ;
		 			}
		 		}
		 	}
	 	}
		
	}
	fclose(fp) ;
	fclose(ifp) ;
	
	return 0;
}

```

![Screenshot 2022-10-18 211906](实验\数据库实验\实验1-实现SQL解析、索引、文件存储的简单数据库\实验截图\Screenshot 2022-10-18 211906.png)

## 数据库基本知识

- 数据库保存在磁盘中而不是内存中，磁盘寻址速度是毫秒级别，存储容量很大，数据传输带宽是G或者M；内存寻址速度是纳秒级别，存储容量较小，带宽很大；可见内存寻址速度是磁盘寻址速度的100万倍。磁盘分区的大小是512B，也就是磁盘基本单位是512B，而操作系统一次读取数据是4K，为什么操作系统读取数据大小比磁盘基本单位大，因为为了节约地址总线个数，节约成本，减少寻址的粒度。

- 使用文件系统保存数据的缺点是无法建立索引，需要全局查找，效率低，而且全局查找需要IO读入所有数据，更造成巨大的读磁盘开销。而使用数据库的优点就是可以建立索引加快查找速度。查询文件速度慢原因：一个是要顺序查找，时间复杂度O(n)，另一个是要全部读完数据，访问磁盘太多，而访问磁盘是IO瓶颈

- 数据库按4K存储数据，这和操作系统访问数据一次读取数据大小相同，这样设计数据存储数据大小大于等于4K的好处是不会浪费一次访问磁盘读取的数据大小。如果数据库设计存储单元大小小于4K，比如1K，操作系统一次读取依旧是4K，这样就有3K是浪费的了。而这样造成的结果就是增加操作系统访问磁盘次数。所以数据库基本单元设计要是4K的倍数。如果数据库仅仅只是使用4K作为存储单元，并没有比文件系统更好，查找他依旧是全量IO，这个时候引申出索引。

- 关系型数据库在创建数据库的时候需要一个schema，这个schema确定之后，那么数据库存储一行数据的大小就确定了，那么数据库的每一块存放的数据库的条数也就确定了。

- 数据库索引保存在磁盘里，B+树的非叶节点存储的是关键字和儿子节点的索引，这些关键字和儿子节点的索引被分成4K大小存放。在运行的时候，操作系统会读取数据库B+树索引的根节点到内存。每次访问数据库约束的时候，操作系统根据B+树根节点找到关键字所处的儿子节点，然后根据儿子节点地址访问磁盘获得新的B+树非叶子节点的新的4K块，如果访问这个非叶子节点找到关键字所在的叶子节点，那么查询这个叶子节点的关键字数组，找到对应的关键字，而关键字里面保存着这个关键字所对应的行数据，这样你就可以返回得到你要查找的数据。

  B+树叶子节点只需要保存Key和Key多对应的行数据就行。

  B+树有两种节点，一种是非叶节点，一种是叶子节点。非叶节点包含单纯的key和指向儿子节点的指针；叶节点的key需要存储行数据，并且他没有儿子节点指针，但是他有一个链表指针。

  创建B+树的时候初始化一个叶子节点A作为根节点。然后不断给这个根节点假数据key_数据，直到这个叶节点分裂，分裂的时候创建一个非叶节点B，这个非叶节点增加一个关键字是A的中间关键字，这里只是给非叶节点的关键字数据增加一个关键字而已，而不是增加关键字和数据组合。增加关键字后，非叶子节点B添加两个分别指向分裂的A节点的指针A1和A2，然后把你的key和数据重新从B节点遍历，找到他应该去的位置，或者是A1或者是A2进行插入。这样就完成了B+树索引的创建和B+树数据的插入。在这个过程中，A节点保存在内存 中，需要一次分裂移动。数据项key插入之后，查找数据的小于key的节点和大于key的节点找到他的前驱节点和后继节点，然后把新的key数据节点插入到这个链表里面。这样就能形成一条链表，支持范围查询。为了方便获得前驱和后继节点，这也是为什么B+树关键字是按照数字1，2，3来的，因为可以通过直接加减1获得前去和后继节点。这样的好处还有一个是如果要删除一个节点，你不需要变动B+树，你只需要把对应的叶节点的Key节点删除就行了。B+树所有叶节点是登高的，因为所有的叶节点都是从初始的叶节点开始分裂得到的，一个新的叶节点总是一个叶节点分裂创建的。

- 数据库表很大是否会造成SQL性能下降？

  如果是少量SQL指令，不会；但是如果并发度太大，那么请求磁盘量增大，会触发IO瓶颈，造成SQL性能下降。

  磁盘级数据库（数据库保存在磁盘，对应的是内存级数据库，数据库保存在内存）在数据库表很大的时候，在高并发的情况会造成IO瓶颈从而导致SQL性能下降。这个时候提出了缓存的概念，比如Redis。

  Redis可以达到秒级十万操作，这个操作数远远大于MySQL等关系型数据库，他是秒级一千操作。

- Redis相较于MemChached的优势

  两个都是关系型数据库，但是Redis的优势是有数据类型，而MemChached没有数据类型的概念，他的所有存储都是字符串。这样造成的结果是，当客户端请求key-value中value的某一项数据的时候，Redis和MemChached性能不一样。MemeChached会返回所有的Key所对应value，需要用户自己去解析value中的某一项数据。这不仅增加了客户端写代码的复杂，而且返回的value中存在很多冗余数据，造成的结果是增加IO网络瓶颈。而Redis有类型的概念，这些类型提供了很多方法处理每个类型，这样，客户端请求数据的时候如果是value的某一项，比如value是一个数组类型，那么取数组中的一项之后返回给客户端，这样不会有冗余数据并且不会让客户端写代码处理数据，非常高效。这个在服务端完成对用户数据请求的解析的过程叫做计算向数据移动。
  
- 同步与异步  阻塞与非阻塞

  [参考](https://www.zhihu.com/question/19732473)

  [参考](https://www.cnblogs.com/loveer/p/11479249.html#!comments)

  从大的概念来说，同步和异步描述的是函数调用时两个函数之间的关系，关注的是函数调用的消息通知机制，如果A调用B，A必须等待B返回结果，那么这个过程是同步的；如果A调用B，A不用等待B返回最终的结果，可以是返回一个部分的或者null的结果，A继续执行，而B在准备好结果之后使用状态或者通知机制通知A处理返回结果，这个过程就是异步。从大的概念，阻塞和非阻塞关注的是一个对象的状态，关注的是函数调用时调用者的状态，如果A调用B，A被阻塞挂起，处于waiting状态，那么就是A就是阻塞的；如果A调用B，A没有挂起而是依旧处于Running状态，那就是非阻塞的。

  在UNIX的IO里，同步是指调用进程使用IO系统调用之后需要等待操作系统执行完数据准备和数据从内核缓冲区拷贝到用户缓冲区后才能继续执行后面的操作；而异步是指进程使用IO系统调用之后进程不用等待操作操纵系统完成数据准备和数据拷贝到用户缓冲区这个过程完成，而是可以直接执行后面的操作，操作系统在完成数据准备和拷贝到用户缓冲区之后会使用进程提供的处理函数进行处理或者通知进程处理。而阻塞是指进程在调用IO系统调用后等待操作系统完成数据准备和拷贝用户空间的状态，如果进程被挂起处于waiting状态，那么就是阻塞式IO，如果没有被挂起而是使用轮询不断检查操作系统是否准备好数据并且处于Running状态，那就是非阻塞式IO。

### SQL

#### 查询

```
//求任意两个老师的薪水差额
select t1.name as t1n, t2.name as t2n, t1.salary-t2.salary
from Teacher t1, Teacher t2
where t1.salary>t2.salary;

//根据学生年龄计算学生出生年份，当前年时2015
select s.name as name, 2015-s.age as year
from Student s ;

//聚集函数
count //求个数
sum //求和
avg //求平均
max //求最大
min //求最小

//求教师总工资
select sum(t.salary) 
from Teacher t ;

//求计算机系老师总工资
select sum(t.salary)
from Teacher t, Department d
where d.name='计算机' and d.tid=t.tid;

//分组查询和分组过滤
//查询计算机系老师的总人数
select d.name as name, count(d.tid) as number
from Department d
group by d.name;

//查询不及格课程成绩超过两门的所有学生学号
//分组过滤
select s.sid
from Student s
where s.score<60
group by s.sid 
having count(*)>2 ;


//求课程不及格超过两门的学生的平均成绩
select s.sid as sid, avg(s.score) as score
from Student s
where s.sid in 
	(select s1.sid 
	from Student s1
	where s1.score<60
	group by s1.sid
	having count(*)>2)
group by s.sid;


//学生成绩前十个
select *
from student
where score>60
order by score
limit 10;
```

#### 集合运算

```
//求学过2号课或者3号可的学生学学号，与
select s.sid
from student s
where s.cid=2
union
select s.sid
from student s
where s.cid=3;

//求学过2号课和3号课的学生学学号，交
select s.sid
from student s
where s.cid=2
intersect
select s.sid
from student s
where s.cid=3;

//求所有没有学过2号课的学生，差
select s.sid 
from student s
except
select s.sid
from student s
where s.cid = 2;
```

#### 空值

```
//找出年龄为空的学生姓名
select s.sid 
from student s
where s.age is null;
```

#### 关系运算

```
//内连接
//求所有老师的课程并按教师号排序
select Teacher.name, Course.name
from Teacher Inne Join Course
on Teacher.tid = Course.tid
order by Teacher.tid

//左外连接 left outer join
//右外连接 right outer join
//全外连接 full outer join
```

### 范式

1NF，属性原子性

2NF，在满足1NF条件下，非主属性完全依赖于候选键

3NF，在满足2NF条件下，非码属性不传递依赖于非码属性

BCNF，不存在函数依赖不依赖候选键。

### 数据库存储和检索

数据库存在磁盘上

#### 数据在磁盘上如何组织

1. 操作系统管理文件的方式：

   文件存储在磁盘块中，每一块512B，操作系统使用文件目录表和FAT（File Allocation Table）文件分配表管理文件系统。文件夹（文件目录）保存了文件的第一个磁盘块所在的位置（一个指向磁盘块的块号），文件分配表FAT按链表保存下一个磁盘块的位置，读取文件以链表的方式根据目录表和FAT表从磁盘中读取。

2. 操作系统内存管理：

   内存被划分成一块一块的（页号），寻址总是以页号：页内偏移找到内存记录的，一个页面对应磁盘的磁盘块。

3. 数据库存储的方式

   

**磁盘管理**

磁盘由（盘面：磁道：扇区）组织

磁盘读写单位是块，一个块是多个连续的扇区

读磁盘方式：读写臂移动到对应的磁道（寻道时间在1-20ms），然后旋转盘面找到对应的磁盘块扇区（旋转时间在0-10ms），然后传输数据（传输时间在每4k小于1ms）

一个磁盘基本信息示例：

- 磁盘示例：一个磁盘由8个圆盘（16个盘面，上下两个盘面），每个盘面由2^16=65536个磁道，每个磁道由2^8=256个扇区，每个扇区由2^12=4096个字节，标准扇区字节大小是512B

- 磁盘以7200转/min，那么8.333ms转一圈
- 读写臂从启动到停止要时间1ms，读写臂每移动一个磁道勇士1ms，也就是移动一个磁道勇士0.00025ms内移动一个磁道，从最内圈磁道移动到最外圈磁道65536个磁道移动用时17.38ms
- 磁道中扇区间的空隙大约占整个磁道百分之十的空间
- 一个磁盘块由4个扇区。
- 读取一个磁盘块的最小时间只有传输时间，比如传输时间0.13ms；最长时间是寻道时间+旋转时间+传输时间=17.38+8.33+0.13=25.84ms

磁盘存取算法考虑的关键

- 降低IO次数
- 降低排队等待时间
- 降低寻道/旋转延迟时间
  - 同一磁道连续块存储
  - 同一柱面不同磁道并行块存储
  - 读个磁盘并行块存储



## Redis

- Unix网络编程

  [基础介绍](https://www.jianshu.com/p/b8203d46895c)

  [基础介绍](https://www.jianshu.com/p/397449cadc9a)

  [多路复用IO的三种实现方式select poll epoll](https://zhuanlan.zhihu.com/p/400798093)

  [epoll底层实现原理](https://zhuanlan.zhihu.com/p/487497556)

  Unix进程IO分为两个阶段，操作系统准备数据阶段和操作系统从内核缓冲区拷贝数据到用户缓冲区。Unix进程IO分为五个方式，其中第四个方式不常用

  - BIO, 阻塞IO（Blocking IO)

    用户调用recvfrom系统调用请求操作系统准备数据，然后自己被阻塞。操作系统准备好数据并且把数据从内核空间拷贝到用户空间之后，会检查阻塞队列并且唤醒用户进程，用户进程继续执行。这个过程的特定是用户进程在操作系统准备数据和把数据拷贝到用户空间两个过程都被阻塞

  - NIO，非阻塞IO（NonBlocking IO）

    用户调用recvfrom之后不是被阻塞，而是操作系统返回一个EWOULDBLOCK的响应，用户进程通过这个响应自循环，直到操作系统准备好数据，而用户调用recvfrom系统调用之后操作系统会把用户进程阻塞，直到把内核空间数据拷贝到内核空间之后才返回，把用户进程解除阻塞，让用户进程重新执行。这个过程的特点是用户进程在操作系统准备数据阶段没有被阻塞，但是在拷贝数据到用户空间的时候会被阻塞

  - 多路复用IO

    一个用户进程监控多个Socket描述符。用户进程使用select、poll、epoll等监控多个socket描述符，自己被阻塞，等到操作系统将他唤醒，之后用户进程调用recvfrom系统调用让操作系统拷贝数据到用户空间，用户进程被阻塞，直到拷贝完成重新唤醒执行后面的操作。

    - select

      select是一种多路复用IO的实现方式，他被用户进程调用，然后他阻塞用户进程，用户进程传递一个fd_set作为文件描述符集合，每次用户调用一次select那么select就会把这个集合拷贝到内核空间，select会轮询监视这个bitmap的文件描述符，如果发现一个或者多个数据准备好了，就会返回和唤醒用户进程，用户进程调用recvfrom让操作系统拷贝数据到用户空间，这个过程用户进程接着阻塞。然后用户进程重复上面的过程。

      select的好处是

      使用一个进程处理多个socket描述符，避免了多进程阻塞IO（BIO）时维护多进程和进程切换的开销，而每次进程切换都要花几纳秒。这里的复用指的是只有一个线程。

      select的缺点是

      1. 每次到用select就要拷贝fd_set到内核空间，增加开销
      2. 底层使用轮询检查文件描述符是否准备就绪，增加开销
      3. 支持监视的文件描述符有限，只有1024个

    - poll

      poll是select的改进版本，底层使用链表实现，他的文件描述符的结构和select不同，他也需要拷贝文件描述符集合到内存空间，并且轮询检查文件描述符集合返回给用户准备好了的文件描述符集合。他相较与select的优点是他支持的文件描述符个数没有限制，而select最多1024

    - epoll

      epoll底层用红黑树保存文件描述符，使用链表保存就序列表，增加查询文件描述符效率。用户使用epoll_create创建一个epoll数据结构，然后调用epool_ctl将socket添加到数据结构上，之后调用epoll_wait把自己阻塞。当操作系统接收到完整的数据的时候，会把文件描述符从红黑树取下来包装成epitem放到就绪队列里面，并且在阻塞队列里面通知阻塞进程去执行这些就绪队列的数据。epoll检查就绪不是使用轮询，而是使用事件驱动，减少了轮询开销。

      epoll在高并发环境是很高效的，高并发条件下复用的进程根本不会被阻塞，因为就绪队列总是有数据，那么他调用epoll_wait的时候总是会去执行数据处理。

      epoll在少量数据连接的时候可能使用阻塞IO更好

  - 信号驱动IO

  - AIO，异步IO，常用于文件处理而不是网路处理

    用户进程调用aio_read系统调用之后操作系统准备数据，而进程不会被阻塞，而是继续执行。之后操作系统准备好数据并拷贝到用户空间之后通知用户进程处理或者直接使用用户进程提供的处理方法处理。

- Redis是单进程单线程单实例处理用户请求

  使用epoll的NIO机制处理IO请求。

- 使用Redis

  Redis默认准备了16个库，获取数据的时候可以指定存储的库，通过select选择使用的库

  ```
  select 1 //选择1号库
  set a hello
  get a  //会返回hello字符串
  select 8 //选择八号库
  get a  //返回(nil)
  ```

  ```
  //基本操作指令
  keys * //返回所有创建的key
  FLUSHDB //清空Redis所有缓存，删库
  ```

### Redis数据类型

key数据结构包括key、value type、encoding等，这些属性可以用来检测一些异常，可以类型总是string的，只有value有物种类型

value类型

- string

  string类型可以具体分为字符串、数值、bitmap

  - 字符串操作有set\get\append\setrange\getrange\strlen

  - 数值有incr自增，这个方法的好处是对于不是很重要的数据，比如秒杀、抢购等数据可以很快自增而不需要使用MySQL数据库进行事务处理，可以很快返回数据给客户端。但是这个方式不适用银行等数据，他必须使用事务持久化，所以不能用于Redis缓存。
  - bitmp类型

  可以对字符串value的操作

  ```
  set key 123
  get key 
  setrange key offset value
  getrange key start end
  append key value
  type key //描述value的类型
  ```

  字符串还有支持对数值的操作，这依赖于string用数值进行编码，这样使用object encoding key命令可以查看对应key的value被用什么编码，编码方式有int, enstr, raw等，可以对应支持不同操作。

  ```
  object encoding key
  ```

  Redis一些命令会改变value的类型，比如如果是raw的99，调用incr会加一成为10000，同时类型变成int，但是你调用strlen的时候，他依然是按照字符的方式返回字符的个数。

  getset命令的好处，本来用户可以先使用get获得数据，再使用set更改，但是这样会发送两条指令，所以把他们合并就只会发送一个指令，也只会像网络发送一个数据包。

  Redis获取的数据是按照二进制数据的方式保存在数组里，而不是按照一定的编码方式保存数据。这样，Redis可以保存任何类型的数据，包括媒体类型和字符类型。因为他的数据保存和读取是没有类型的，而是二进制的。Redis默认的数据类型是ASCII码，如果你使用中文编码，他不会显示中文，而是直接返回给你十六进制数，当你在启动客户端的时候使用

  ```
  redis-cli -raw
  ```

  他能使用中文编码显示。

   对bitmap的操作，bitmap是按照字节保存的，每个字节是8位，setbit key 1 1，会在第一个字节的第二个比特位放1，setbit key 9 1会在key的第二个字节的第二个比特位置一。

  bitmap的用法

  - 统计用户登录天数，你可以用MySQL来存，但是完全可以用Redis位图来做更快。bitmap把每一位当成一天，某天登录就把那一天的位置为1，这样就可以统计位数个数得到登录天数。一年365天,365/8=46，46个字节就可以保存一个登录天数。

    ```
    setbit 1 1 1
    setbit 1 2 1
    setbit 1 7 1
    bitcount 1
    ```

  - 统计活跃用户

    ```
    setbit 20190101 1 1
    setbit 20190102 7 1
    setbit 20190102 1 1
    
    bitop or destkey 20190101 20190102 //按位或操作
    bitcount destkey 0 -1
    ```

    制作一个按天的bitmap，将天数按位或，得到destkey，统计destkey的1的位数得到活跃用户数

- List

  list是一个包含头节点和为节点head和tail的双向链表

  ```
  lpush key 1 2 3 4 5 //头插法
  rpush key 1 2 3 4 5 //尾插法
  lpop key //头部弹出
  rpop key //尾部弹出
  
  lrange key 0 -1 //打印所有列表内容，key支持正负索引
  lindex key 0 //索引下标，类似数组
  lrem key 2 a //从头节点开始删除2个a
  ```

  List作用是可以实现栈和队列

- hash

  ```
  hset sean name zzl age 18 address bj //创建sean:{
  													name:zzl
  													age :18
  													address:bj
  												}
  hget sean name age //取值
  hkeys sean //取sean的key
  hvalues sean //取sean的values
  hgetall sean //取key和values
  ```

  哈希可以用来保存用户详情页（喜欢点赞等）

- set

  List是有序的可重复的。set是无序的去重的集合。支持集合操作，支持从集合中随机取一个shu

  ```
  sadd key1 1 2 3
  sadd key2 3 4 5 
  smembers key1
  sinter key key1 key2 //交集到key
  sdiff key key1 key2  //减法
  sunion key key1 key2 //并集
  
  srandmember 用来做抽奖程序
  ```

- zset( sorted_set)

  ```
  zadd k1 8 apple 2 banana 3 orange
  
  zrange k1 1 2  //前两个大小
  ```

  用处，歌曲排行榜前十名，也可以集合操作

  zset使用跳跃表保存数据。

### Redis为什么快

- 数据量很大的时候需要集群，集群分为主从式（约束：配置相同、同步、副本高可用），分片（约束：每一台不完整，聚合数据成本高，甚至不支持）。Redis不支持聚合操作。Redis做集合运算并不快。

### Redis事务

Redis事务提交提案检查指令的语法合法才提交，一旦提交会全部执行，即使中间有报错也不会回滚

```
multi //开始事务
set a 1
set b 2
exec  //执行事务
```

Redis事务只保证原子性，不支持回滚，在执行过程不会被其他线程打断。

Redis不支持回滚一是认为失败应该由编写方完成，而是不支持回滚可以保持事务的简洁快速。



微服务-服务治理

脚手架：spring boot, netty

中间件：SSM

底层：计组，内核，网络、IO

其他：分布式解决方案（锁、事务、一致性、幂等性）- kafka - ISR，CAP，设计模式，算法

### Redis使用场景

- 五大数据类型
- 用于缓存
- 为了服务无状态
- 无锁化

### Redis是单线程还是多线程，Redis是线程安全的

1. 无论什么版本，工作线程都只有一个
2. 6.x版本之后，IO线程出现了多线程，但是工作线程依旧只是一个。在以前，工作线程需要自己负责recvfrom系统调用对每一个就绪的描述符，而现在这个过程被IO多线程处理。这里的IO线程是用户进程通知操作系统把内核数据拷贝到用户空间。IO多线程造成数据输入输出并行，但是工作线程负责计算，依旧线性的。
3. Redis工作线程是单线程，但是IO线程是多线程。好处是执行时间更短，更好压榨系统和硬件资源。
4. Redis工作线程是单线程的，他的计算是串行的，所以是线程安全的，但是外部事务在使用的时候要保证自己的顺序。

### 缓存穿透、缓存击穿、缓存雪崩

1. 缓存穿透：数据库没有这个缓存：布隆过滤器，锁（挡住无效请求和重复请求）

2. 缓存击穿：热点数据过期

3. 缓存雪崩：大量热点数据过期。

   分布式微服务，微服务扩缩容

### 缓存如何过期、淘汰、回收，缓存预热

- 如何回收

  1. 后台线程轮询，分批分段删除过期key
  2. 请求数据的时候判断数据是否过期

- 如果淘汰

  内存空间不足，一种机制是不允许淘汰，其他的是LRU LFU random TTL

- 缓存预热

  提前把热数据放到缓存，因为我们不知道什么是热数据，依然会产生很多缓存不命中，那么我们可以采用加锁处理

### 如何处理缓存和数据库不一致

canal binlog

MQ  函数式编程  server less

Redis是缓存，倾向于有时差。

架构：用户层、接入层、业务层、服务层、基础设施层

### Redis主从不一致问题 Redis主从复制原理

1. redis默认弱一致性，异步的同步
2. 所不能主从，单实例/分片集群/redlock，redisson
3. 咋配置中提供了多个client连接同步，趋向一致性
4. wait 2 0

- 主从复制原理

  master和slave连接正常时，maste发送命令流保持对slave更新

  当master和slave连接断开或超时，slave重新连接上master时会部分重同步恢复在没有连接的数据

  如果部分重同步 失败，会触发全量重同步。

### Redis持久化原理和方式

- 方式

  1. RDB， AOF
  2. 主从同步也是持久化
  3. 高版本开启AOF，可以通过执行日志得到全部内存数据

- 原理：

  阻塞当前线程，异步后台进程完成持久化，fork+copy on write

  RDB会按时fork一个进程拷贝数据到磁盘，如果想获得完整数据，不适合RDB，因为是隔一段时间执行，Redis宕机会丢失数据。

  AOF往AOF文件追加命令到日志文件。AOF会造成新能下降。但是你想保证数据完整新就要取舍。AOF在很大的时候，Redis可以对AOF进行重写（一些指令可以被取消

### 为什么使用setnx

原子操作，可以实现分布式锁

### Redis集群方案

- 常见集群分类

  主从复制集群

  分片集群

- Redis有哪些集群

  主从复制集群，手动切换

  带有哨兵的主从复制集群

  客户端实现路由索引的分片集群

  使用中间件代理层的分片集群

  Redis自身实现的cluster分片集群

## MySQL

### 事务（ACID、锁，MVCC）

- 原子性，要不全部执行，要不全部不执行。如果执行失败，要回滚。原子性的实现原理使用的时undolog来回滚。日志有undolog、redolog、binlog，undolog。undolog和redolog不属于MySQL server 而是属于MySQL innodb存储引擎，binlog是MySQL自带的日志。不同的引擎数据存储方式不同。undolog是对成功执行的指令的反命令，如果是delete，那么就是insert，如果是update，那就update相反的，主要是增删改的操作。

  - 快照读，读取的是历史版本，例如select，不加锁的非阻塞读，快照读的实现是基于MVCC，读取的不一定是最新版本。RR是快照读，他不能读到最新数据。
  - 当前读，读取的是最新数据，如update, insert, delete, select ... lock in share mode, select ... for update，当前读是加锁读，读取期间其他食物不能修改数据。RC可以当前读

- 一致性，事务执行前后一致，包括安全检查等。这由其其他三种特性保证

- 隔离性，各个事务相互独立，不相互影响。实现方式有锁和MVCC。MySQL保证隔离性使用的是MVCC。MVCC是一种并发读写不加锁的方案。

  **锁**

  - 读读不会有数据安全问题

  - 读写：MVCC，多版本并发控制解决数据读写问题。

    **mysql 开启事务**

    ```
    set autocommit=0;
    commit;
    begin ;
    update t26 set name='123' ;
    commit ;
    ```

    **mysql删除表**

    ```
    truncate table t26 ; //清楚表的内容而不是删除整个表
    ```

  - 写写：锁

  **锁分类**

  - 按照粒度

    行锁

    表锁

  - 范围

    行记录锁

    间隙锁

    临键锁

  - 读写

    排他锁（写锁）

    共享锁

  - 应用场景

    悲观锁

    乐观锁

  **MVCC原理**

  MVCC是解决读写冲突时的无锁并发控制，也就是为实物分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照，所以MVCC为数据库解决了两个问题：1. 在并发读写数据库的时候，可以做到读操作不阻塞写操作，写操作不阻塞读操作，提高数据库并发读写能力。2. 解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题。

  - 隐藏字段

    隐藏字段是在创建表的时候自动创建的字段

    1. DB_TRX_ID，创建或最近修改该记录的事务ID
    2. DB_ROLL_PTR，回滚指针，记录上一个旧版本
    3. DB_ROW_ID，隐藏主键，默认6字节

  - undolog

    MVCC的undolog在添加一条新的记录时会初始化一个新数据，建立DB_ROLL_PTR=null，DB_TRX_ID指向创建他的事务；在更新事务的时候创建一条新记录为更改后的，然后DB_ROLL_PTR指向修改前的数据行的地址，DB_TRX_ID指向修改的事务。这样undolog形成一条链表

  - readview

    事务在执行快照读的时候会生成一个readview

    readview有三个属性值，trx_list表示readview生成时刻的活跃事务列表（commit的事务不是活跃事务）；up_limit_id表示列表中最小的事务ID，low_limit_id表示即将分配的下一个事务ID

    **为什么读已提交和可重复读读到的数据不一样**

    快照读是按照可见性算法来得到的读取结果

    关键在于RC和RR在生成readview的时机不同，RC每次快照读都会重新生成redview，而RR当前事务第一次进行快照读的时候生成的readview，在接下来的快照读会延用。

    **可见性算法**

    当前执行快照读的事务生成readview，当前没有执行commit的事务都放到活跃事务列表

    如果数据的上一个修改的事务DB_TRX_ID小于所有活跃事务列表的ID，那么说明他已经提交，当前事务可读取DB_TRX_ID的数值

    如果 DB_TRX_ID>=low_limit_id，。。。

    否则，判断DB_TRX_ID是否在活跃事务列表，如果在，则说明他未提交，当前事务不可见DB_TRX_ID的修改，如果不在，说明DB_TRX_ID已经修改，当前事务可见。

  **隔离级别**

  [参考](https://cloud.tencent.com/developer/article/1450773)

  读已提交和可重复读差异是因为readview生成时间不同造成的

  - 读未提交

    读未提交可能发生**脏读**、**不可重复读**、**幻读**

    读未提交是事务的快照读可以读取另外事务的修改数据，但是这个修改数据可能不是最终的数据，只是一个中间数据，那么就会发生**脏读**。

    **脏读**是事务执行过程中读取了其他事务没有提交的数据。

  - 读已提交

    读已提交可能发生**不可重复读**、**幻读**

    读已提交是读取已经提交的事务的数据。

    读已提交实现方式是每次快照读都要修改readview的三个属性值然后执行可见性算法，从而保证总是读取了已经提交的数据。

    **不可重复读**是事务两次执行快照读过程中，因为其他事务发生了对数据的修改，造成事务两次读数据不一样。解决不可重复读可以使用可重复读的MVCC协议，加行级锁。

    **幻读**是事务两次执行快照读整个表的属性时发生的因为其他食物发生了对整个表的增加或者删除导致的表的属性不一致。比如说一个事务两次读表的大小，中间发生数据增加，结果造成事务两次读表的大小不一致。解决幻读使用表级锁。

    **幻读和不可重复读区别**，幻读关注的是表的行数不一致，解决办法是表级锁；不可重复读关注的是表的行数据不一致，解决办法是行级锁。

  - 可重复读（MySQL默认隔离级别）

    可重复读可能发生**幻读**

    MySQL实现可重复读的底层原理是第一次快照读的时候生成的readview被后面的快照读服用了trx_list, up_limit_id, low_limit_id，造成后面执行序列里面提前commit的其他事务没有被更新到trx_list，从而总是被当成还未提交状态，这样总是读取的第一次快照读的数据。

  - 串行化

- 持久性，数据保存到磁盘，即使系统崩溃也不会丢失数据。持久性实现原理是redolog。redolog的二阶段提交，是为了redolog和binlog的数据一致性。binlog会一直写。WAL顺序读写随机读写，write ahead log。保证redolog和binlog一致性使用的是两阶段提交

### MySQL调优

#### 连接进程相关的connection

```
//max_connections
show variables like '%max_connection%' ;//显示默认MySQL的最大连接数
set max_connections=1024; //设置MySQL最大连接数，最大连接太多会造成延迟高

show processlist; //显示所有MySQL连接。
//max_user_connections; 限制每个用户请求连接个数

//back_log
show variables like '%back_log%'; // back_log参数，如果请求连接大于max_connection,请求会被放入堆里面缓存，如果缓存大于									  back_log限制，这个请求会被拒绝。这个值不能设置过大，因为那样每个客户请求会被放入堆
									 里面缓存，客户要等待连接，这对客户不友好，客户只是感觉到发送请求没响应。所以干脆给出请									 求太多等拒绝策略
//wait_timeout //关闭一个非交互连接需要等待时长
//interactive_timeout //关闭一个交互连接需要等待时长
```

#### log日志参数设置

```
log_error 错误日志名称
log_bin  二进制日志名称，记录对数据造成更改的所有语句，主从复制需要binlog，binlog默认不开启，需要手动开启。binlog执行需要写入到磁盘，所以会影响性能
```

### MySQL主从复制原理

master节点上对数据库增删改操作被记录到binlog文件，之后通过一个IO thread写入到slave节点的relay log（中继日志）里面，然后slave上的一个SQL thread会把relay log重新执行一遍，从而把数据写入地盘。MySQL主从复制是一种异步复制，主机不用等待从机复制好所有的数据才返回。

1. master服务器将数据改变记录到二进制binlog日志，当master上的数据发生改变时，会将他写入二进制文件
2. slave服务器会在一定时间间隔内对master二进制日志进行探测，他是否发生改变，如果发生改变，就开始一个IO线程请求mster的二进制文件。
3. 同时master节点为每个IO线程启动一个dump线程，用于向其发送二进制时间，并保存从节点本地的中级日志中，从节点将启动SQL线程从中继日志中读取二进制日志。在本地重放，使得其数据和主节点保持一致，最后IO线程和SQL线程将进入睡眠状态，登台下一次唤醒。

### MySQL聚簇索引和非聚簇索引

索引存在磁盘。

聚簇索引索引和数据放在一个文件里，在Innodb里面，数据和索引全部放在ibd文件中，而myisam数据放在myd文件中，而索引放在myi文件中，索引和数据时分开的。Innodb有一个聚簇索引和多个非聚簇索引，而myisam只有非聚簇索引。

####  索引原理

MySQL索引主要使用两种数据结构，B+树和Hash索引

Innodb默认是B+树索引

Memory存储引起使用Hash索引。Memory表只存在内存中，断电会消失，适用于临时表。Memory使用hash表存储是因为他比B+树更快，但是他不能支持范围查询和排序等功能。B+树单条查询新能低于hash表，但是它支持排序和范围查询。hash表范围查询需要全量查找。

B+树作为索引的优势

hash索引不支持范围查询，也不支持like这样的模糊查询

hash索引不支持多列联合索引的最左匹配原子

Hash索引存在hash碰撞问题

### MySQL锁

- 按属性分

  - 共享锁：又叫读锁，共享锁主要用于并发读数据，事务为数据加上读锁以后，其他食物只能对该数据加读锁而不能加写锁，直到所有读锁释放之后其他事务才能加写锁

  - 排他锁：又叫写锁，排他锁主要目的是事务在修改数据的时候不允许其他事务修改或者读取。当事务为数据加写锁以后，其他事务不能给数据加任何锁，包括读锁或者写锁。

- 按锁的粒度分类

  - 行锁，对表的一行或者多行加锁，事务可以访问没有加锁的数据，不能访问加锁的数据。行锁的优势是力度小，不容易冲突，比表锁支持的并发要高，但是加锁比表锁麻烦
  - 表锁，对整个表加锁，下一个事务访问这个表的时候必须等待。特点是，粒度大、加锁简单、容易冲突
  - 记录锁，记录锁是行锁的一种，他锁的是一条记录
  - 页锁，操作系统和磁盘数据交互的大小是以页为单位的，每一页一半4K，页锁就是数据页加锁，一次锁相邻数据页记录
  - 间隙锁，间隙锁属于行锁的一种，锁的是表记录的一个区间遵循左开右闭原则，只出现在可重复读的事务级别中
  - 临键锁，next-key锁，也是行锁的一种，他是Innodb默认行锁算法，他是记录锁和间隙锁的组合，next-key锁把查询出来的记录锁住，同时也会把范围查询内的所有间隙空间也锁住，再之他会把香菱的下一个区间也锁住。

- 按锁的状态

  意向锁是事务在要给数据行加锁的时候会首先查是否有事务对这个表记录有加锁，如果有加锁就不用查找数据后枷锁，直接等待

  - 意向共享锁
  - 意向排他锁

### MySQL分库分表

当有1000万条记录，你需要分库分表，因为此时查询会很慢，把当前数据库拆分，水平拆分（按年月日拆分），垂直拆分（把相关性高的拆分），保证数据均匀分布 到不同数据库

- MySQL为什么要主从同步
  - 主从同步是实现读写分离的要求，防止请求落到一个数据库
  - 做为主机的备份，当主机访问量太大的时候启动备份服务器
  - 当业务量很大，需要对数据库分库分表，分为多个库需要主从同步

### MySQL执行计划

explain 

#### MySQL索引的设计原则

- 尽量使索引的字段占用的空间小，也就是key的大小越小越好
- 适合创建索引的列是在where字句中的列，或者连接字句中的列，或者orderby的列
- 基数少的列不适合建索引，基数少的列指的是一个列的数据很多重复的元素，比如列只有4中数字，1，2，3，4重复
- 不要给每个字段都创建索引，因为索引越多，占用磁盘空间越大，可能让你IO磁盘次数变多，反而降低效率
- 外键必须创建索引
- 更新频繁的列不能索引
- 创建索引的列不要太多，可以创建组合索引，但是组合索引的列的个数不要太多
- 大文本大对象不要建索引。

1. MySQL索引、聚集索引和非聚集索引、B树
2. 悲观锁、乐观锁、举例、CAS
3. InnoDB的页机制
4. ACID，事务如何实现，redolog很大怎么办
5. [redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)的数据结构，各个使用场景，过期淘汰策略，
   1. Redis介绍
   2. 了解redis源码么
   3. 了解redis集群么
6. 数据库的主从原理，具体是怎么监听binlog日志的
7. 讲一下数据的acid
   1. 讲一下数据的acid
   2. 什么是一致性
   3. 什么是隔离性
   4. Mysql的隔离级别
   5. 每个隔离级别是如何解决
8. Mysql要加上nextkey锁，语句该怎么写
9. 数据库的索引原理 
   1. 联合索引  
   2. 非聚簇索引和聚簇索引
   3. 索引的使用注意事项
10. Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化
11. Redis的应用
    1. Redis的持久化的方式和原理
12. MySQL索引结构
13. Redis数据类型
14. 口述查询前十条数据的sql？
15. 左右连接的区别？

　　left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。（结果条数等于左表）
　　right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。（结果条数等于右表）
　　inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。（左连接和右连接的交集）
　　full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。（左连接和右连接的并集）

16. [union和union all的区别](https://www.cnblogs.com/xiangshu/articles/2054447.html)

    Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

    Union All：对两个结果集进行并集操作，包括重复行，不进行排序；

    Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序；

    Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。

    ```sql
    select employee_id,job_id from employees
    union
    select employee_id,job_id from job_history
    ```

17. mysql存储引擎，innodb用的什么数据结构存储，说说B+树和B树的区别？

18. **MySQL有哪些数据类型？**

19. 聚簇索引、唯一索引、主键索引、复合索引，重点说说主**键索引和单一索引的区别**？（想到了通过主键回表）

20. **怎么对sql调优？**

    答：只答了针对慢查询添加索引。

21. **怎么知道一个查询是慢查询？**

    答：不会，就回答了查看响应速度。

    

22. 主键索引和辅助索引的区别（1分钟）

23. 分布锁（不会）

24. Redis（不太了解）

25. Linux命令，磁盘满了，怎么找到磁盘的大文件（不会）



26. 怎么实现间隙锁 底层

27. JVM内存区域

    1. 程序计数器 ， 虚拟机栈 ，本地方法栈 ， 堆 ，方法区 ，元空间 }  // 每个区域要能介绍一下

28. Minor GC 触发条件 ： eden区剩余内存是否足够 两种情况分开分析

    FULL GC 触发条件 ： Minor GC 平均晋升空间大小 > 老年代连续剩余空间，则触发FULL GC

29. 判断对象死亡的方法 ： { 引用计数法 ， 可达分析[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) }

    深入一些,：GC root对象有哪些？为什么选择他们做GC root对象

30. 垃圾收集[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) ： { 标记清除[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) 、标记整理[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) 、 复制[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) 、 分代收集[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法) }

    深入一些： 各个[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)的优点和适用场景

31. 垃圾收集器 ： { serial 、 parallel 、 CMS 、 G1  }

    CMS 、G1 重点 ， 介绍工作流程和优缺点

32. 内存泄漏

    例子： { 单例 ， 容器 等等}

    原因 ： 长生命周期持有短生命周期引用

33. 引用类型 ; { 强引用、 软引用、 弱引用 、 虚引用 }

34. 类加载过程 ： { 加载 ， 连接 ， 初始化 }

    有哪些类加载器 ， 能否自定义 Java.Object.String 的类加载器 ？

35. 双亲委派机制 介绍 & 作用

36. ArrayList 和 LinkedList 的区别

37. HashMap & ConcurrentHashMap 的比较 : 线程安全问题等等 

       深入一些 ： HashMap 为什么线程不安全？ 能否举例 = { 并发resize()触发闭环结构 ，覆盖put操作 }

38.  HashMap 的 相关问题   // HashMap系列需要通过关键源码理解，比较重要
      为什么 HashMap的size 为 2的幂次方 ？  

       HashMap resize()过程能否介绍 ？  

       HashMap效率受什么影响 (负载因子、hash数组size)？  

       HashMap中扰动函数的作用 ？

39. Hashtable 和 HashMap的区别 ： { 底层数据结构 (JDK1.8后不同)、父类不同 、扩容方法不同 、 线程上锁范围不同（重点） }

40. equals 和 == 区别

    为啥重写equals要重写hashCode()

    hash值相等，而两个对象不一定equals

41. String StringBuffer StringBuilder 区别 和各自使用场景 

    ​     深入一些 ： String 是如何实现它不可变的？ 为什么要设置String为不可变对象 ?   (字节一面这个问题给我问懵了)

42. 接口和抽象类区别

43. 重写和重载的区别

44. 深拷贝和浅拷贝区别

45. Java三大特性

46. Object的方法 ： { finalize 、 clone、 getClass 、 equals 、 hashCode }

47.  设计模式   ： {  单例模式 、 工厂模式 、 装饰者模式 、 代理模式 、 策略模式 等等} （此处我的掌握也不是很好）

48. 单例模式为什么采用双检测机制 ？ 单例为什么用Volatile修饰？ 装饰模式和代理模式区别？

49. 

50. MyISAM 和 InnoDB的区别  ： {是否支持行锁 、 是否支持事务 、 是否支持 MVCC 、 底层索引结构不同 }

51. 深入一些 ： 为什么要有一致性 ？ AID不是已经保证了一致性了吗 ？

52.  并发事务带来的问题 ： {  脏读 、 修改丢失 、 不可重复读 、 幻影读  }

53. 事务的隔离级别

54.  MVCC机制

55. 索引

    为什么索引使用B+树结构，而不是B树

    为什么索引使用B+树结构，而不是[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树) ： { 磁盘预读取 、[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)高度 }

56. 聚簇索引和非聚簇索引区别？ 主键索引和二级索引了解吗？

57. 为什么不对每个列创建索引呢？

58. SQL语句优化 ，SQL题目（字节要求撸代码）

59. explain中 rows type key extra字段的含义？

60. count(1) count(*) count(列值)的区别

# 计算机网络相关

[精品 讲解计算机网络](https://zhuanlan.zhihu.com/p/404693092)

## 计算机网络实验

### 实验1-HTTP底层通信/使用网络系统调用实现网络进程通信

**实际上是HTTP协议使用TCP三次握手建立连接，四次挥手断开连接，使用read/write系统调用进行传输数据的过程的实现，这是HTTP协议底层传输数据的程**

Linux网络系统调用Socket已经实现了TCP/IP，UDP/IP协议栈，用户程序需要遵循TCP/IP协议的三次握手四次挥手规则调用系统调用建立连接和断开连接以及数据传输。HTTP使用TCP/IP协议传递数据的底层实现（使用系统调用规则）。

**网络字节序和主机字节序**

主机字节序指的是整数在内存中的保存方式，小端字节序让整数的低地址保存在内存低地址，整数高地址保存在内存高地址；大端字节序让整数低地址保存在内存高地址，整数高地址保存在内存低地址，对32整数01020304,小端保存会是(内存低地址：04 03 02 01：内存高地址)，大端会是（01 02 03 04)。网络字节序是大端字节序，对01020304 的32位整数，发送字节顺序是04 03 02 01。所以为了保证消除字节序的影响，需要将socket绑定地址的时候转换成大端字节序

**查看网络请求过程**

```
//服务端监听端口
sudo tcpdump -iany tcp port 9502

//客户端访问端口会在服务端显示请求连接过程
telnet 127.0.0.1 9502
```

**TCP三次握手和建立连接过程/TCP传送数据过程/TCP四次挥手和断开连接过程**

- TCP建立连接过程

  ![img](https://pic2.zhimg.com/80/v2-19c1a6b084bcf9aeda1aa39de684b8e5_720w.webp)

  > 我们可以通过网络抓包的查看具体的流程：
  >
  > 比如我们服务器开启9502的端口。使用tcpdump来抓包：
  >
  > **tcpdump -iany tcp port 9502**
  >
  > 然后我们使用telnet 127.0.0.1 9502开连接.:
  >
  > telnet 127.0.0.1 9502
  >
  > 14:12:45.104687 IP localhost.39870 > localhost.9502: Flags [S], seq 2927179378, win 32792, options [mss 16396,sackOK,TS val 255474104 ecr 0,nop,wscale 3], length 0**（1）**
  > 14:12:45.104701 IP localhost.9502 > localhost.39870: Flags [S.], seq 1721825043, ack 2927179379, win 32768, options [mss 16396,sackOK,TS val 255474104 ecr 255474104,nop,wscale 3], length 0 **（2）**
  > 14:12:45.104711 IP localhost.39870 > localhost.9502: Flags [.], ack 1, win 4099, options [nop,nop,TS val 255474104 ecr 255474104], length 0 **（3）**
  >
  >
  > 14:13:01.415407 IP localhost.39870 > localhost.9502: Flags [P.], seq 1:8, ack 1, win 4099, options [nop,nop,TS val 255478182 ecr 255474104], length 7
  > 14:13:01.415432 IP localhost.9502 > localhost.39870: Flags [.], ack 8, win 4096, options [nop,nop,TS val 255478182 ecr 255478182], length 0
  > 14:13:01.415747 IP localhost.9502 > localhost.39870: Flags [P.], seq 1:19, ack 8, win 4096, options [nop,nop,TS val 255478182 ecr 255478182], length 18
  > 14:13:01.415757 IP localhost.39870 > localhost.9502: Flags [.], ack 19, win 4097, options [nop,nop,TS val 255478182 ecr 255478182], length 0
  >
  > - 114:12:45.104687 时间带有精确到微妙
  > - localhost.39870 > localhost.9502 表示通信的流向，39870是客户端，9502是服务器端
  > - [S] 表示这是一个SYN请求
  > - [S.] 表示这是一个SYN+ACK确认包:
  > - [.] 表示这是一个ACT确认包， (client)SYN->(server)SYN->(client)ACT 就是3次握手过程
  > - [P] 表示这个是一个数据推送，可以是从服务器端向客户端推送，也可以从客户端向服务器端推
  > - [F] 表示这是一个FIN包，是关闭连接操作，client/server都有可能发起
  > - [R] 表示这是一个RST包，与F包作用相同，但RST表示连接关闭时，仍然有数据未被处理。可以理解为是强制切断连接
  > - win 4099 是指滑动窗口大小
  > - length 18指数据包的大小
  >
  > 我们看到 **（1）（2）（3）三步是建立tcp：**
  >
  > **第一次握手：**
  >
  > 14:12:45.104687 IP localhost.39870 > localhost.9502: Flags [S], seq 2927179378
  >
  > 客户端IP localhost.39870 (客户端的端口一般是自动分配的) 向服务器localhost.9502 发送syn包(syn=j)到服务器》
  >
  > syn包(syn=j) ： syn的seq= 2927179378 （j=2927179378）
  >
  > **第二次握手：**
  >
  > 14:12:45.104701 IP localhost.9502 > localhost.39870: Flags [S.], seq 1721825043, ack 2927179379,
  >
  > 收到请求并确认：服务器收到syn包，并必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包：
  > 此时服务器主机自己的SYN：seq：y= syn seq 1721825043。
  > ACK为j+1 =（ack=j+1）=ack 2927179379
  >
  > **第三次握手：**
  >
  > 14:12:45.104711 IP localhost.39870 > localhost.9502: Flags [.], ack 1,
  >
  > 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)
  >
  > 客户端和服务器进入ESTABLISHED状态后，可以进行通信数据交互。此时和accept接口没有关系，即使没有accepte，也进行3次握手完成。
  >
  > 连接出现连接不上的问题，一般是网路出现问题或者网卡超负荷或者是连接数已经满啦。

  TCP建立连接过程：服务端使用socket系统调用创建一个监听套接字，接着创建一个网络地址变量，使用bind系统调用将这个网络地址绑定到监听套接字（（协议版本ipv4/ipv6, ip地址，端口号）三元组唯一确定网络中的一个进程），然后调用accept阻塞进程等待创建一个连接套接字，当客户端使用connect系统调用创建一个连接套接字之后，会阻塞客户端进程，同时向服务端发送SYN X的同步帧（第一次握手），服务端接收到客户端的连接请求之后，会唤醒服务器进程（信号还是端口中断？)，服务器进程唤醒之后向客户端发送一个确认帧ACK X+1和一个同步帧SYN Y（第二次握手），接着陷入阻塞等待客户端确认这个同步帧，当客户端接收到服务端发送的确认帧之后，他知道服务端已经准备好通信了，他要向服务端反映自己已经准备号通信，所以他会发送确认帧Y+1给服务器说明自己已经准备好通信（第三次握手），并且从阻塞状态返回，返回一个连接套接字，服务端接收到这个确认帧 之后知道客户端已经准备好通信了就从accept返回一个监听套接字，就此三次握手建立完成。**问题：为什么十三次握手而不是两次握手？因为TCP通信时全双工通信，在客户端接收到服务端的确认帧的时候，客户端知道服务端已经准备好通信，但是服务端并不知道客户端是否准备好通信，所以需要客户端确认服务端发送的同布帧**

- TCP发送数据过程：客户端使用write/send系统调用发送数据之后阻塞等待服务端发送确认帧，服务端调用read/recv阻塞，等待客户端发送的数据，当客户端发送的数据当来之后会检查客户端数据是否完整，如果不完整会部分确认，客户端发现服务端发送的确认不是全部确认，会重发数据（这个过程时华东窗口发送数据的过程）。服务端在接受完数据之后可能会向客户端发送数据，这个过程和上述滑动窗口发送数据的过程是一样的。

  > 紫色背景的部分：
  >
  > IP localhost.39870 > localhost.9502: Flags [P.], seq 1:8, ack 1, win 4099, options [nop,nop,TS val 255478182 ecr 255474104], length 7
  >
  > 客户端向服务器发送长度为7个字节的数据，
  >
  > IP localhost.9502 > localhost.39870: Flags [.], ack 8, win 4096, options [nop,nop,TS val 255478182 ecr 255478182], length 0
  >
  > 服务器向客户确认已经收到数据
  >
  > IP localhost.9502 > localhost.39870: Flags [P.], seq 1:19, ack 8, win 4096, options [nop,nop,TS val 255478182 ecr 255478182], length 18
  >
  > 然后服务器同时向客户端写入数据。
  >
  > IP localhost.39870 > localhost.9502: Flags [.], ack 19, win 4097, options [nop,nop,TS val 255478182 ecr 255478182], length 0
  >
  > 客户端向服务器确认已经收到数据
  >
  > 这个就是tcp可靠的连接，每次通信都需要对方来确认。

* TCP关闭过程：用户程序在传递完数据之后调用close关闭socket描述符，进入阻塞并向服务端发送一个FIN M结束帧，客户端此时处于recv数据接收阶段，他把FIN M结束帧解释为文件结束符返回给应用程序并且知道无法再从这个socket描述符接收到更多数据（此时数据发送的字符串已经全被被recv的内核缓冲区 接收了，只是可能还有全部拷贝到用户程序），服务端发送一个ACK M+1的确认帧，客户端接收到这个确认帧之后进入新的阻塞状态等待客户端发送FIN 完成帧（这个等待状态是无限等待状态，在客户端接收到这个确认帧之后客户端会关闭socket描述符，但是这只是客户端的，因为TCP时全双工的，还需要关闭服务端的socket描述符），当服务端的recv把所有缓冲数据都拷贝到应用程序用户空间之后，将会调用close系统调用来关闭连接，服务端close系统调用发送一个FIN N的完成帧给客户端，客户端接受到这个这个FIN帧之后知道服务端已经关闭了连接描述符，需要通知客户端自己知道这个事情了，所以发送一个确认ACK N+1，自己进入TIME_WAIT(2MSL)状态，当服务端接收到这个FIN帧之后知道客户端已经知道自己关闭了连接套接字，关闭过程就结束了，否则服务端等待一段时间没有接收到（信号实现）这个ACK，他会重发FIN，而TIME_WATI状态就是用来处理这个重发过程的。**问题：1. 为什么又TIME_WAIT状态？答：网路原因造成服务端无法接收到ACK，那么TIME_WAIT状态用来处理服务端重发的FIN。2. 为什么四次握手，三次握手是否可以？不可以，建立连接三次握手可以是因为没有数据拷贝到用户空间，而四次握手是因为又数据拷贝到用户空间，那么发送完成帧FIN就不能和发送ACK一起发，这里就增加了一次握手。**

  > 建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭(half-close)造成的，如图：
  >
  > ![img](https://pic1.zhimg.com/80/v2-0554854079c144d46da269740c666a50_720w.webp)
  >
  > 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
  >
  > （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。
  >
  > （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。
  >
  > （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。
  >
  > （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。
  >
  > 对应函数接口如图：
  >
  > ![img](https://pic3.zhimg.com/80/v2-a59eac5deddd8b191397e6ea31ba0d72_720w.webp)
  >
  > 过程如下：
  >
  > - 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；
  > - 另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；
  > - 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；
  > - 接收到这个FIN的源发送端TCP对它进行确认。
  >
  > 这样每个方向上都有一个FIN和ACK。
  >
  > 1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
  >
  > 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。
  >
  > 2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？
  >
  > 这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。



**一些参考资料**

[W. Richard Stevens](http://www.kohala.com/start/)

https://zhuanlan.zhihu.com/p/180556309

http://c.biancheng.net/cpp/html/3045.html

https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html

https://cloud.tencent.com/developer/article/1722240

Socket是Linux提供的系统调用，Socket调用了TCP/IP协议栈，TCP/IP、Socket都是Linux操作系统提供的用于网络通信服务的程序。

不同的语言的库函数对Socket系统调用进行了封装，Socket的实现在Linux内核中，包括TCP/IP的实现。高级语言的库函数封装了Socket系统调用，从而可以通过使用高级语言的Socket库函数调用Socket系统调用。

同一主机上的进程通信方式有管道（有名管道和无名管道）、信号、共享内存、消息队列、信号量等；不同主机通信使用Socket套接字。Socket编程使用传输层传递的协议（TCP、UDP）+端口，网络层的IP地址这三元组唯一标记网络中的一个进程。

创建一个Socket连接会返回一个Socket描述符，这是在进程文件描述符表的一个索引，这个索引指向系统进程文件数据结构的地址。文件描述符是Linux系统中每个进程的文件描述符表的索引；文件指针式C语言的一个指向FILE数据结构的指针，FILE数据结构包括一个缓冲区和一个文件描述符。

**网络字节序和主机字节序**

字节序指的是整数保存在内存中的字节的顺序，包括小端字节序和大端字节序。小端字节序是整数的低位存放在低地址，高位存放到高地址；大端字节序是整数的高位存放在低地址，低位存放在高地址。比如一个4字节32位的int数值01020304，在文件中保存为01020304，左边是低地址，右边是高地址；在socket中保存为04030201，最低地址是04，一个字节可以保存两个十六进制数，04是一个字节的十六进制表示。

#### Socket C语言

![](https://pic1.zhimg.com/80/v2-d37fb0d929b6a8e7b68d82c2ac4f9abc_720w.jpg)

**C语言库函数中的Socket编程相关的库函数**

> **int  socket(int protofamily, int type, int protocol);//返回sockfd **
> 用于创建一个Socket描述符，他唯一标记一个Socket。protofamily表示协议族，包括AF_INET(IPV4)、AF_INET6(IPV6)等，他决定了Socket的网络地址类型；type，Socket类型，包括SOCK_TREAM、SOCK_DGRAM等；protocol，传输层协议，包括IPPROTO_TCP（TCP协议）、IIPROTO_UDP（UDP协议）等。当创建一个Socket描述符的时候，创建Socket描述符的时候返回的Socket描述符没有绑定IP和端口，可以使用bind函数绑定IP+端口，如果不使用bind绑定，在使用connect和listen等函数的时候会被自动分配IP+端口；这个机制使得服务端需要使用bind来绑定端口而客户端不用，因为客户端在使用connect和listen的时候会使用自动分配的端口。

> **int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);**
>
> 给文件描述符绑定IP地址和端口，其中sockaddr数据结构对不同的协议族定义不一样，在IPV4中，sockaddr定义如下
>
> ```text
> struct sockaddr_in {
>  sa_family_t    sin_family; /* address family: AF_INET */
>  in_port_t      sin_port;   /* port in network byte order */
>  struct in_addr sin_addr;   /* internet address */
> };
> 
> /* Internet address. */
> struct in_addr {
>  uint32_t       s_addr;     /* address in network byte order */
> };
> ```

> ```> 
> int listen(int sockfd, int backlog);
> int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
> sockfd是要监听或者使用的socket描述符，backlog是服务端允许排队的最大连接个数，addrlen是地址长度,调用listen后套接字编程监听套机字
> ```

> ```text
> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); //返回连接connect_fd
> ```
>
> accept接收listen传递的监听套接字，转换成连接套接字

> read/write函数，进行网络IO函数
>
> ```text
> #include <unistd.h>
> #include <sys/types.h>
> #include <sys/socket.h>
> 
> ssize_t read(int fd, void *buf, size_t count);
> ssize_t write(int fd, const void *buf, size_t count);
> 
> ssize_t send(int sockfd, const void *buf, size_t len, int flags);
> ssize_t recv(int sockfd, void *buf, size_t len, int flags);
> 
> ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
> const struct sockaddr *dest_addr, socklen_t addrlen);
> 
> ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
> struct sockaddr *src_addr, socklen_t *addrlen);
> 
> ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
> ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
> ```

> ```text
> int close(int fd);
> ```
>
> 关闭套接字，这个套接字的引用计数变成0，这个套接字不能继续作为read/write函数的第一个参数

**C语言 Socket 编程实现不同主机进程通信**

https://zhuanlan.zhihu.com/p/180556309

```c
/* File Name: client.c */
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
 
#define MAXLINE 4096
 
int main(int argc, char** argv){
 	int    sockfd, n,rec_len;
 	char    recvline[4096], sendline[4096] = "abcd";
 	char    buf[MAXLINE];
 	struct sockaddr_in servaddr;
 
 
 	if( argc != 2){
 		printf("usage: ./client <ipaddress>\n");
 		exit(0);
    	}
 
 
 	if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
 		printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);
 		exit(0);
    	}
 
 	memset(&servaddr, 0, sizeof(servaddr));
    	servaddr.sin_family = AF_INET;
    	servaddr.sin_port = htons(8000);
 	if( inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0){
 		printf("inet_pton error for %s\n",argv[1]);
 		exit(0);
    	}
 
 
 	if( connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){
 		printf("connect error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 
 	printf("send msg to server: \n");
    gets(sendline, 4096, stdin);
 	if( send(sockfd, sendline, strlen(sendline), 0) < 0){
 		printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);
 		exit(0);
    	}
 	if((rec_len = recv(sockfd, buf, MAXLINE,0)) == -1) {
       		perror("recv error");
 		exit(1);
    	}
    	buf[rec_len]  = '\0';
 	printf("Received : %s ",buf);
    	close(sockfd);
 	exit(0);
}

```

```c
/* File Name: server.c */
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#define DEFAULT_PORT 8000
#define MAXLINE 4096


int main(int argc, char** argv){
	int    socket_fd, connect_fd;
 	struct sockaddr_in servaddr;
 	char    buff[4096];
 	int     n;
 	//初始化Socket
 	if( (socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){
 		printf("create socket error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 	//初始化
 	memset(&servaddr, 0, sizeof(servaddr));
    	servaddr.sin_family = AF_INET;
    	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。
    	servaddr.sin_port = htons(DEFAULT_PORT);//设置的端口为DEFAULT_PORT
 
	//将本地地址绑定到所创建的套接字上
 	if( bind(socket_fd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1){
 		printf("bind socket error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 	//开始监听是否有客户端连接
 	if( listen(socket_fd, 10) == -1){
 		printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 	printf("======waiting for client's request======\n");
 	while(1){
	//阻塞直到有客户端连接，不然多浪费CPU资源。
 		if( (connect_fd = accept(socket_fd, (struct sockaddr*)NULL, NULL)) == -1){
	 		printf("accept socket error: %s(errno: %d)",strerror(errno),errno);
	 		continue;
    		}
		//接受客户端传过来的数据
	    	n = recv(connect_fd, buff, MAXLINE, 0);
		//向客户端发送回应数据
	 	if(!fork()){ /*紫禁城*/
	 		if(send(connect_fd, "Hello,you are connected!\n", 26,0) == -1)
				perror("send error");
			close(connect_fd);
	 		exit(0);
	    	}
	    	buff[n] = '\0';
	 	printf("recv msg from client: %s\n", buff);
	    	close(connect_fd);
    	}
    	close(socket_fd);
}
```

#### Socket Python

https://www.runoob.com/python/python-socket.html

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名：client.py
 
import socket               # 导入 socket 模块
 
s = socket.socket()         # 创建 socket 对象
host = socket.gethostname() # 获取本地主机名
port = 12345                # 设置端口号
 
s.connect((host, port))
print(s.recv(1024) )
s.close()
```

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名：server.py
 
import socket               # 导入 socket 模块
 
s = socket.socket()         # 创建 socket 对象
host = socket.gethostname() # 获取本地主机名
port = 12345                # 设置端口
s.bind((host, port))        # 绑定端口
 
s.listen(5)                 # 等待客户端连接
while True:
    c,addr = s.accept()     # 建立客户端连接
    print('连接地址：', addr)
    mystring = "Hello"
    c.send(mystring.encode())
    c.close()                # 关闭连接
```

#### Socket Java

https://www.liaoxuefeng.com/wiki/1252599548343744/1319099802058785

```c
//Client.java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class Client {
	public static void main(String[] args) throws IOException {
		Socket sock = new Socket("localhost", 6666); // 连接指定服务器和端口
		try (InputStream input = sock.getInputStream()) {
			try (OutputStream output = sock.getOutputStream()) {
				handle(input, output);
			}
		}
		sock.close();
		System.out.println("disconnected.");
	}

	private static void handle(InputStream input, OutputStream output) throws IOException {
		var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
		var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
		Scanner scanner = new Scanner(System.in);
		System.out.println("[server] " + reader.readLine());
		for (;;) {
			System.out.print(">>> "); // 打印提示
			String s = scanner.nextLine();
			writer.write(s);
			writer.newLine();
			writer.flush();
			String resp = reader.readLine();
			System.out.println("<<< " + resp);
			if (resp.equals("bye")) {
				break;
			}
		}
	}
}

```

```java
//Server.java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.charset.StandardCharsets;

/**
 * Learn Java from https://www.liaoxuefeng.com/
 * 
 * @author liaoxuefeng
 */
public class Server {
	public static void main(String[] args) throws IOException {
		ServerSocket ss = new ServerSocket(6666); // 监听指定端口
		System.out.println("server is running...");
		for (;;) {
			Socket sock = ss.accept();
			System.out.println("connected from " + sock.getRemoteSocketAddress());
			Thread t = new Handler(sock);
			t.start();
		}
	}
}

class Handler extends Thread {
	Socket sock;

	public Handler(Socket sock) {
		this.sock = sock;
	}

	@Override
	public void run() {
		try (InputStream input = this.sock.getInputStream()) {
			try (OutputStream output = this.sock.getOutputStream()) {
				handle(input, output);
			}
		} catch (Exception e) {
			try {
				this.sock.close();
			} catch (IOException ioe) {
			}
			System.out.println("client disconnected.");
		}
	}

	private void handle(InputStream input, OutputStream output) throws IOException {
		var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
		var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
		writer.write("hello\n");
		writer.flush();
		for (;;) {
			String s = reader.readLine();
			if (s.equals("bye")) {
				writer.write("bye\n");
				writer.flush();
				break;
			}
			writer.write("ok: " + s + "\n");
			writer.flush();
		}
	}
}

```

#### Socket Go

http://c.biancheng.net/view/4513.html

```go
//Client.go
package main
import (
    "log"
    "net"
    "os"
)
func main() {
    if len(os.Args) != 2 {
        log.Fatalf("Usage: %s host:port", os.Args[0])
    }
    service := os.Args[1]
    tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
    if err != nil {
        log.Fatal(err)
    }
    conn, err := net.DialTCP("tcp4", nil, tcpAddr)
    if err != nil {
        log.Fatal(err)
    }
    n, err := conn.Write([]byte("HEAD / HTTP/1.1\r\n\r\n"))
    if err != nil {
        log.Fatal(err)
    }
    log.Fatal(n)
}
```

```go
//Server.go

package main
import (
    "fmt"
    "log"
    "net"
    "time"
)
func echo(conn *net.TCPConn) {
    tick := time.Tick(5 * time.Second) // 五秒的心跳间隔
    for now := range tick {
        n, err := conn.Write([]byte(now.String()))
        if err != nil {
            log.Println(err)
            conn.Close()
            return
        }
        fmt.Printf("send %d bytes to %s\n", n, conn.RemoteAddr())
    }
}
func main() {
    address := net.TCPAddr{
        IP:   net.ParseIP("127.0.0.1"), // 把字符串IP地址转换为net.IP类型
        Port: 8000,
    }
    listener, err := net.ListenTCP("tcp4", &address) // 创建TCP4服务器端监听器
    if err != nil {
        log.Fatal(err) // Println + os.Exit(1)
    }
    for {
        conn, err := listener.AcceptTCP()
        if err != nil {
            log.Fatal(err) // 错误直接退出
        }
        fmt.Println("remote address:", conn.RemoteAddr())
        go echo(conn)
    }
}
```

## 输入URL到显示网页的过程

1. DNS域名解析获取IP地址
2. 浏览器通过IP地址建立和对应主机的连接
3. 浏览器发送请求，后台处理请求并返回响应
4. 浏览器获取响应并渲染

1. DNS域名解析过程

## 传输层协议 TCP/UDP

[计算机网络全](http://docs.52im.net/extend/docs/book/tcpip/vol1/18/)

[TCP IP头部](http://www.51testing.com/html/66/138366-216709.html) 

[TCP IP头部](https://www.cnblogs.com/limanjihe/p/10134385.html#:~:text=IP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%98%AF%E4%B8%80,%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E4%B8%BA65535B%E3%80%82)

[IP偏移量](https://blog.csdn.net/cumirror/article/details/4869770)

[Time_wait状态](https://www.cioage.com/article/623158.html)

[Time_wait状态](https://draveness.me/whys-the-design-tcp-time-wait/)

[TCP流量控制](https://blog.csdn.net/guoweimelon/article/details/50879588#:~:text=ARQ%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%8D%B3%E8%87%AA%E5%8A%A8%E9%87%8D,%E5%AE%83%E9%80%9A%E5%B8%B8%E4%BC%9A%E9%87%8D%E6%96%B0%E5%8F%91%E9%80%81%E3%80%82)

[TCP拥塞控制](https://segmentfault.com/a/1190000040600606#:~:text=%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%E6%98%AF%E5%86%B3%E5%AE%9A%E4%BB%BB%E4%BD%95,%E5%A4%9A%E5%B0%91%E6%8B%A5%E5%A1%9E%E6%9D%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E3%80%82)

[TCP拥塞控制](https://zhuanlan.zhihu.com/p/37379780)

[HTTP/HTTPS TCP/IP协议栈](https://zhangbinalan.gitbooks.io/protocol/content/httpqi_ta.html)

[MSS MTU](https://draveness.me/whys-the-design-tcp-segment-ip-packet/)

[TCP粘包](https://draveness.me/whys-the-design-tcp-message-frame/)

[TCP粘包](https://segmentfault.com/a/1190000039691657)

1. 三次握手，四次挥手，为什么三次握手，为什么要四次挥手，四次挥手中什么是 time_wait 状态 ？ close-wait 状态?time_wait状态什么场景下过多 ， 会造成什么问题？

   1. 三次握手
      1. 客户端设置SYN=1，初始化一个序号X，发送给服务端，进入SYN_SENT状态
      2. 服务端接收到请求，从LISTEN状态进入SYN_RECEIVED状态，设置ACK=1，确认好ack=X+1，SYN=1，初始化一个序号Y，发送给i客户端
      3. 客户端接收到响应，进入ESTABLISTED状态，设置ACK=1，确认号ack=Y+1，发送给服务端
      4. 服务端接收到响应，进入ESTABLISH状态

   2. 为什么三次握手，能否使用四次握手

      使用两次握手的一个问题是，客户端发送请求和得到响应则客户端知道服务端接收和发送请求都行，但是服务端不知道客户端接收请求是否可行，因此不能使用两次握手；另外一个问题是延迟到来的连接请求可能会创建一个连接而实际上客户端已经完成了连接请求，这造成服务端连接的浪费。

      使用四次握手是在服务端发送ACK响应和SYN同步请求时分开来发，这种情况是可以的，但是合并他们可以增加效率。

      综上，使用三次握手

   3. 四次挥手

      1. 客户端设置FIN=1，初始化序号为X，发送给服务端，进入FIN_WAIT_1状态
      2. 服务端接收到请求，进入CLOSE_WAIT状态，设置ACK=1，确认号ack=X+1，发送给客户端
      3. 客户端接收到响应，进入FIN_WAIT_2状态
      4. 服务端发送完数据以后，设置FIN=1，初始化一个序号X，发送给客户端，进入LAST_ACK状态
      5. 客户端收到请求，设置ACK=1，确认好为X+1，发送给服务端，进入TIME_WAIT状态，等待2MSL之后进入CLOSED状态
      6. 服务端接收到ACK响应之后进入CLOSED状态

   4. 为什么四次挥手，为什么CLOSE_WAIT状态

      在客户端发送FIN请求之后，只能说明客户端数据发送完了，服务端不一定发送完数据，这个时候CLOSE_WAIT状态，服务端只发送对客户端请求关闭的响应，等待自己发送完数据之后再发送关闭连接FIN请求

   5. TIME_WAIT状态

      也称为2MSL状态，MSL是Maximum Segment Lifetime的缩写，代表最大段生存周期，标明IP数据包再网络中存活的最大时间，再IP数据包里可以通过TTL（Time To Live）进行设置。TIME_WAIT状态是请求关闭方才能所处的状态。TIME_WAIT状态主要有两个方面的原因：

      1. 防止过期的数据到来。在TIME_WAIT状态对于过期到来的数据会直接丢弃并返回RST
      2. 确保可靠关闭TCP连接。当服务端没有收到ACK，就会重发FIN，客户端重发ACK，从而保证可靠关闭

      为什么2被MSL（这是ACK发送到被响应得到的在网络中的最大生存时间）

   6. TIME_WAIT过多

      在高并发情况下会出现很多TIME_WAIT的端口，这样会造成很多端口处于TIME_WAIT状态，造成建立新连接失败。解决方法

      1. 对于客户端，设置HTTP的connection为keep-alive，让服务端可以复用连接
      2. 对于服务端，一个是设置小的TIME_WAIT时间，另外一个是允许处于TIME_WAIT状态的Socket被重用

2. TCP怎么保证连接的可靠性（ARQ 、 流量控制 、 拥塞控制 、 校验和），说说拥塞控制（快重传、快恢复）

   1. 校验和
   2. 确认机制，停止等待协议每个发送的数据都能收到对应的确认
   3. 超时重传机制，当一个数据丢失可以被重传
   4. 流量控制，滑动窗口协议控制发送方发送速率，防止接收方缓冲区溢出
   5. 对失序的数据进行排序
   6. 丢弃重复的数据

3. TCP和UDP的区别，他们的使用场景

   TCP是有连接的、可靠的、面向字节流的传输层协议，UDP是无连接的、不可靠的、面向数据报的传输层协议

   TCP有流量控制和拥塞控制，UDP没有

   TCP因为是面向字节流的，有产生粘包的风险，而UDP是面向数据报的，他的UDP头部有这个数据报的大小，无粘包

   TCP只能一对一连接，而UDP可以广播和多播

   TCP因为可靠性来源多种方式，而UDP只有基本的校验和

   UDP比TCP速度块

   应用场景：

   TCP用于需要可靠传输的协议，比如HTTP，HTTPS，FTP

   UDP可用于对传输速度有要求但是对数据质量无要求的场景，比如视频流、IP电话
   
4. TCP流量控制

   [停止等待协议](https://zhuanlan.zhihu.com/p/405550972)

   [回退N协议](https://zhuanlan.zhihu.com/p/405573476)

   [选择重传协议](https://zhuanlan.zhihu.com/p/405575394)

   流量控制是控制发送方流量以防止接收方缓冲区溢出，是TCP保证可靠通信的一个机制

   使用的滑动窗口协议：

   发送方和接收方都有自己的窗口，在建立通信的时候，接收方会返回自己的窗口大小字段，发送方获得这个窗口和拥塞窗口比较，从而选择出自己的发送窗口

   发送的数据都被编号，每次发送方发送多个分组，收到ACK后努力把窗口向前移动到第一个没有被确认的分组，删除已经确认的分组，发送新到来的分组，每个分组会设置一个超时计时器，如果超时没有收到确认，就会重传这个分组

   接收方将接受分组，然后发送确认。

   1. 停止等待协议

      发送方窗口为1，接收方窗口为1

      分组标号为0101，使用一位比特标号

      发送方发送一个分组之后只有等到接收到这个分组的确认之后才会发送新一个分组，超时就会重传

      接收方接收到一个分组之后发送一个ACK确认分组，如果分组有差错，那么发送一个NAK加快重传或者直接抛弃等待发送方重传

   2. 回退N协议

      使用n个比特对分组进行标号，如果为2，则分组标号为01230123

      发送窗口大小
      $$
      1<W_T \leq 2^n-1
      $$
      接收窗口大小为1

      发送窗口为1则则变成停止等待协议，发送窗口超过限制就会让接收窗口无法分辨新旧分组

      发送窗口一次发送所有分组，接收窗口按序确认，逐一确认或者累计确认

      发送窗口接收到一个确认之后会努力把窗口向前移动到没有确认的分组，并且删除已经确认的分组，发送新进入窗口的分组

      接收窗口接收到一个分组，判断是否按序到达的分组，如果是就移动，如果不是就丢弃，并且发送重复确认之前到达的分组，可以让接收方快重传，当一个分组超时之后，他会重传他后面的所有的分组。

   3. 选择重传协议

      使用n个比特对分组进行标号，如果为2，则分组标号为01230123

      发送窗口大小
      $$
      1<W_T \leq 2^{(n-1)}
      $$
      接收窗口大小
      $$
      1<W_R \leq W_T
      $$
      如果发送窗口大小超过上限，那么会导致接收窗口无法分辨新旧分组

      发送窗口发送所有分组，每个分组都有一个超时计时器，接收窗口逐一确认，不能累计确认

      发送窗口接收到一个ACK之后努力移动到没有确认的分组，删除确认的分组，发送新的分组

      接收方接收到一个数据后努力移动到没有到达的分组，提交已经到达的分组

      发送方超时重传未确认的分组

      选择重传协议比前面两个要信道利用率更高，但是有缓存开销

5. TCP拥塞控制

   拥塞控制是控制网络负载，防止发送方像网络注入过多分组

## 应用层协议 HTTP/HTTPS

### HTTP和HTTPS

1. HTTP和HTTPS区别

   1. HTTP使用端口80，HTTPS使用端口443
   2. HTTP是明文传输，HTTPS运行在SSL之上，添加了加密和认证机制，更加安全
   3. HTTPS因为加密解密会带来巨大的CPU和内存开销
   4. HTTPS通信需要整数，一般想认证机构（CA）购买

2. HTTP1，HTTP1.1，HTTP2，HTTP3 区别

   [HTTP各版本特征](https://network.51cto.com/article/628901.html)

   HTTP1.0

   - 无状态（服务器不跟踪客户单也不记录过去的连接状态）、无连接（浏览器每个请求都要重新建立TCP连接，请求完就关闭）协议
   - 短连接：每次请求都要重新建立TCP连接
   - 请求报文的请求头没有host字段
   - 不允许断点续传，不能传输对象的一部分，只能传输整个对象

   HTTP1.1

   - 长连接：在请求报文的请求头的connection域设置keep-alive可以使用长连接
   - 请求管道化
   - 增加缓存处理：请求头增加Cache-control字段
   - 请求头增加Host字段（使得一个服务器可以创建多个web站点），支持断点传输
   - 由于长连接会给服务器造成压力

   HTTP2.0

   - 使用二进制分帧
   - 压缩头部，双方各自维护一个header的索引表，通过发送key来缩减头部大小
   - 使用多路复用，使用多个stream，每个stream又分帧传输，使得一个TCP连接处理多个http请求
   - 服务器推送

   HTTP3.0

   - 传输层使用基于UDP协议的QUIC协议
   - 减少了TCP三次握手时间，TLS（SSL）握手时间
   - 解决了HTTP2.0前一个Stream丢失而阻塞后一个Stream的问题
   - 优化了重传策略，重传包编号和原包不同，降低后续重传计算的开销
   - 连接迁移，不适用TCP四元组来确定一个连接，而是用一个64位随机数确定一个连接
   - 优化流量控制

3. HTTPS加密过程

   1. 客户端发送请求，并发送自己支持的加密规则，包括对阵加密、非对称加密和摘要算法

   2. 服务端从请求中选择加密算法和Hash算法，并将自己的身份信息以证书的形式发送给客户端，证书包括网站网址、加密公匙、颁发机构等信息

   3. 客户端验证证书是否合法性，包括证书是否过期、颁发机构（CA）是否可靠、公匙能否正确认证”发行者的数字签名“、证书中的域名是否和服务器实际域名相符

      如果证书不合法，就返回警告给服务器处理

      如果证书合法，客户端初始化一个随机密匙，使用公匙进行加密；使用Hash算法对握手消息计算摘要，并使用未加密的随机密匙进行加密；之后把加密后的随机密匙和摘要发送给服务端

   4. 服务端使用私钥解密加密的随机密匙，得到对称加密的密匙，用对称加密的密匙解密摘要，并验证是否和握手消息一致，如果一致，那么使用对称加密的密匙加密握手消息发送给客户端

   5. 客户端使用对称加密密匙解密并验证摘要，如果一致，则握手结束。之后传输的数据都是用对称加密的密匙进行加密。

      整个过程非对称加密只是对随机密匙进行加密，对称加密是对真正发送的数据进行加密，Hash算法用于验证数据完整性

   - 对称加密和非对称加密区别
     - 对称机密：加密和解密使用相同的密匙，算法有DES、RC2、RC4
     - 非对称加密：加密和解密分别使用公钥和私钥，算法有RSA
     - 区别：对称加密速度快，适用于大量数据加密；非对称加密安全性高，因为不传送私钥
   - 数字签名，摘要算法
     - 数字签名：发送者用私钥进行签名，接收者用公钥进行验证，如果验证通过接收者有理由相信发送者一定是A
     - 摘要算法：MD5，SHA

4. Cookie和Session的区别

   Cookie是客户端保持状态的方案，Session是服务端保持状态的方案

   Cookie保存在客户端，每次请求会一起提交Cookie；Session保存在服务端，通过检索SessionID查看状态。保存SessionID可以采用Cookie，也可以使用URL重写机制保存会话ID到URL中

### get和post方法

1. 区别

   1. get方法参数放到URL里，而post方法参数放到请求体里
   2. get方法请求体为空，post方法请求体不为空
   3. get方法长度是有限的，2K，post方法长度不限
   4. get方法要求幂等性，也就是同样的请求具有相同的副作用，而post请求没有。这样get方法适合查询，而post方法 适合增删改
   5. get方法和post方法底层都是TCP/IP协议，只是规定不同
   6. get方法只能使用ASCII编码，而post请求没有要求
   7. get方法比post更不安全，get请求可以被浏览器缓存收藏

2. 请求内容，响应内容，响应状态码类别

   1. 请求报文

      请求行：请求方法，URL字段，协议版本

      请求头：键值对（Accept-客户端可以接受的资源类型，Accept-Language-接受资源的语言，Accept-Encoding-接受资源的编码，User-Agent-客户端

      空行

      请求体

   2. 响应报文

      状态行：协议版本，状态码和状态描述

      响应头：

      空行

      响应体

   3. 响应状态码

      1. 2xx，操作成功，200 ok
      2. 3xx，重定向，301 永久重定向
      3. 4xx，客户端错误，401 bad request，402 没授权，403 禁止，404 not found
      4. 5xx，服务端错误，500 服务端内部错误，501服务不可用

## OSI模型 TCP/IP模型

[OSI TCP/IP模型](https://www.bilibili.com/read/cv7082441/)

OSI模型

1. 应用层：是特定的应用程序，数据单位是报文，TCP/IP把上面三层合并，得到应用层，应用层协议包括HTTP、DNS、FTP、TELNET、SMTP等
2. 表示层：负责数据的加密解密和压缩等，数据单位是报文
3. 会话层：管理会话（比如何时建立连接，何时关闭连接，会话时长），数据单位是报文
4. 传输层：建立端到端的连接，数据单位是数据段，协议有TCP UDP
5. 网络层：负责寻址和路由，数据单位是报文，协议有ARP、RARP、IP、ICMP、IGMP
6. 数据链路层：控制物理层的协议，包括如何访问和共享介质、如何标识设备、如何封装成帧，单位是帧
7. 物理层：传播电气信号和数据比特，包含多种物理介质，数据单位是位

# Java和框架相关(JDK)

**Java书籍**

Java 标准规范：[Java SE8 ](https://docs.oracle.com/javase/specs/index.html) [JDK 8](https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf)   [JVM8](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf)

[Java核心技术 基础知识]("C:\Users\cheng\Desktop\JavaBackend\书籍\Java\Java核心技术 卷1 基础知识 原书第9版 完整中文版 .pdf")

[深入理解Java虚拟机]("C:\Users\cheng\Desktop\JavaBackend\书籍\Java\深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）周志明.pdf")

[Java并发编程实战]("C:\Users\cheng\Desktop\JavaBackend\书籍\Java\Java并发编程实战（中文版）.pdf")

## 运算优先级

单目（+- !）

乘除（* /）

位（^ << >> ）

关系（> < = != ）

逻辑（&& || ）

三目（A? B:C）

后赋值（A=B）

## 查找树

### AVL平衡二叉树

[参考](https://blog.csdn.net/code_peak/article/details/120610047)

```java

class AVLTree{
	private class AVLTreeNode{
		public int val ;
		public int height ;
		public AVLTreeNode left, right ;
		
		AVLTreeNode(int v, int h, AVLTreeNode left, AVLTreeNode right){
			this.val = v ;
			this.height = h ;
			this.left = left ;
			this.right = right ;
		}
	}
	
	private AVLTreeNode root = null ;
	
	private int getHeight(AVLTreeNode node) {
		return node == null? 0 : node.height ;
	}
	
//	LLRotation(pRoot)
//	传入最小的失衡的系节点pRoot
//	对pRoot右旋
	private AVLTreeNode LLRotation(AVLTreeNode node) {
		AVLTreeNode nodeLeft = node.left ;
		node.left = nodeLeft.right ;
		nodeLeft.right = node ;
		
		node.height = Math.max( getHeight(node.left), getHeight(node.right ) ) + 1 ;
		nodeLeft.height = Math.max( getHeight(nodeLeft.left), getHeight(nodeLeft.right) ) + 1 ;
		return nodeLeft ;
	}
//	RRRotation(pRoot)
//	传入最小失衡节点pRoot
//	对pRoot进行一次左旋
	private AVLTreeNode RRRotation(AVLTreeNode node) {
		AVLTreeNode nodeRight = node.right ;
		node.right = nodeRight.left ;
		nodeRight.left = node ;
		
		node.height = Math.max(getHeight(node.left),  getHeight(node.right) ) + 1 ;
		nodeRight.height = Math.max( getHeight(nodeRight.left), getHeight(nodeRight.right ) ) + 1 ;
		return nodeRight ;
	}
//	LRRotation(pRoot)
//	传入最小失衡的节点pRoot
//	先对pRoot.left左旋
//	再对pRoot右旋
	private AVLTreeNode LRRotation(AVLTreeNode node) {
		AVLTreeNode nodeLeft = node.left ;
		nodeLeft = this.RRRotation(nodeLeft) ;
		node.left = nodeLeft ;
		
		return this.LLRotation(node) ;
	}
	private AVLTreeNode RLRotation(AVLTreeNode node) {
		AVLTreeNode nodeRight = node.right ;
		nodeRight = this.LLRotation(nodeRight) ;
		node.right = nodeRight ;
		
		return this.RRRotation(node) ;
	}
	
//	最大值节点
	public AVLTreeNode maxNode(AVLTreeNode root) {
		while(root.right != null)
			root = root.right ;
		return root ;
	}
//	最小值节点
	public AVLTreeNode minNode(AVLTreeNode root) {
		while( root.left != null)
			root = root.left ;
		return root ;
	}
	
	//查找元素
	//返回根节点
	public boolean search(int key) {
		if( search(root, key) != null)
			return true ;
		return false ;
	}
	private AVLTreeNode search(AVLTreeNode root, int key) {
		if( root == null || root.val == key)
			return root ;
		if( key<root.val )
			return search( root.left, key) ;
		else
			return search( root.right, key ) ;
	}
	
	//增加元素，返回根节点
	public void add(int key) {
		root = add(root, key) ;
	}
	private AVLTreeNode add( AVLTreeNode root, int key) {
		if( root == null ) 
			return new AVLTreeNode(key, 1, null, null) ;
		if( key < root.val ) {
			root.left = add(root.left, key) ;
			if( this.getHeight(root.left)- this.getHeight(root.right) == 2 ) {
				if( key<root.left.val )
					root = this.LLRotation(root) ;
				else
					root = this.LRRotation(root) ;
			}
		}else if( key> root.val) {
			root.right = add( root.right, key) ;
			if( this.getHeight(root.right) - this.getHeight(root.left) == 2) {
				if( key> root.right.val )
					root = this.RRRotation(root) ;
				else
					root = this.RLRotation(root) ;
			}
		}else {
			System.out.println("allready in: "+ key) ;
		}
		root.height = Math.max( this.getHeight(root.left), this.getHeight(root.right ) ) + 1 ;
		return root ;
	}
	
	//删除元素，返回根节点
	public boolean remove(int key) {
		AVLTreeNode ret = this.search(root, key) ;
		if( ret == null) {
			System.out.println(key + " not in AVL") ;
			return false ;
		}
		root = this.remove(root, ret ) ;
		return true ;
	}
	private AVLTreeNode remove( AVLTreeNode root, AVLTreeNode key) {
		if( key.val< root.val) {
			root.left = this.remove(root.left, key) ;
			if( this.getHeight(root.right) - this.getHeight(root.left) == 2 ) {
				AVLTreeNode right = root.right ;
				if( this.getHeight(right.left) > this.getHeight(right.right) ) {
					//LR型
					root = this.LRRotation(root) ;
				}else {
					root = this.RRRotation(root) ;
				}
			}
		}else if( key.val> root.val) {
			root.right = this.remove( root.right, key) ;
			if( this.getHeight(root.left) - this.getHeight(root.right) == 2) {
				AVLTreeNode left = root.left ;
				if( this.getHeight(left.left) > this.getHeight(left.right) ) {
					root = this.LLRotation(root) ;
				}else {
					root = this.LRRotation(root) ;
				}
			}
		}else {
			if( root.left == null && root.right == null) {
				return null ;
			}
			if( this.getHeight(root.left) >= this.getHeight(root.right )) {
				AVLTreeNode leftMax = this.maxNode(root.left) ;
				root.val = leftMax.val ;
				root.left = this.remove( root.left, leftMax) ;
			}else {
				AVLTreeNode rightMin = this.minNode(root.right) ;
				root.val = rightMin.val ;
				root.right = this.remove( root.right, rightMin) ;
			}
		}
		root.height = Math.max(this.getHeight(root.left), this.getHeight(root.right)) + 1 ;
		return root ;
	}
	
	
	public void show() {
		show(root) ;
		System.out.println();
	}
	private void show(AVLTreeNode root) {
//		System.out.println(root.val) ;
		if( root == null || (root.left == null && root.right == null))
			return ;
		System.out.println(root.val) ;
		
		if( root.left != null) {
			System.out.println( root.val+ " " + root.height + " L " + root.left.val) ;
		}
		if( root.right != null) {
			System.out.println( root.val + " " + root.height + " R " + root.right.val ) ;
		}
		
		show( root.left) ;
		show( root.right) ;
	}
}

public class Main { 
	
	public static void main(String[] args) throws Throwable { 
		AVLTree tree = new AVLTree() ;
		tree.add(1) ;
		tree.add(2) ;
		
//		tree.show();
		
		tree.add(3) ;
		tree.add(-1);
		tree.add(10);
		tree.add(3);
		
		tree.show() ;
		
		tree.remove(2) ;
		tree.show();
		
//		tree.add(-1);
//		tree.add(5);
//		
//		tree.add(-2);
		
//		tree.show();
//		System.out.println(tree.search(-1)) ;
	}
}
```

#### AVL树讨论

AVL树任意节点的两个子树的高度差不超过1

### 红黑树

[参考1](https://blog.51cto.com/u_15197573/5164593?b=totalstatistic)

[参考2](https://blog.csdn.net/weixin_42786274/article/details/86557922)

[参考代码](https://www.jianshu.com/p/eb6e3fa41c66)

```java
class RedBlackTree{
	
	private static final int Red = 1 ;
	private static final int Black = 0 ;
	private class RedBlackTreeNode{
		public RedBlackTreeNode parent, left, right ;
		public int val , color ;
		public RedBlackTreeNode(RedBlackTreeNode p, RedBlackTreeNode l, RedBlackTreeNode r, int v, int c) {
			this.parent = p ;
			this.left = l ;
			this.right = r ;
			this.val = v ;
			this.color = c ;
		}
	}
	
	private RedBlackTreeNode root = null ;
	
	//左旋
	private void leftRotation(RedBlackTreeNode node) {
		RedBlackTreeNode right = node.right ;
		node.right = right.left ;
		right.left = node ;
		
		right.parent = node.parent ;
		node.parent = right ;
		
		if( node.right != null)
			node.right.parent = node ;
		if( right.parent != null) {
			if(right.parent.left == node) {
				right.parent.left = right ;
			}else {
				right.parent.right = right ;
			}
		}else {
			this.root = right ;
		}
	}
	//右旋
	private void rightRotation(RedBlackTreeNode node) {
		//类似AVL的右旋
		RedBlackTreeNode left = node.left ;
		node.left = left.right ;
		left.right = node ;
		
		//设置left节点父节点为node节点父节点，设置node节点父节点为left节点
		left.parent = node.parent ;
		node.parent = left ;
		
		//设置原left节点的右子节点的父节点为node节点
		if(node.right != null)
			node.right.parent = node ;
		//设置left节点的父节点的子节点
		if( left.parent != null) {
			if( left.parent.left == node) {
				left.parent.left = left ;
			}else {
				left.parent.right = left ;
			}
		}else {
			//如果left节点父节点为null，说明left节点是root节点，那么设置root节点
			this.root = left ;
		}
	}
	
//	add(key)
//	找到add的parent节点，添加node节点到parent节点
//	然后调整节点
//	设置node节点的color为红色
//	如果node节点的父节点是黑色，不做任何改变
//	while node节点不为空&&node节点不为root节点&&node节点的父节点的color是红色：
//		if node节点的父节点是祖父节点的左子节点
//			if 父节点的兄弟节点存在并且是红色，
//				那么修改父节点和父节点兄弟节点为黑色，修改祖父节点为红色，让node=祖父节点继续调整
//			else node节点的父节点的兄弟节点不存在
//				if node节点是父节点的右子节点,形成LR型结构，要转换成LL型结构
//					根据node节点的父节点左旋，并且令node节点=父节点
//				对LL型结构，设置父节点为黑色，祖父节点为红色，根据祖父节点进行进行右旋，调整结束
//		else node节点的父节点是祖父节点的右子节点
//		    if 父节点的兄弟节点存在并且为红色
//		        那么修改父节点和父节点的兄弟节点为黑色，修改祖父节点为红色，让node=祖父节点继续向上调整
//		    else 父节点的兄弟节点不存在
//		        if node节点是父节点的左子节点，形成RL型结构，要转成RR型结构
//		            根据node节点的父节点右旋，并且令node节点=父节点
//		        对RR型结构，设置父节点为黑色，祖父节点为红色，根据祖父节点进行左旋，调整结束
	public void add(int key) {
		//添加root节点
		if(root == null) {
			root = new RedBlackTreeNode(null, null, null, key, Black) ;
			return ;
		}
		
		//查找到添加位置的父节点parent
		RedBlackTreeNode tmp = root, parent = null ;
		while( tmp!=null ) {
			parent = tmp ;
			if( key<tmp.val )
				tmp = tmp.left ;
			else if( key>tmp.val)
				tmp = tmp.right ;
			else {
				System.out.println(key + " 已经存在") ;
				return ;
			}
		}
		
		RedBlackTreeNode node = new RedBlackTreeNode(parent, null, null, key, Red) ;
		if( key<node.parent.val ) {
			node.parent.left = node ;
		}else {
			node.parent.right = node ;
		}
		
		fixTree(node ) ;
	}
	private void fixTree(RedBlackTreeNode node) {
		//设置新节点颜色为Red
		node.color = Red ;
		//如果node不为空，node不是root节点，node父节点颜色是Red
		while( node!= null && node!= root && node.parent.color == Red) {
//			如果node父节点是祖父节点的左子节点
			//因为root节点为Black，当node.parent为Red时，一定存在node的祖父节点
			if( node.parent == node.parent.parent.left ) {
				//如果父节点兄弟节点存在
				//修改父节点和兄弟节点颜色为黑色，祖父节点颜色为红色，node节点=祖父节点，继续向上调整
				if( node.parent.parent.right != null && node.parent.parent.right.color == Red) {
					node.parent.color = Black ;
					node.parent.parent.right.color = Black ;
					node.parent.parent.color = Red ;
					node = node.parent.parent ;
				}else {
					//如果父节点兄弟节点不存在，
					//1. 如果是LR型结构，转成LL型结构，node=node.parent, 对node左旋
					//2. 设置node父节点黑色，祖父节点红色，祖父节点右旋
					//完成调整
					if( node == node.parent.right ) {
						node = node.parent ;
						this.leftRotation(node);
					}
					node.parent.color = Black ;
					node.parent.parent.color = Red ;
					this.rightRotation(node.parent.parent);
				}
			}else {
				if( node.parent.parent.left != null) {
					node.parent.color = Black; 
					node.parent.parent.left.color = Black ;
					node.parent.parent.color = Red ;
					node = node.parent.parent ;
				}else {
					if( node == node.parent.left ) {
						node = node.parent ;
						this.rightRotation(node);
					}
					node.parent.color = Black ;
					node.parent.parent.color = Red ;
					this.leftRotation(node.parent.parent);
				}
			}
		}
		this.root.color = Black ;
	}
	
	public void show() {
		show(this.root) ;
	}
	private void show( RedBlackTreeNode node ) {
		if( node == null  )
			return ;
		
		if( ( node.left == null && node.right == null ) ) {
			System.out.println( node.val +" "+ (node.color==1? "Red":"Black") ) ;
		}
		if( node.left != null) {
			System.out.println( node.val +" "+ (node.color==1? "Red":"Black") + "  L "+ node.left.val ) ;
		}
		if( node.right != null) {
			System.out.println( node.val +" "+ (node.color==1? "Red":"Black") + "  R "+ node.right.val ) ;
		}
		
		show(node.left ) ;
		show(node.right ) ;
	}
}

public class Main { 
	
	public static void main(String[] args) throws Throwable { 
		RedBlackTree tree = new RedBlackTree() ;
		
//		tree.add(2);
		tree.add(3);
		tree.add(5);
		tree.add(1);
		tree.add(6);
//		tree.add(-1);
		tree.add(10);
		
		
		tree.show();
	}
}
```

#### AVL树讨论

AVL树是一个平衡二叉树，它满足四条性质

1. 节点要不是红要不是黑
2. 根节点是黑
3. 红节点的两个子节点必为黑
4. Null节点为黑
5. 从根节点到叶节点的任意路径的黑节点数目相同

其中第五条性质保证了最长路径不大于最短路径的2倍，因为最长路径是红黑相间的路径，而最短的路径是全为黑色的路径，这样可以看到最长路径的长度不大于最短路径的2倍，所以是近似平衡的

### B树

[参考代码](https://blog.csdn.net/u011983531/article/details/78377026)

[参考代码](https://github.com/tclxspy/Articles/blob/master/algorithm/MD/%E7%AE%97%E6%B3%95%2316--B%E6%A0%91%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81Java%E5%AE%9E%E7%8E%B0.md)

[参考](https://www.cnblogs.com/dfyz/p/5029797.html)

```java
class BTree{
	static int t = 2 ;
	static final int M = 2*t ;
	static final Boolean Leaf = true ;
	static final Boolean NonLeaf = false ;
	
	class Node{
		public Boolean leaf ;
		public int size ;
		public Entry[] entry = new Entry[M] ;
		public Node() {
			size = 1 ;
			entry[0] = new Entry(-1, null) ;
		}
	}
	class Entry{
		int key ;
		Node next ;
		Entry(int k, Node node) {
			this.key = k ;
			this.next = node ;
		}
	}
	
	Node root = null;
	BTree(){
		root = new Node() ;
		root.leaf = true ;
	}
	//增加元素
	//如果root节点满，那么分离root节点
	//如果root节点不满，调用insertNonNull(root, key)
	public void insert(int key) {
		System.out.println(key) ;
		if( root.size == M) {
			//分离root节点，
			//令旧root节点为oldRoot
			//取中间Entry e，创建一个新的root节点newRoot，将节点e放到newRoot的数组
			//新建Node z，将oldRoot节点的e Entry的后面的Entry复制到z的数组，修改z的size
			//将e.next = z; newRoot.entry[0].next = oldRoot
			//令root = newRoot 
			Entry e = root.entry[ M/2 ] ;
			root.size = M/2 ;
			
			Node z = new Node() ;
			z.leaf = root.leaf ;
			for(int i=M/2+1;i<M;i++) {
				z.entry[ z.size++ ] = root.entry[i] ;
			}
			
			Node newRoot = new Node() ;
			e.next = z ;
			newRoot.entry[ newRoot.size++ ] = e ;
			newRoot.leaf = false ;
			newRoot.entry[0].next = root ;
			
			root = newRoot ;
		}
		insertNonNull(root, key) ;
	}
	private void insertNonNull( Node root, int key) {
		//如果root是叶子节点，直接插入key
		//如果root不是叶子节点，
		//   首先找到key插入的Entry节点e，检查e.next指向的子节点是不是满
		//   如果满，就调用splitNode分离子节点，分离之后再调用insertNonNull(root,key)
		//   如果不满，那就调用insertNonNull(e.next, key)
		System.out.println("in insertNonNull: " + key) ;
		int i = 1 ;
		while(i<root.size && key > root.entry[i].key ) {
			i++ ;
		}
		System.out.println( "i : "+ i) ;
		if( root.leaf == true) {
			
			if( i==root.size ) {
				root.entry[root.size] = new Entry(key, null) ;
			}else {
				for(int j=root.size-1;j>=i;j--) {
					root.entry[j+1] = root.entry[j] ;
				}
				root.entry[i] = new Entry(key, null) ;
			}
			root.size ++ ;
			
			showNode( root ) ;
		}else {
			//获得key节点插入的子节点
			Entry e = root.entry[i-1] ;
			System.out.println("Show root") ;
			showNode(root) ;
			//判断这个子节点是否是满节点
			if( e.next.size == M) {
				//满节点，就分离
				splitNode(root, i-1) ;
				showNode(root) ;
				insertNonNull(root, key) ;
			}else {
				insertNonNull(e.next, key) ;
			}
		}
	}
	private void splitNode(Node root, int i) {
		//获得root.entry[i]的子节点next, 获取e=next.entry[ M/2]
		//将e放到root.entry[i+1]的位置
		//创建z节点复制next节点的一半的entry
		//z.entry[0].next = e.next ;
		//e.next = z ;
		
		Node next = root.entry[i].next ;
		Entry e = next.entry[ M/2 ] ;
		next.size = M/2 ;
//		System.out.println(e.key) ;
		
		Node z = new Node() ;
		for(int j=M/2+1;j<M;j++) {
			z.entry[z.size++] = next.entry[j] ;
		}
		z.leaf = next.leaf ;
		
		z.entry[0].next = e.next ;
		e.next = z ;
		for(int j=root.size-1;j>=i+1;j--) {
			root.entry[j+1] = root.entry[j] ;
		}
		root.entry[i+1] = e ;
		root.size++ ;
	}
	
	private void showNode(Node root) {
		System.out.println("Node: "+root) ;
		for(int i=0;i<root.size;i++) {
			System.out.println(root.entry[i].key + " : "+ root.entry[i].next ) ;
		}
		System.out.println("===========") ;
	}
	public void show() {
		show(root) ;
	}
	private void show( Node root) {
		if( root == null)
			return ;
		
		System.out.println(root) ;
		for(int i=0;i<root.size; i++) {
			System.out.println(root.entry[i].key + " : "+ root.entry[i].next ) ;
		}
		System.out.println("===========") ;
		
		for(int i=0;i<root.size;i++) {
			show(root.entry[i].next ) ;
		}
	}
}

public class Main { 
	
	public static void main(String[] args) throws Throwable { 
		BTree tree = new BTree() ;
		for(int i=6;i>=1;i--) {
			tree.insert(i);
		}
		
		System.out.println() ;
		tree.show();
	}
}
```

#### B树讨论

B树节点包括key数组和子节点数组，数组大小是M，M是阶数，也是最小读书t的两倍，n表示key的个数，则n+1是子节点的个数，节点用leaf标记是否为叶节点

B树的高度是
$$
height = O(log_t( (n+1) \div2))
$$
B树是一种用于索引的数据结构，之所以用B树，因为B树是一个多路树，他的节点可以设计的很大，跟磁盘页一样大，从而减少树的高度，进而让索引的时候减少磁盘IO的操作。B树把自己的根节点保留再内存，插入的时候找到插入的节点位置，然后根据这个节点位置的磁盘地址从外存中读取这个页面到内存，如果对这个页面发生修改，修改完成之后写入到磁盘。为什么不用红黑树或者AVL平衡树，因为他们叶子节点都是二，树的高度太高，增加磁盘IO次数。B树的节点都是按页保存在外存。

B树查找复杂度和增加节点复杂度都是，其中t是最小度数
$$
O(tlog_t(n))
$$
B+树是B树的一种扩展，他和B树不同的点在于他的数据结构key包含前驱节点pre和后继节点next，形成一个链表；B+树在分离节点的时候，把用于分离的节点保留在了左子节点，而B树没有保存在子节点，这样B+树的所有数据都保存在叶节点，而中间节点只是索引的功能，而B树的每个节点都可以包含对数据项的引用；B+树使用链表结构使得遍历B+树有两种方法，一种是使用链表，一种是直接中序遍历B+树。

### 完全二叉树、满二叉树、二叉搜索树、平衡二叉树AVL树、红黑树、B树、B+树

[参考](https://www.cnblogs.com/fengtingxin/p/13720992.html)

完全二叉树：空树不是完全二叉树，完全二叉树的叶子节点只在最底层和次底层，并且最底层全集中在最坐标。

满二叉树：除了最底层所有节点都没有子节点，非叶节点都有两个子节点

二叉搜索树：根节点的左子节点都小于根节点，根节点的右子节点都大于等于根节点，理论增删改查复杂度log(n)，但有一种退化成链表的情况

AVL树，一种平衡二叉树，任意节点的左右子节点高度不超过1，当失衡时需要左右旋操作

红黑树：一种近似平衡二叉树，最长节点不超过最短节点2倍。红黑树相较于AVL树，不是高度平衡的，在删除节点时最多三次旋转操作，而AVL树要维护删除操作的那一条路，所以AVL维护代价更高；AVL因为高度平衡，查询性能优于红黑树；综合来说红黑树优于AVL树。

B树，多路树，所有叶子节点深度相同，用于索引结构

B+树，B+树优于B树一个是B+树的关键字只是关键字用于索引，而B树的关键字包含了数据在磁盘的位置指针，这减少了一次取页的关键字的个数，为查询数据增加了次数；其次是B+树使用链表方便区间查询。

## Java集合框架

[集合框架](https://www.geeksforgeeks.org/how-to-learn-java-collections-a-complete-guide/)

### List接口

#### ArrayList

ArrayList实现了List接口，底层实际上是动态数组

1. 增

   检查size是否超过length，如果超过，那么length增加一半，内存增加一半，再添加元素，之后size+1

2. 删

   检查删除的index是否越界，没有越界，那么将动态数组元素向前移动一个位置，size-1

3. 改

   检查index是否越界，没有越界直接再数组上修改

4. 查

   检查index是否越界，没有越界直接按index返回数据

5. 检查元素是否在数组中，循环查询，使用元素的eaquals函数比较

6. sort，默认使用merge_sort，可以添加比较方法

7. hashcode

   ```java
   int hashcode = 1 ;
   for(E e: objArr){
   	hashcode = 31*hashcode + (e==null)?0:e.hashCode() ;
   }
   ```

8. eaquals

   比较每个Element是否相等

9. ArrayList的hashcode方法和equals方法是现成安全的，它使用了modificationCounter实现了CAS机制，从而保证了hashCode方法和equals方法的线程安全性。

   ArrayList是不线程安全的，比如增加数据，两个线程同时读取了size，那么在添加数据的时候他们会发生覆盖，从而只是添加了一个元素

10. ArrayList可以初始化length，如果没有，默认为0，之后如果添加数据，设置为10；之后如果内存不够，就至少增加一半

#### Vector

Vector和ArrayList类似，区别在于Vector是在ArrayList方法之上添加了Synchronized修饰方法，从而保证了线程安全。

Vector 扩容时2倍，ArrayList扩容时1.5倍，为什么设置成2倍和1.5倍，首先采用固定增量扩容平均push_back一个元素的时间复杂度是线性的，而采用倍增的方法可以将增加元素的复杂度变成O(1)；其次，为什么不采用更高的比如3倍，因为在分配内存的时候使用2倍的话，每一次分配内存总是大于前面所有分配内存的和，这样我们在复制分配内存的时候就不能利用原来的内存，所以分配内存大小倍增应该在(1,2)之间其取值

#### Stack

Stack继承自Vector，是线程安全的。可以用双端队列ArrayDeque和LinkedList实现Stack，但是那是不线程安全的

#### LinkedList

LinkedList实现了List和Deque接口，不仅仅是链表，也是双端队列，可以用来实现栈和队列，但是这是不线程安全的。LinkedList没有实现hashCode和equals函数，因为他可以是双端队列，所以方向没办法确定。

```java
class MyLinkedList{
	class Node{
		int val ;
		Node pre ;
		Node next ;
		
		Node(Node p, int v, Node n ){
			pre = p ;
			val = v ;
			next = n ;
		}
	}
	
	Node first = null ;
	Node last = null ;
	
	int size = 0 ;
	
	private void linkLast(int v ) {
		Node l = last ;
		Node newNode = new Node(last, v, null) ;
		last = newNode ;
		if( l == null) {
			first = newNode ;
		}else {
			l.next = newNode ;
		}
		size ++ ;
	}
	
	
	
	public void add(int v) {
		linkLast( v ) ;
	}
	
	private Node nodeAt(int idx) {
		if( idx<1 || idx>size )
			throw new RuntimeException("index越界") ;
			
		Node f = first ;
		for( int i=0;i<idx-1;i++) {
			f= f.next ;
		}
		return f ;
	}
	
	public int get(int idx) {
		return nodeAt(idx).val ;
	}
	
	public void remove(int idx ) {
		Node node = nodeAt(idx ) ;
		Node pre = node.pre ;
		Node next = node.next ;
		System.out.print("node value") ;
		System.out.println( node.val ) ;
		
		if( pre == null ) {
			first = next ;
		}else {
			pre.next = next ;
		}
		
		if( next == null ) {
			last = pre ;
		}else {
			next.pre = pre ;
		}
		
		node = null ;
		size -- ;
	}
	
	public void print() {
		Node f = first ;
		for( int i=0;i<size;i++) {
			System.out.print( f.val ) ;
			System.out.print(" ");
			f = f.next ;
		}
		System.out.print("    size:");
		System.out.println( size) ;
	}
}

public class Main {

	public static void main(String[] args) {
		MyLinkedList mylst = new MyLinkedList() ;
		
		mylst.add(0);
		mylst.add(1);
		mylst.add(23);
		
		mylst.print();
		
		System.out.println( mylst.get(1) ) ;
//		System.out.println( mylst.get(5) ) ;
		
		mylst.print();
		
		mylst.remove(3);
		mylst.print();
	}

}
```

### Queue接口

#### Deque接口

##### LinkedList

实现了List和Deque接口的链表实现双端队列。使用First和Last标记指向链表第一个和最后一个节点，操作总是在First和Last位置进行操作。操作都是常数复杂度

##### ArrayDeque

底层数据结构是动态数组。使用循环队列实现双端队列，head和tail初始化指向0下标，head总是指向队列新加入的元素，tail总是为空，并且总是在队列最早加入的元素的前面。

1. 增加元素，push操作使用addFirst实现，head先减1，然后加入增加的元素，

   在增加元素的时候判断队列（动态数组）是否为满：当增加元素的时候head==tail，那么说明队列为满，就扩容

   ArrayDeque扩容是至少增加一半容量jump，也可以增加指定的容量needed，但是needed>jump。获得扩容的newCapacity之后，新申请一个newCapacity的数组，使用System.arrayCopy(oldes, 0, newes,0, oldLength)复制到新数组；之后调整head和tail的位置，这需要tail<head或者tail==head并且es[head]!=null，首先获取newSpace = newCapacity-oldCapacity，然后使用System.arrayCopy(es, head, es,head+newSpace, oldCapacity-head)进行复制，这里获得head后面的所有元素个数使用oldCapacity-head。

   ArrayList扩容也是增加一半容量

   Vector扩容增加一个容量

2. 删除元素，pop操作使用removeFirst实现，首先获取head位置的元素e，如果e!=null，那么head加1，返回e，否则返回null，发生NoElementException

   判断删除元素后队列为空

   在删除元素的时候判断head==tail则队列为空

   removeLast实现，首先h=tail-1，e=elements[h]，如果e!=null，那么tail减1，返回e，否则返回null，发生NoElementException

   删除元素后判空，删除元素head==tail则为空

3. 判空

   因为在加入元素的时候保证了为满就增加容量，所以只有一种情况会出现head==taill，那就是为空，所以可以用head==tail判断是否为空。

4. 判满

   head==tail并且es[head] != null，因为在增加元素时发生head==tail就代表满了。

5. 元素个数

   tail-head<0 ? tail-head+es.length, tail-head ;

#### PriorityQueue

```java

class PQueue{
	private int[] que = new int[20] ;
	
	private int size = 0 ;
	
	private void siftUp(int k, int x) {
		while(k>0) {
			int parent = (k-1)>>1 ;
			int c = que[parent] ;
			if( c< x )
				break ;
			que[k] = c ;
			k = parent ;
		}
		que[k] = x ;
	}
	private void siftDown(int k, int x) {
		int half = size>>1 ;
		
		while(k<half) {
//			System.out.println(k) ;
			int pos = ((k<<1)+1) ;
			System.out.println(pos) ;
			int c = que[pos] ;
			int right = pos +1 ;
			if( right<size && que[right]<c)
				c = que[ pos= right] ;
			System.out.print(x);
			System.out.print(" ");
			System.out.println(c) ;
			if( x<c )
				break ;
			que[k] = c ;
			k = pos ;
		}
		que[k] = x ;
	}
	
	public void add(int x) {
		siftUp(size++, x ) ;
		System.out.print("        size: ");
		System.out.println(size) ;
	}
	public int peek() {
		return que[0] ;
	}
	public int pop() {
		int result = que[0] ;
		int x = que[--size] ;
		siftDown(0, x) ;
		
		System.out.println("aaaaa") ;
		return result ;
	}
	
	public void print() {
		for( int i=0;i<size;i++) {
			System.out.print(que[i]) ;
			System.out.print(" " );
		}
		System.out.println() ;
	}
}
```

1. PriorityQueue 是一个堆，底层使用动态数组实现，从0开始标号
2. 关键的点在于siftUp函数和siftDown函数
3. 当容量不够的时候至少扩充原来数组的一半。

### Set接口

#### SortedSet接口

##### NavigableSet接口

###### TreeSet

#### HashSet

#### LinkedHashSet

### Map接口

#### SortedMap接口

##### NavigableMap接口

###### TreeMap

#### HashMap

TreeSet、TreeMap使用红黑树存储

HashMap默认桶的个数是16，默认调整红黑树的节点个数是8，当initCapacity不为2的幂次，会自动转换成大于initCapacity的最小的幂次。当size个数>capacity*loadFactor就扩容，扩充桶的个数，此时桶的个数是2的幂次就有用了，h&32==0就代表节点在新桶的位置等于在旧桶的位置，如果h&32==1就代表节点在新桶的位置是旧桶的位置+16

HashMap存储结构是数组+链表，当链表长度>=8时替换链表使用红黑树存储数据

HashMap处理hash冲突使用拉链法，链表插入使用尾插法，因为要计算链表长度判断是否转换成红黑树

HashMap可以存放null:valuue的键值对，默认null的key保存在0号桶

HashMap数组大小时2的幂次好处是可以在计算桶的下表的时候可以使用位运算h&(length-1) == h%length，来计算桶的下表；其次是在扩容的时候，比如16扩容到32，可以用h&32==0 也就是判断h的第五位来判断到新桶下标等于旧桶下表，如果h&32==1，那么新桶下标是旧桶下表+16 ；

**插入**

1. 首先计算key的hash值，计算方法是key.hashCode()^key.hashCode()>>>16

2. 判断table是否为空，为空就resize分配内存给table，resize总是扩充为原桶的两倍，然后重新把旧节点放到新桶，这个时候判断一个节点的桶的位置可以用hash&32==0，就代表在原桶；hash&32==1，就代表在原桶+16的那个桶
3. 利用hash&(length-1)获得key所在的桶的下标，判断头节点p是否为空，为空就分配p节点内存保存key
4. 如果不为空，判断p是否是RBTreeNode节点，如果是，就执行RBTreeNode并且返回一个旧的保存key的节点
5. 如果p不是树节点，就遍历链表，如果遇到一个关键字与key相同的节点，返回这个节点，否则就在尾部插入key关键字的节点
6. 判断插入之后链表长度是否大于等于链表转树的阈值，如果大于等于8，就把链表转为红黑树，并且把树的根节点赋值给桶第一个节点
7. 如果e不为空，代表哈希表存在这个key，返回e的旧值

**获取key节点的数值**

计算key的hash值，找到对应的桶

判断桶的节点p是否是树节点，是树节点就查找红黑树

否则遍历链表

#### HashTable

HashMap和HashTable区别

1. HashTable使用synchronized进行同步
2. HashMap支持null的key节点
3. HashMap不保证节点顺序
4. HashMap迭代器是failfast的。

#### LinkedHashMap

LinkedHashMap继承自HashMap，他只是在HashMap的节点添加了两个指针，从而把HashMap的节点通过head和tail构建出一个在HashMap结构基础上还有关于head和tail的双向链表。当添加一个元素的时候，按照hashMap的方式添加，同时也要把他加入到tail节点后面；当访问到一个节点后，就把这个节点重新添加到tail节点；当增加元素的时候，考虑把head元素删除。

#### WeakHashMap

WeakHashMap的节点是继承自WeakReference对象的节点，其他和HashMap相同，这种结构只是利用弱引用容易被回收的特点方便JVM回收HashMap的对象

**Tomcat的concurrentCache使用了WeakHashMap**

```java
public final class ConcurrentCache<K, V> {

    private final int size;

    private final Map<K, V> eden;

    private final Map<K, V> longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap<>(size);
        this.longterm = new WeakHashMap<>(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() >= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
```

ConcurrentCache把缓存划分为两个部分Eden区和Longtern区，Longtern区存放弱引用哈希表，首先被回收

- 对于get操作，首先在Eden区get，如果没有再在Longtern区get，并且把get的对象放到Eden区
- 对于put操作，如果size不够，把Eden区全部转移到Longtern区，再在Edent插入

## Java并发集合框架Java.util.Concurrent JUC

[参考-介绍并发集合框架](https://spongecaptain.cool/post/java/frameworkofjuc/#41-lock)

**浅拷贝和深拷贝**

浅拷贝只拷贝引用，引用所指向的对象没有改变

深拷贝不仅拷贝引用，还拷贝了引用所指的对象，新引用所指向的对象是新拷贝的对象。

**锁的释放**

- 正常结束：synchronized代码块执行结束，ReentrantLock在finally调用lock.unlock
- 异常结束：在synchronized代码块或者ReentrantLock的try代码块抛出异常
- return释放：在代码块调用return返回

### 顶层

#### Lock包

[参考](https://blog.csdn.net/qq_20499001/article/details/103322794)

##### ReetrantLock

底层使用AQS作为同步队列（锁池队列），使用Unsafe的CAS，初始化CAS的state变量为0，当一个执行态的线程到来时竞争state，cas(state, 0, 1)，期望值是0，如果成功设置为1，那么代表这个线程竞争到锁，它可以继续执行；如果之前一个线程已经竞争到锁，那么state就不可能是0，那么这个线程就无法设置state变量，从而不能竞争到锁，之后这个线程被放到同步阻塞队列，等待竞争锁。当进行lock.unlock()的时候，会让state-1，并且返回false；如果state减到0，那么就说明没有占用

ReetrantLock实现了Lock接口，它可以结合Condition接口实现synchronized条件等待

```java
//A 线程
synchronized(lock){
	lock.wait(); //进入等待队列，失去锁
}
//B线程
synchronized(lock){
	lock.notify(); //从等待队列
}


//A线程
lock.lock() ;
try{
    doSomething();
    Condition.await() ;//进入等待队列
    doSomething() ;
}
finally{
    lock.unlock() ;
}
//B线程
lock.lock();
try{
    doSomething() ;
    Condition.signal() ;//从等待队列获取一个线程放入阻塞队列，这是一种延迟通知，只有等这个							线程释放锁之后才会signal一个等待队列的线程
}
finally{
    lock.unlock();
}
```

#### 并发容器

##### Queue接口

###### ArrayBlockingQueue

[参考](https://juejin.cn/post/6844903796485668872#heading-0)

````java
class Producer implements Runnable{
	BlockingQueue<Integer> que ;
	
	public Producer(BlockingQueue<Integer> q) {
		que = q ;
	}
	
	public void run() {
		for( int i=0;i<10;i++) {
			try {
				que.put(i) ;
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
class Consumer implements Runnable{
	BlockingQueue<Integer> que ;
	public Consumer(BlockingQueue<Integer> q) {
		que = q ;
	}
	@Override
	public void run() {
		for(int i=0;i<10;i++) {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			int a = 0;
			try {
				a = que.take();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			System.out.println(a) ;
		}
	}
}
public class Main { 
	
	public static void main(String[] args) throws InterruptedException {
		
		BlockingQueue<Integer> que = new ArrayBlockingQueue<Integer>(3) ;
		
		Thread producer = new Thread(new Producer(que)) ;
		producer.start();
		Thread consumer = new Thread(new Consumer(que)) ;
		consumer.start();
		
		while(producer.isAlive() || consumer.isAlive() ) {
			System.out.println( producer.getState() ) ;
			Thread.sleep(1000);
		}
	}
}
````

**ArrayBlockingQueue实现原理**

- 同一时间只有一个生产者或者消费者线程操作队列，队列使用循环队列

- 对于生产者put线程，他们互斥获得锁，操作队列，如果队列没有满，他向队列写元素，同时使用notEmpty.signal在notEmpty的条件同步队列上唤醒一个线程来读取运输；如果对了满了，那么这个生产者线程会被放到notFull.await的notFull的条件同步队列阻塞
- 对于消费者take线程，如果队列有元素，他获取元素并且使用notFull在notFull的同步队列上唤醒一个生产者线程放入元素；如果队列没有元素，他被阻塞到notFull同步队列。

##### List接口

###### CopyOnWriteArrayList

底层使用Object[] array数组来存储

增删改，使用synchronized同步，每次总是新建一个克隆数组，在克隆数组上进行增删改操作，然后把得到的新数组array=es替换到array

查操作，查操作没有锁，是在原数组array上进行查找操作。这样的好处在于实现了读写分离，读线程可以并发操作，而写线程之间必须互斥。

CopyOnWriteArrayList读写分离适合读多写少的情况，他不适合内存敏感和数据实时性敏感的情况。他的缺点

1. 因为增删改在复制数组上操作，浪费内存
2. 读取数据的时候可能发生写数据，因此读数据可能不是实时的

##### Map接口

###### ConcurrentHashMap

Java17 ConcurrentHashMap实际上就是一个HashMap，只是在增删改的时候会把对应的key的那个桶Synchronized锁起来

JDK1.7 使用segment继承ReetrantLock实现，每个segment包含HashEntry数组，以及size表示segment包含HashEntry个数，modCount表示数据结构变化次数，当要求size的时候，使用CAS来求：

- 当retries=-1，遍历所有segments求modCount的和得到last

- 当retries=0，遍历所有segments得到size的和Size，以及所有modCount的和ModCount，比较ModCount==last，如果相等就返回这个Size，认为没有进程争用

- 当retries=1，重复retries=0的操作，这样求一个size需要两次CAS操作

- 当retries=2，认为前两次都不成功，这次把所有的segments调用segment.lock()锁住，然后求size，并且返回这个size，之后记得在finally里面把所有的segment.unlock()解锁。

#### 线程池 Executer

##### Thread 类

thread.start方法执行过程：在main线程初始化时，每次new Thread()就会创建一个Thread对象，并且这个Thread对象会被加入到main线程的ThreadGroup group里，然后调用start0这个native方法啊创建线程。

#### TimeOut类

提供时间

#### 同步器

[参考资料](https://www.cnblogs.com/dolphin0520/p/3920397.html)

同步器是用来协调线程的同步的

#####  CountDownLatch

调用latch.await的main进程等待state个线程执行完latch.countDown之后执行。

**原理**

CountDownLatch初始化一个Volatile state变量，维护一个Sync extends AQS的同步队列。在每个线程里面，线程执行完成之后（某个执行完成的点调用latch.countDown将state变量-1，如果说到了一个线程让state变成0，那么就从同步队列里面唤醒一个线程到就绪队列。在主线程main里面，调用latch.await()方法，会把Thread.currentThread = main放到Sync同步队列，直到state被变成0才唤醒他。注意这里的sync同步队列和ReetrantLock里面的同步队列是不一样，ReetrantLock的同步队列是一个锁池队列，他被唤醒的进程需要去竞争锁才能进入就绪队列，而CoountDownLatch的sync同步队列不需要竞争锁，他被唤醒之后直接回到就绪队列，而且这个同步队列最多只有main线程一个线程。

CountDownLatch用来协调A线程等待state个线程BCDE等执行完成之后才开始执行，相当于线程池里面thread.join()方法，主线程调用其他线程的join方法进入无限等待状态，直到调用join的线程执行完成之后才能执行

ReetrantLock不是用来协调线程执行关系的，它主要是用来解决多进程同步访问共享变量的问题。

##### CyclicBarrier

等待N个线程执行到CyclicBarrier.await的栅栏点之后这个N个线程重新开始执行

**原理**

CyclicBarrier包含一个count记录还有多少没有到达到达栅栏点的所有线程数目，一个ReetrantLock lock用于锁池，Condition trip = lock.condition() 用于挂起和唤醒线程。

CyclicBarrier变量barrier的count=N，barrrier被初始化赋值给N个线程，每个线程执行到barrier.await到达栅栏点，开始竞争barrier.lock的ReetrantLock锁，如果竞争得到锁，count-1，判断count-1的结果是否等于0，如果为0就代表所有N个线程到达栅栏点，唤醒所有挂起的N-1个线程执行barrier之后的工作。如果cout-1!=0，就代表还有线程没到栅栏点，那么就调用trip.await()把这个线程挂起到等待队列，变成Waiting状态，等待调用trip.signalAll唤醒到阻塞队列，当线程争用到锁之后，他会从调用condition.wait的地方重新执行，这样就能统一所有的N个线程到同一个barrier。CyclicBarrir还可以重用，可以设置多个barrier

##### semaphore

CountDownLatch和CyclicBarrier都是用于协调线程运行的，CountDownLatch适合让一个线程等待其他线程执行完毕（使用join方法，使用线程池shutdown也有同样的效果），而CyclicBarrier适合多个线程相互等待到达一定的 状态后执行。此外CyclicBarrier是可以被重用的。

Semaphore是信号量，主要用于多线程对多个共享资源的访问。如果信号量的个数是1，那么就是锁机制

**信号量semaphore实现原理**

Semaphore信号量使用Unsafe类的state直接内存来保存资源个数，当一个线程使用aquir申请一个资源时，先state-1，判断剩余量是否大于0，大于0就证明能分配，线程获得信号量资源继续执行；否则就是小于0，那么就把这个线程放到Semaphore类的Sync阻塞队列，并且调用LockSupport.park的线程管理把这个线程放到等待队列（这是操作系统层面的）。当调用release的时候，会让state+1，之后把阻塞队列的中的线程谁支撑Waiting，调用LockSupport.unpark将线程唤醒。

基于Unsafe下的state变量

1. Lock类：有ReetrantLock记录锁和重用，
2. 同步器类：Semaphore记录资源数量，CountDownLatch记录还有多少个线程没有执行到latch.await命令

### 中间层

#### AQS（AbstractQueuedSynchronizer）

同步队列，底层使用双向链表实现，当线程竞争锁失败后线程被调用Unsafe.park()挂起，同时把线程状态和线程组合成Node加入同步队列保存，当线程被唤醒时从同步队列里面找到线程并且调用Unsafe.unpark()从阻塞中唤醒，并且删除这个同步队列节点。

AQS需要配合Unsafe的线程调度方法一起完成对线程的管理，相当于模拟实现了操作系统线程调度过程。

#### Automic类 原子类

### 底层

#### Volatile关键字

[参考资料](https://www.cnblogs.com/dolphin0520/p/3920373.html)

**多核计算机工作模型**

多核CPU计算机的存储器分为，寄存器、高速缓存Cache、主存（物理内存）、辅存（外存、磁盘、U盘、光盘）。

因为CPU在读写Cache的速度远大于读写主存的速度，因此，CPU工作的时候，总是先把主存的变量拷贝到Cache里面，然后对变量的操作总是在Cache里面，在某个时刻才考虑把Cache里面的数值写回到主存里面（程序执行结束，Volatile关键字变量的本地变量被修改）

这种工作模式造成的问题就是缓存一致性问题，当两个CPU共享主存变量，他们分别把主存共享变量拷贝到本地Cache，然后再本地Cache上对变量进行操作，这样可能造成他们写回到主存中的变量不是两个CPU线程执行的正确结果，也就造成了缓存一致性问题。

**CPU解决缓存一致性问题方法**

- 总线锁：CPU在使用一个共享变量的时候会使用总线锁把那个变量的总线锁住，这样其他CPU在获取那个共享变量的时候会被迫等待或者挂起，直到那个共享变量可以被使用
- 缓存一致性协议：CPU在写本地变量的时候，一方面立即写入到主存，另一方面使用总线把其他CPU的这个共享变量的缓存设置为无效，这样当其他CPU在读取Cache缓存里面的值时总是从主存里面读取更新的值覆盖缓存的值。

**Java内存模型 JMM - Java Memory Model **

Java内存模型就是为了适应多核CPU共享内存的执行情况的。Java内存模型规定所有变量保存到主存，线程有自己的工作内存，线程对数据的操作只能在自己的工作内存中，而不能在主存中，每个线程不能访问其他线程的工作内存。

**并发编程的三大特性，Java内存模型的三大特性**

- 原子性

  一组指令要么全部执行，要么都不执行

  Java内存模型只保证read苁主存中读取变量到工作内存，write把工作内存变量写到主存，lock和unlock对主存中变量加锁和释放锁等操作的原子性

  如果要实现更大范围的一组指令的原子性，可以使用synchronized或者lock包下面的锁来实现，他们使得同一时间只有一个线程或CPU执行同步代码块，保证了原子性。

- 可见性

  在多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程能够立即看到这个修改的值

  Java可以使用Volatile关键字保证可见性，Volatile修饰的变量，在修改Cache工作内存的本地变量时，实现了CPU缓存一致性协议，他会把修改的值更新到主存中，同时通过CPU总线设置其他CPU的工作内存Cache的同一共享变量的本地内存为失效，这样其他CPU在操作这个本地变量时会首先从主存中读取这个更新值

  此外，可以使用synchronized和lock锁来保证可见性，synchronized和lock保证同一时间只有一个线程CPU在执行同步代码块，并且在退出同步代码块的时候会将本地变量写回主存，这样下一个CPU执行同步代码块的时候可以读取这个更新的值

- 有序性

  代码的执行顺序和代码书写的先后顺序执行

  为了提高执行效率，编译器会对指令重排序，指令重排序不影响单线程执行指令的正确性，但是会影响多线程执行指令的正确性。

  ***

  比如A线程执行a=1, b=2；B线程执行if b==2: a+1 ; 正确结果是a=3

  如果A代码发生指令重排序使得执行顺序时b=2, a=1，那么B线程先检测到b=2然后把a+1，结果就造成a的值不能预测。

  ***

  Java内存模型保证有序性可以使用Volatile关键字，Volatile关键字保证有序性是使用内存屏障实现的，在汇编代码里，我们会看到对变量操作时会产生一个内存屏障指令，这个指令保证编译器在指令重排序的时候不会把后面的代码重排序到内存屏障前面，也不会让内存屏障前面的代码被重排序到后面

  可以使用synchronized和lock保证有序性，他们同一时间只有一个CPU执行同步代码块，而一个线程执行代码块相当于顺序执行。

**Volatile关键字功能**

- 保证可见性，通过写本地变量时写到主存，并且使用CPU总线让其他CPU的本地变量失效，从而在操作共享本地变量时从主存中重新读
- 禁止指令重排序，保证一定的有序性，通过内存屏障实现，内存屏障让他前面的代码不会被重排序到他后面，他后面的代码不会被重排序到他前面

**实现原子性i+1**

volatile不能实现原子性，但是可以保证可见性

实现原子性可以使用synchronized（底层操作MarkWord），lock（ReetrantLock底层使用unsafe类的CAS机制操作直接内存），原子类型AtomicInteger（底层使用unsafe类CAS机制操作直接内存）

#### Unsafe类

Unsafe类是一个操作直接内存（堆外内存）的底层类，它可以完成所有对内存的操作，比如分配数组、分配对象、清理对象等，Unsafe类是一个单例

JUC使用了Unsafe类的两个特性

- 线程调度，unsafe可以使用park()和unpark()方法挂起或者唤醒一个线程
- 乐观锁CAS，比较替换，unsafe的CAS方法是一个原子操作，他直接使用CPU的cmpxchng原语实现变量的比较替换



## Java基础

[Java SE8 ](https://docs.oracle.com/javase/specs/index.html) [JDK 8](https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf)  [JVM8](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf)

### Java执行过程

1. 将Java代码编译成class字节码

   字节码格式：

   类描述信息

   access_flag：public、interface、abstract

   this.class引用在常量池中，表示类名；super.class引用在常量池中，表示继承类名

   Interface表 表示实现的接口

   常量池，保存字面值和符号引用

   字段表，保存静态变量和实例变量

   方法表，保存方法代码（包括参数，返回值；access_flag；JVM指令集代码；方法相对原代码的偏移；本地变量表）

2. JVM启动一个Main线程，加载包含Main方法的类

   将二进制字节流加载到方法区，并且创建一个Java.Lang.Class对象，作为外部访问方法去类类型的接口

   数组类型不会加载，JVM直接给他分配内存，但是数组中元素的类型需要被加载。

   **不同的类会用不同的加载Loader来加载，主要有三种**

   1. Bootstrap Loader，负责加载Java Liberary的类，在<JAVA_HOME>\lib目录下的类
   2. Extension Loader，负责加载扩充的类，在<JAVA_HOME>\lib\ext目录下的类
   3. Application Loader，负责加载用户自己写的类，在-classpath目录下的类

   **加载的双亲委派机制**

   除Bootstrap Loader以外，任何一个加载类都必须属于一个父类，这种属于是一种组合关系

   加载的时候，子类首先调用父类来加载对应的类，如果父类加载不了（加载器在他的加载目录下找不到这个类），再用子类来加载

   **双亲委派机制的好处**

   保证加载的优先顺序，这样同样一个名字的类，优先加载父类加载器可以加载的类

3. JVM的Main线程验证

   检查类信息是否符合JVM规范，保证JVM运行安全

4. JVM的Main线程准备

   准备阶段为类的静态变量分配内存并且初始化，这里的静态变量保存在方法区，实际上可能是在方法区的堆上（方法去时JVM的概念，而永久代和元空间是实现方法区的两种方式。永久代有大小限制，可以使用-Xms PermMaxSize 等设置大小，而元空间是建立在堆上，理论上的限制是内存大小，使用元空间的好处是减少产生方法区内存溢出）

5. JVM的Main线程解析

   解析阶段将符号引用替换成直接引用，直接引用是指向目标的指针、偏移量或者标记目标的句柄。直接引用是跟内存相关的，意味着在内存中分配内存存储。解析具体分为类符号应用解析、字段符号引用解析、方法符号引用解析、接口符号引用解析。如果解析成功，成功返回直接引用，那么还要进行权限检查，查看类A是否对类C的直接应用具有访问控制权限。

6. JVM的Main线程初始化

   这个初始化是对类静态变量的初始化，这个初始化时JVM按序收集父类的对静态变量的赋值语句产生clinit方法和按序收集子类的静态变量的赋值语句产生clinit方法完成的，首先执行父类的clinit方法，其次执行子类的clinit方法。这个初始化不是new实例时对实例变量的初始化，而是类加载过程中的初始化静态变量

7. JVM的Main线程加载到主类之后，建立主类Main方法的Frame，设置本地变量表、程序计数器、常量池引用。开始执行Main方法。

   ```java
   // 执行循环过程
   int i ;
   for( i=0;i<100;i++){
   
   }
   被编译成
   localVariable this(reference,1 slot),i(int 1 slot)
   code :
   	0. iconst_0 ; //将0压入操作栈
   	1. istore_1 ; //将操作栈中的数送回本地变量表，两个指令给i赋值 i=0
   	2. goto #7 ;
   	
   	3. 	iload_1 ;
   	4.	iconst_1 ;
   	5.	iadd ;
   	6.	istore_1 ; //上面四个指令执行i++
   		
   	7.	iload_1 ; //将1号int本地变量数值压入操作栈
   	8.	bipush 100; //100 压入操作栈
   	9.	ifcmplt #3 ;// 上面三个指令执行判断i<100
   	
   		
   //执行类初始化过程
   A a = new A() ;
   被编译成
   new #19 ; //创建对象A，过程是首先检查类A是否被加载，如果没有加载，就把A类交给对应的ApplicationLoader进行加载。加载过程
   		  //是加载（将二进制字节码加载到方法区，并创建一个java.lang.class对象的实例作为在方法区获得这个类）；验证（检查
   		  //类信息是否负荷JVM规范，保证JVM安全；准备（给静态字段创建内存并初始化为默认值，如果是static final直接初始化为
   		  //字面值）；解析（替换常量池的符号引用为直接引用，也就是分配内存，把内存引用赋值给对应的常量，解析完成之后会进行权		  //限检查，查看对应的字段、方法等是否可以被调用）；初始化（这里的初始化时静态字段的初始化，初始化方法是JVM获取对静		   //态字段的赋值语句建立的clinit方法，父类也有这个方法，首先初始化父类的静态字段，然后初始化子类的静态变量
   		  
   		  //上面的类加载完成之后，会在堆上分配内存，建立A的实例，这个堆上的实例保存有三个部分，A的对象头-包括A的类类型的
   		  //引用，实例的锁等；A的实例变量；A的对齐补充。这样在堆上我们建立了A的实例变量的内存。之后这个对象的引用会被返回给
   		  //a所在的方法的frame的操作栈上
   dup  ;    //将栈帧的操作栈的第一个元素duplicate
   invocateSpecial #20; //调用A方法的初始化方法进行初始化，注意这个初始化方法会调用父类的（Object类）的初始化方法进行初始化
   					 
   
   //执行函数调用
   public class A{
   	Integer a = 10 ;
   	
   	public void set(int a){
   		this.a = a ;
   	}
   	public static void main(String[] args){
   		A a = new A() ;
   		
   		a.set(10) ;
   	}
   }
   被编译成
   public void set(int a)
   describer: (int)V
   local variable: this(指向对象在堆中的引用);int a ;
   code :
   	aload_0 ;
   	iload_1 ; //加载1号int本地变量
   	invokeStatic #1 ; //调用Integer.valueOf()将int数字转换成Integer类型并且返回Integer在Integer常量池的引用
   	
   	putfield #2 ; //将在堆上的A的实例变量的a字段赋值为Integer的引用
   	return 
   public static void main(String[] args)
   describer: ([Ljava.lang.String)V
   local variable : [Ljava.lang.String ; A a ;
   code :
   	new #3 ;  //new A，创建A的实例
   	dup ; 
   	invokeSpecial #4; //执行A的初始化函数
   	astore_1 ; 保存A的实例引用到一号本地变量
   	
   	aload_1 ;
   	bipush 10 ;
   	invokeVirtual #5 ;// 调用set方法
   	
   访问静态变量，静态变量在方法区分配内存，在准备阶段就被分配内存并且初始化
   getstatic #12 ;//读取静态变量的引用
   invokevirtual #14;//调用Integer.inValue()将这个引用获取int
   
   iconst_1 ;
   invokevirtual #14; //调用Integer.valueOf()将int转换成Integer并压入引用
   putstatic #12 ;// 写入静态变量
                     
   访问实例变量，实例变量在堆上分配内存，要使用new关键字创建对象的时候才会在堆上分配内存，之后调用初始化函数初始化。
   aload_0 ;
   getfiled #12 ;
                     
   aload_0 ;
   iconst_1 ;
   putfield #12 ;
   ```

### JVM内存结构 Java内存模型

#### JVM 内存结构

1. 方法区：代码，常量池（字面值，符号引用）
2. 堆：创建对象分配内存（对象头、实例变量、对齐）、数组
3. 程序计数器PC：线程私有，指向执行代码的位置
4. 虚拟机栈：线程私有，为Java方法执行服务。一个方法建立一个Frame，一个Frame包括操作栈（用于数字运算、程序调用传递参数、赋值传递参数）、本地变量表（Compile阶段产生）、运行时常量池的引用（用于动态生成对常量池中的引用）
5. 本地方法栈：线程私有，用于执行本地方法（C++等）编写的方法

#### Java内存模型

多个线程共享主存，每个线程私有工作内存，线程主要操作的是自己的工作内存，完成之后才送到主存，线程之间不能获得内存，线程操作主存依赖一组原子操作，比如read、write

这里的内存和JVM内存结构完全不是一回事，非要对应，也是主存代表堆上的实例变量，而线程工作内存代表虚拟机栈。

Java内存模型划分主存和工作内存的原因是可以利用高速缓存加速线程的计算，而减少访问内存的操作。

在Java中，主存表示方法区的静态变量和堆区的实例变量，工作内存表示线程的虚拟机栈，主存和工作内存使用getstatic，putstatic读写方法区的静态变量，使用getfield和putfield读写实例变量，读到的实例变量数据会被放到当前栈帧的操作栈上，可以通过本地变量栈和栈帧修改数值之后putfield或者putstatic到实例变量或者静态变量。

### Java数据类型

 

|               | byte(1byte) | short(2bytes)              | int(4bytes)   | long(8bytes)   |      |
| ------------- | ----------- | -------------------------- | ------------- | -------------- | ---- |
|               |             | char(2bytes) unicode16字符 |               |                |      |
| boolean(1bit) |             |                            | float(4bytes) | double(8bytes) |      |
|               |             |                            |               |                |      |

#### 引用类型

[引用类型](https://juejin.cn/post/6884507434036133901)

引用类型保存对象在内存的首地址

**四种引用类型**

根据跟GC的关系划分4个引用类型

1. 强引用：使用new创建对象返回的是对象内存首地址，这个是强引用
2. 软引用：使用SoftReference将强引用转换成软引用，软引用对象会在内存不足时被GC
3. 弱引用：使用WeakReference将其他引用转换成弱引用，弱引用对象在下一次GC时会被回收
4. 虚引用：使用PhantonReference转换，虚引用对象不能被使用，他的意义在于对象被回收会向系统发送提示

#### 类型常量池

每个类都有对应的常量表，可以存储缓存

**Integer.valueOf(12)和new Integer(12)区别**

前者是在Ineger缓存池查看是否有12Interger的缓存，如果有，返回缓存的引用，如果没有，则创建新的Integer返回引用

后者直接在堆上常见Integer累心并返回引用

#### 字符串String不可变

[为什么字符串String不可变](https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/)

String不可变底层是用final byte[]数组实现

所有的String都是final的，可以使用intern将String加入字符串常量池

1. 缓存HashCode，不可变字符串只需要在调用HashCode的时候一次计算缓存就行，计算HashCode方法是31*h+(v&0xff)

2. 字符串常量池的要求，从常量池返回一个字符串引用就设置了这个变量的字符串数值，如果这个位置可变，那么就会改变这个数值。
3. 安全性，String经常被当成参数传递，比如网络环境，设置final可以保证安全
4. 线程安全，final的对象是线程安全的

**String、StringBuilder、StringBuffer**

是否可变长：String因为final数组，是不可变的；String Builder和StringBuffer都是使用byte[]，是可变的

线程安全：StringBuffer和StringBuilder都继承了AbstractStringBuilder，只是StringBuffer使用synchronized加锁增删改方法实现同步；而String因为final数组是线程安全的

**字符串常量池**

字符串常量池是在编译时期创建的静态常量池，在加载的解析阶段分配内存创建。字面值会被保存在常量池中，并且编译时会将字面值相同的变量指向常量池中的同一个对象。

使用字符串常量池和基本类型缓存不一样，String.valueOf(byte[])不会检查常量池，而是直接创建对应的String，当然可以使用intern将这个新的String加入到常量池；而使用Integer.valueOf(123)会检查Integer的缓存，如果没有就创建新值在堆上，如果有就返回Integer缓存引用，IntegerCache是Integer的静态内部类，他在初始化准备阶段就分配好Cache的数组内存并且在初始化的时候创建了[-128,127]之间的数字的Integer对象。Integer缓存的数字范围是[-128,127]

字符串常量池在堆上分配内存，因为要保证字符串太大方法区容不下。

#### 参数传递

[参数传递](https://www.cnblogs.com/wkfvawl/p/10539084.html)

Java只有按值传递，传引用类型也是传递的一个引用类型的拷贝，只是这个拷贝指向相同对象

C++有三种参数传递方式传值、传指针、传引用

实际上传指针也是传值，因为形参是实参的拷贝，他们指向相同的内存对象

传引用要求的是将实参传递，形参和实参是同一个对象，改变形参也就改变实参

#### 关键字

##### final

final基本类型，这个变量在被初始化之后不能改变

final引用类型，这个变量在初始化指向一个对象后就不能指向其他对象，只能指向这一个对象，但是不影响修改这个对象

final方法，方法不能被重写

final类，类不能被继承

##### static

static字段，这个变量是类相关的变量，静态变量，与对象无关的变量，在加载的准备阶段分配内存初始化为默认值、在初始化阶段被JVM生成的clinit方法初始化为字面值

static方法，这个方法是静态方法，他只能访问类中的静态字段和静态方法，调用这个静态方法不需要实例，直接类名.方法名就可以调用。Main方法被设置为static，因为需要一个程序执行接口，而非static变量依赖实例，而创建实例就依赖进入接口，这是一个先有鸡还是先有蛋的问题。static方法必须是实现了的，不能是虚方法

static内部类，普通内部类的创建依赖外部类的创建，而静态内部类不需要。静态内部类只能访问外部类的静态方法和成员

static语句块，静态语句块，静态语句块只能执行一次，是在类加载阶段初始化时候被JVM联合静态变量、静态语句块收集赋值操作组成clinit方法执行初始化使用的。他只能在类加载阶段使用一次

##### super

访问父类构造函数super(1,2,3)

访问父类成员函数super().A() ;

#### 对象创建初始化

在加载类阶段对静态变量的初始化，这是JVM自动收集静态变量和静态代码块的赋值操作完成的

父类（静态变量、静态代码块）

子类（静态变量、静态代码块）

在实例化时的初始化，在compile阶段会把普通变量赋值添加到一个init初始化函数，实例化的初始化是对实例变量的创建和初始化，实际上在编译阶段会把实例变量赋值、普通代码块实例变量赋值和构造方法赋值一起创建一个构造init方法，在这个方法中，实例变量赋值和普通代码块赋值在构造方法之前

父类（实例变量赋值、普通代码块）

父类（构造方法）

子类（实例变量赋值、普通代码块）

子类（构造方法）

#### Object类方法

##### equals

equals满足等价性的五个条件

1. 自反性，自己等于自己 x.equals(x) 为true
2. 对称性，x.equals(y)和y.equals(x)结果相同
3. 传递性，x.equals(y) y.equals(z) 则x.equals(z)
4. 一致性，多次比较结果不变x.equals(y)多次执行结果不变
5. 与null比较为false，因为obj不为空

**等价的判断**

x==y比较的是引用，是内存地址是否相同，是否是同一个对象

x.equals(y)，比较的是内容是否一样

**重写equals**

判断是否同一个对象x==y，不是就false

判断为空或者不为同一个类型，false；y==null ||getClass() !=y.getClass() ;

y转型为x的类型

比较x和y的每个变量

##### hashCode

重写equals就必须重写hashCode，以保证同一个变量hash值相等

在HashSet和HashMap等依赖hashCode的集合类，必须重写equals和hashCode

如果只是重写equals，可能hashCode不一样，那么相等的对象被分到两个桶

如果只是重写hashCode不重写equals，相同对象在同一个桶中有两个实例

**重写hashCode**

result=17

result =  result*31+this.x ; (this.x只对基本数据类型，对byte需要this.x&0xff，对引用类型this.x.hashCode() )

result = result*31 + this.y ;

##### tostring

##### clone

深拷贝，重新建立一个对象和被拷贝的对象相同，并且拷贝的变量指向这个新创建的对象

浅拷贝，只拷贝引用类型的值，这样拷贝的变量和原来的应用类型变量指向同一个对象

#### 访问控制符

public protected private

#### 抽象类和接口

抽象类可以被继承，而接口只能实现

抽象类只能单继承，接口可以有多个实现

抽象类可以实现方法，接口都是抽象方法，不能实现

接口字段默认public static final，方法默认public，而抽象类没限制。

#### 重写与重载

重写是把父类的方法重写，参数、方法名相同

重载是方法名相同，但是参数或参数顺序不同

#### 反射

反射用来提供运行时类信息，包括三个类

Filed类，可以通过get和set方法动态改变字段值

Method类，可以通过invoke方法类方法

Constructor类，可以通过newInstance方法重建类对象

**反射优点**

1. 可扩展性：可以通过全限定名创建对象
2. 类浏览器和可视化开发环境，可以动态加载类的成员信息
3. 方便调试和测试

**反射缺点**

性能开销，降低性能

安全性约束，反射要运行在没有安全约束条件

内部暴力，允许访问私有成员等操作

#### 异常

异常是指令错误产生的，比如除0

中断不是CPU执行指令产生的，是系统其他部分发出的，比如IO

#### 泛型

#### 反射

## Java多线程

多线程是用来并发执行程序，加快速度的一种方案，其次是一种开展多任务的方案

### 线程状态

1. 新建，使用new Thread创建一个新线程
2. Runnable，可运行态，是线程要不再就绪，要不在执行
3. 无限期等待，线程调用没有Timeout设置的wait（等待notify或notifyall）或者join方法
4. 限期等待，线程调用有时间设置的Timeout的wait或者join方法
5. 阻塞，线程等待获取锁，或者Thread.sleep()方法
6. 死亡，线程执行结束

**线程状态**

[七状态模型](https://www.jianshu.com/p/ea9821e4cd24)

[参考](https://blog.csdn.net/weixin_43808717/article/details/115351888)

[参考](https://blog.csdn.net/pange1991/article/details/53860651)

[参考](https://blog.csdn.net/coding_1994/article/details/80634792)

[参考](https://www.jianshu.com/p/b8df805825b5?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)

![img](https://images2018.cnblogs.com/blog/137084/201804/137084-20180421113325399-1759953729.jpg)

1. 新建态（New），使用new得到的
2. 就绪态（Ready），被放到就绪队列
   - 新建态调用start方法进入就绪态
   - 执行态调用Thread.yeild方法立即释放CPU进入就绪态，此过程Thread不释放锁。或者执行态时间片用完进入就绪态
   - 阻塞态的线程在锁池队列（同步队列），竞争到对象锁之后进入就绪态
   - 有限等待状态的线程Thread.sleep(10)时间结束，或者用户输入结束，或者object.join(10)执行object时间10毫秒结束，进入就绪态，进入就绪队列
   - 调用LockSupport.park处于无限等待状态的线程被LockSupport.unpark唤醒回到就就绪队列
3. 执行态（Running），线程调度执行得到。
   - 就绪态被CPU调度变成执行态，从就绪队列中获取线程
4. 计时等待（Timed_waiting)，
   - 执行态执行Thread.sleep(10)，thread.join(10)，lock.wait(10)执行用户输入等会让线程进入计时等待
5. 无限等待（Waiting）
   - 执行态执行thread.join()，调用lock.wait()，调用LockSupport.park()等方法，使用lock.wait之前一定获得锁，使用时会释放锁，使LockSupport.park可以不获得锁
6. 阻塞状态（Blocked）
   - 执行态争用锁lock失败直接进入锁池队列（同步队列），进入阻塞状态
   - 因为调用lock.wait（计时等待或者无限等待）, Condition.await()，被lock.nofify, lock.notifyAll 或者Condition.signal(), Condition.signalAll() 从等待队列里面释放进入同步队列（锁池），同时进入阻塞状态。使用lock.notify唤醒线程选择是任意的，可以自己实现定义哪种方法（FIFO，随机）
7. 死亡状态（Terminated）
   - run方法结束，main方法结束，或者发生异常终止

### 线程创建

1. 继承Thread

2. 实现Runnable接口

3. 实现Callable接口

4. 线程池

   **线程池工作流程**

   [线程池](https://www.cnblogs.com/qlqwjy/p/9470414.html)

   [线程池](https://blog.csdn.net/saibeidehuangyan/article/details/122294753)

   1. 核心线程数没有满，就创建线程获取任务执行
   2. 如果核心线程数满，尝试将任务加入工作队列
   3. 如果不能成功加入工作队列，说明工作队列满了，尝试建立新线程
   4. 如果不能成功建立新线程，那么说明达到最大线程数，执行拒绝策略

   **拒绝策略**

   1. Abort，直接抛出异常
   2. CallerRuns，返回主线程处理
   3. DiscardOldest，抛弃工作队列最久的任务
   4. Discard，抛弃当前任务

   **线程池参数**

   核心线程数, corePoolSize

   总线程最大数，maximunPoolSize

   keepAliveTime，空闲线程存活时间

   Timeunit 时间单位

   BlockingQueue，工作队列的实例

```java
//
////创建多线程的四种方式
////1. 继承Thread,继承Thread创建的多线程没有共享数据，因此不存在同步问题
//class MyThread extends Thread{
//	
//	@Override
//	public void run() {
//		for( int i=0;i<10;i++) {
//			System.out.println(Thread.currentThread().getName()+": "+i) ;
//		}
//	}
//}

//2. 实现Runnable接口
//实现Runnable接口创建线程可以共享变量，这样就需要实现同步
//2.1 线程代码相同，实现共享变量，只需要传入相同的Runnable实例到Thread实例
class MyThreadRunnable implements Runnable{
	public static int a=0 ;
	@Override
    public void run() {  
        synchronized(this) {  //synchronized需要传递一个引用来作为互斥量，这里使用类对象的this引用来作为互斥量
//             for (int i = 0; i < 5; i++) {  
//                  System.out.println(Thread.currentThread().getName() + " synchronized loop " + i);  
//             }  
        	a++ ;
        	a++ ;
        	System.out.println(Thread.currentThread().getName() + ": " + a ) ;
//        	a=a+1 ;
        }  
   }  
}

////2.2 多线程的代码不一样
//class Data{
//	int i =0 ;
//	
//	public void inc() {
//		i++ ;
//	}
//	public void dec() {
//		i-- ;
//	}
//	public int get() {
//		return i ;
//	}
//}
//class MyThreadRunnableInc implements Runnable{
//	Data data ;
//	
//	MyThreadRunnableInc(Data d){
//		this.data = d ;
//	}
//	
//	@Override
//	public void run() {
//		synchronized(data) {
//			this.data.inc();
//		}
//	}
//}
//class MyThreadRunnableDec implements Runnable{
//	Data data ;
//	MyThreadRunnableDec(Data d){
//		this.data = d ;
//	}
//	
//	@Override
//	public void run() {
//		synchronized(data) {
//			this.data.dec();
//		}
//	}
//}


class MyThread implements Runnable{
	int x ;
	public MyThread(int i) {
		this.x = i ;
	}
	
	@Override
	public void run() {
		for( int i=0;i<3;i++) {
			System.out.println(Thread.currentThread().getName() + " : "+ x+ " : "+i) ;
		}
	}
}

public class Main { 
	
	public static void main(String[] args) throws Throwable { 
		
//		int num = 3 ;
//		Thread[] t = new MyThread[num] ;
//		for( int i=0;i<num ;i++) {
//			t[i] = new MyThread() ;
//			
//			t[i].start();
//		}
		
//		String a = "123" ;
//		String b = "123" ;
		
		
		
//		MyThreadRunnable a = new MyThreadRunnable() ;
//		int num=3 ;
//		Thread[] t= new Thread[num] ;
//		for( int i=0;i<num;i++) {
//			t[i] = new Thread( a ) ;
//			t[i].start() ;
//		}
//		
//		for( int i=0;i<num;i++) {
//			t[i].join() ;
//			System.out.println("end: " + i);
//		}//使用join等待所有线程结束
//		System.out.println(a.a) ;
		
//		Data a = new Data() ;
//		int num=3 ;
//		Thread[] t= new Thread[num] ;
//		for( int i=0;i<num/2;i++) {
//			t[i] = new Thread(new MyThreadRunnableInc(a)) ;
//			t[i].start() ;
//		}
//		
//		for( int i=num/2;i<num;i++) {
//			t[i] = new Thread(new MyThreadRunnableDec(a)) ;
//			t[i].start() ;
//		}
//		
//		for( int i=0;i<num;i++) {
//			t[i].join() ;
//			System.out.println("end: " + i);
//		}//使用join等待所有线程结束
//		System.out.println(a.get()) ;		
		
        
		ExecutorService executor = new ThreadPoolExecutor(3, 5, 1, TimeUnit.SECONDS, new ArrayBlockingQueue(4) ) ;
		
		for( int i=0;i<6;i++) {
			executor.execute(new MyThread(i) ) ;
		}
		
		executor.shutdown();
	}
}
```

### 线程协作

使用wait notify，等待和唤醒线程

使用join等待另外线程结束

### 线程安全

#### 不可变

使用final让数组和对象不可变

String，BigInteger使用final实现线程安全

#### 无同步方案

线程不共享变量

一种是线程就没有共享的变量

一种是ThreadLocal，ThreadLocal使用了是在方法区的，使用了一个Map<currentThread.getName, Map>来保存各自的数据，使用ThreadLocal可以用来传递一个线程调用多个方法时传递上下文，类似于参数传递

#### 线程同步

线程共享变量保证共享变量安全性的方案

##### 阻塞同步，锁

synchronized和Reentrantlock

synchronized方法是用Acc_synchronized同步

synchronized代码块使用moniterenter和moniterexit同步

synchronized是JVM实现的同步方案，Reentrantlock是JDK实现的同步方案

##### 非阻塞同步

1. CAS compare and set

   包括内存地址V，expectedValue A和新值B，开始读取内存地址V保存到A，修改成新值B，到要写入的时候，重新读入内存地址V，和A比较，如果没有发生变化，那么就说明没有线程与他争用共享变量，之后写入B

2. AutomicInteger原子类型使用CAS来同步

### 锁优化

锁优化是对synchronized关键字进行的优化

#### 自旋锁

锁被占用，线程忙循环一段时间后获取锁而不是立即阻塞

#### 锁升级

1. 无锁，锁对象markword设置无锁

2. 偏向锁

   偏向锁让获取这个锁的线程在之后获取这个锁的时候不需要进行同步操作

   线程在获取锁对象之后，设置markword为偏向状态，并用CAS把自己的线程ID写入markword，之后线程访问锁的代码块不需要同步操作

   当另外一个线程试图获得锁时，偏向状态结束，锁对象回到无锁或者轻量级锁状态

3. 轻量级锁

   锁对象的锁状态是无锁是，线程在自己的虚拟机栈上创建一个LockRecord，并使用CAS修改锁对象的Markword为LockRecord的指针，如果CAS失败，虚拟机检查MarkWord是否已经是指向LockRecord的指针，如果是，代表线程已经获得锁，那就可以访问同步块，如果不是，那就是有线程占用了这个锁。轻量级锁不适合两个线程以上同步。

4. 重锁synchronized

   线程无法获得锁对象就阻塞等待，这种阻塞等待需要切换到操作系统线程，是非常耗时的

### Java内存模型

线程共享主内存，每个线程有自己的工作内存，线程之间不能访问工作内存，主内存和工作内存使用原子操作交互

1. read，从主内存读取变量值放到工作内存
2. load，把工作内存变量值放到本地变量副本
3. use，把工作内存变量值放到执行引擎执行
4. assign，把执行引擎返回值放到共工作内存
5. store，把工作内存变量放到主存
6. write，把主存内的变量值写入变量
7. lock和unlock对主存变量加减锁

#### Java内存模型三大特性

1. 原子性，内存模型保证read，load，use，assign，store，write，lock和unlock原子性

2. 可见性，可见性指的是线程修改变量值需要让其他线程知道这个修改。Java实现可见性是当线程修改本地变量值的时候就刷新到主存，当线程要读取本地变量的时候就从主存读取数据。

   实现可见性：

   1. volitle关键字：他保证可见性，同时禁止指令重排序（通过内存屏障防止内存屏障后面的代码被重排序到前面）。Volatile不能保证线程安全，因为他只能保证可见性，不能保证操作原子性。但是可以使用while循环检查volatile关键字变量来实现同步
   2. synchronized：在执行对变量unlock之前，把修改值写入主存
   3. final关键字：只要完成对final变量的初始化并且没有发生this逃逸（其他线程在线程初始化的时候访问了this对象，修改了final的值），那么final变量对所有线程可见

3. 有序性

   有序性是在本线程观察，所有操作都是有序的。但是这种有序在其他线程看来，可能是无序的，因为发生了指令重排序。

   要保证有序性有两种实现

   1. volatile关键字，通过内存屏障保证有序性
   2. 使用synchronized保证执行代码有序性

### 其他

#### 中断

主线程调用线程的interrupt方法可以中断线程，这种中断对线程处于阻塞、限期等待和无限等待状态，可以产生一个InterruptedException异常，从而中断线程。但是这种中断不能处理处于IO阻塞和synchronized锁阻塞的的线程。这个时候因为interrupt会修改线程状态标志Interrupted，所以可以通过使用Intterrupted方法检测是否发生了中断从而进行中断处理。

#### 守护线程

一个线程被设置为守护线程，他会在非守护线程结束之后随时结束

## Java 虚拟机

### 垃圾收集

#### 判断对象是否可以被回收

1. 引用计数

   给每个对象记录引用个数，如果引用为0就代表可以被回收

2. 可达性分析

   根据GC Root建立引用图，不在引用图上的是可以被回收的对象

   **可以被当成GC Root的对象**

   1. 虚拟机栈中本地变量表的引用
   2. 本地方法栈中JNI的引用对象
   3. 方法区中静态属性引用的对象
   4. 方法区中常量引用对象

#### 方法区的回收

主要是常量池的回收和类的卸载（避免反射和动态代理创建过多的类而造成方法区溢出）

类的卸载必须满足三个条件

1. 堆里没有类及其子类的实例
2. 加载这个类的ClassLoader被回收
3. 这个类的java.lang.Class对象没有在任何地方被引用，也就在任何地方无法通过反射访问这个类方法

### 垃圾回收算法

#### 标记清除

CMS（concurrent mark sweep）等采用标记清除

首先标记要被清除的对象，然后清除他们。回收的块会被添加到空闲链表，每次分配内存时从空闲链表获得满足对象大小的块分配内存，然后把block-size的块返回给空闲链表

不足：

- 标记和清除效率不高
- 会产生外部碎片

#### 标记整理

把所有存活的对象移动到内存一边，然后清除边界以外的对象

优点：

- 不产生外部碎片

缺点：

- 需要移动大量对象，效率低

#### 标记复制

把内存分为两个部分，一部分分配内存，一部分不用，回收时将存活的对象复制到不用的内存，然后回收用过的内存

标记复制一般用于Minor GC，回收新生代，新生代分为Eden区和两个小的Survivor区，每次分配空间总是在Eden区和一个Survivor区分配，回收时将存活对象复制到不用的Survivor区。这其中可能发生Survivor区不够情况，就需要老年区来分配这个内存，实现空间分配担保

HostSpot虚拟机默认Eden：Survivor=8：1

缺点：

- 浪费一般内存不用

### 垃圾收集器

#### 新生代 Minor GC

##### Serial

串行垃圾收集器，客户端默认新生代默认垃圾收集器（客户端关注内存大小，Serial效率能接受）

##### ParNew

Serial多线程版本，服务端默认新生代垃圾收集器，可以和CMS配合使用

##### Parallel Scavenge

多线程垃圾收集器

在达到可控制的吞吐量的目标时尽可能缩短垃圾回收时停顿时间，时吞吐量优先收集器

吞吐量是执行执行用户代码时间/(执行用户代码时间+执行垃圾回收时间)，高吞吐量可以提高CPU利用率，缩短运行时间，适合不需要交互的应用；延迟是收集器Stop the World执行的时间，延迟越短，则客户服务质量越好，适合用户交互的程序，但是会增加整个运行时间。

缩短停顿时间（延迟）是靠牺牲吞吐量和新生代内存空间实现的，小的新生代空间会触发更频繁的垃圾回收，导致吞吐量下降。

Parallel Scavenge可以自动调节新生代大小、Eden和Survivor比例、晋升到老年代年龄

#### 老年代 Major GC

##### CMS

Concurrent Mark Sweep，使用标记清除算法，哟四个流程

1. 初始标记：仅仅标记GC Root引用的对象，有停顿
2. 并发标记：根据GC Root进行可达性分析过程，和用户线程并发执行，不需要停顿
3. 重复标记：标记因为并发标记时用户线程产生的新的垃圾对象，需要停顿
4. 并发清除：和用户程序并发，清除垃圾

缺点：

- 吞吐量低，并发标记和并发清除占用CPU
- 没办法处理浮动垃圾，并发清除时用户线程在运行会产生新的垃圾，这必须等到下一次GC时才能处理
- 并发时用户线程在申请新的内存，意味着CMS不能等到老年代快满的时候收集，必须留一部分空间。而预留的空间可能不够新对象分配，造成并发失败
- 标记清除算法产生外部碎片，造成老年代还有空内存的时候因为不能给大对象分配内存而引发Full GC

##### Serial Old

Serial老年代版本，适合客户端

在服务端，主要作为CMS收集器并发失败后的后备方案

##### Parallel Old

Parallel Scavenge的老年代版本

在注重吞吐量和CPU资源的场合，可以优先考虑Parallel Scavenge+Parallel Old收集器组合

#### Mixed GC

##### G1

面向服务端的垃圾收集器，在多CPU和大内存场景有很好的性能，CMS的替代

G1将内存划分为小的内存Region，每个Region可以作为Eden、Survivor或老年代，根据经验设置每个Region回收时间和获得的内存，并维护一个优先列表，根据允许的收集时间，优先回收价值大（回收内存多）的Region，这样实现了一个停顿模型

每个Region保存一个RemenberedSet保存这个Region引用对象所在的Region，这样在做可达性分析的时候可以避免全堆扫描

特点：

- 空间整合：整体上看是基于标记整理算法实现的，但从局部看是基于复制算法实现的，意味着不会产生外部碎片
- 可控制的停顿时间：让GC时间不超过使用者设定的时间内。

##### Shenanwoah

##### ZGC

#### Full GC

在新生代和老生代都可以GC

### 内存分配策略

1. 优先在Eden区分配，当Eden区不够时发生MinorGC
2. 大对象进入老年代，比如长字符串和大数组，这样避免大对象快速沾满Eden区发生MinorGC频繁发生Eden和Survivor之间的复制
3. 长期存活对象进入老年区，增加对象年龄计数器，每熬过一次GC就加一，默认15次就复制到老年代
4. 动态对象年龄判定，如果Survivor区具有相同年龄的对象占一半内存，就把年龄大于等于这个年龄的对象复制到老年区
5. 空间分配担保，当进行MinorGC之前，检查老年代最大连续空间是否可以容纳所有新生代对象的总空间，如果时，则进行MinorGC；如果不是，检查是否可以HandlePromotionFailure=True，如果是，检查老年代最大可用空间是否大于历次Promotion的平均对象的平均大小，如果是，则进行一次冒险的MinorGC；如果不是或者HandlePromotionFailure=False，那么进行一次FullGC

### GC触发条件

#### MinorGC

当Eden区满时触发

#### MajorGC

Serial Old、Parallel Old在老年代满时

CMS在达到设定的大小时

#### FullGC

1. 调用system.gc()，并不会立即FullGC
2. 老年代空间不足，在大对象和长期存活对象进入老年代引发。可以设置Xmn调大虚拟机新生代或者调大XX：MaxTenuringThreshold调大进入老年代年龄，让对象躲在新生代存活一段时间。同时避免创建过大对象和数组
3. 空间分配担保失败，整理到Survivor的对象内存不足要移动到老年代但是老年代最大连续内存不能分配
4. JDK1.7之前永久代空间不足，那是永久代是固定内存，在反射和动态代理创建类的时候可能内存不足
5. Concurrent Mode Failure，并发失败，在CMS时并发的用户线程在创建对象使得内存不足



1. springboot自动装配

2. 为什么JAVA要进行GC

3. 怎么判断一个垃圾（垃圾回收机制）

4. 讲讲volatile，JMM，垃圾回收过程，字节码角度解释return i++，mysql的事务原理

5. Hashmap的原理，增删的情况后端数据结构如何位移
   hashmap容量为什么是2的幂次
   hashset的源码
   object类你知道的方法
   hashcode和equals
   你重写过hashcode和equals么，要注意什么
   假设现在一个学生类，有学号和姓名，我现在hashcode方法重写的时候，只将学号参与计算，会出现什么情况？
   往set里面put一个学生对象，然后将这个学生对象的学号改了，再put进去，可以放进set么？并讲出为什么

6. Java的内存模型，垃圾回收

7. Spring的aop有哪些实现方式

8. 指针和引用的区别

9. JAVA的ArrayList分配内存机制

10. volatile关键字的作用

11. java多线程实现方法

12. 5 Jvm垃圾回收， 垃圾回收算法

13. HashMap线程安全吗？如何线程安全（答了ConCurrentHashMap，后来还根据这个出了一道场景题，具体内容忘了）

14.  string和stringbuffer的区别？

15. 抽象类和接口的区别？

16. 如何遍历list？

17. 问了问spring中的AOP和IOC

18. 方法重载和重写的区别？

19. 说说Java面向对象的特征及理解？**（多态说的不好）**

20. JVM内存结构？JMM内存模型

21. 堆和栈有什么区别

22. 垃圾回收GC在哪？JVM垃圾回收过程？

23.  **怎样查看GC调用频率，或者说怎么样针对GC执行进行堆内存调优？** 

     答：（重点来了）打了打印GC日志，或者使用Java自带的Jstat内存监视工具，或者可以下载dump文件用工具查看，还有一款[阿里巴巴]()开源的堆内存调优工具不记得叫啥了。

24. **hashmap遍历？**

    答：太菜了只用过迭代器遍历所以只说了迭代器作者：旭一个

    看了网上还有：使用For-Each迭代entry，使用For-Each迭代keys或者values，迭代keys并搜索values（低效），1.8之后lambda表达式简化foreach遍历（map.forEach((k,v) -> System.out.println(k + "=" + v));）

25. static关键字？**如果子类和父类都有static变量，static修饰的代码块以及相应构造器，问加载顺序****？**

26. ==和equals？ Object类方法，hashcode，equals，hashcode实现，equals实现，会出现什么问题

27. **平常遇到哪些异常？**

28. **包的访问权限？说说public等几个修饰访问权限的区别？**

29. JVM内存分区？

    哪些地方是线程共享的？

     一个对象在内存分区中的过程？

    答：回答了栈中的对象引用，对象从eden区到sur[vivo](https://www.nowcoder.com/jump/super-jump/word?word=vivo)r到老年代的过程。

    **JVM内存调优？**

    答：说了些堆调优的参数配置，说了什么时候调大调小eden区。

30. **springMVC工作流程？**

    答：只知道请求响应。。。

    

31. JVM内存区域（1分钟）

32. 堆的内存布局（0.5分钟）

33. 垃圾回收完整过程（1分钟）

34. CMS垃圾回收过程（1分钟，记错了，失了忆，乱扯了一会）

35. NIO底层实现原理（2分钟）

36. G1垃圾回收过程（1.5分钟）

37. Spring如何解决循环依赖（3.5分钟）

38. MVCC原理（3分钟）

39. 消息中间件（不太了解）

40. 常见的设计模式（讲了单例、工厂、代理、装饰器、观察者，4分钟）

# Java Web

## Linux进程间通信

https://blog.csdn.net/gatieme/article/details/50908749

https://blog.csdn.net/Li_Ning_/article/details/52128307

### 管道（命名管道和无名管道）

### 信号

### 消息队列

### 共享内存

### 信号量

### 套接字（Socket）

## Linux Socket编程

[W. Richard Stevens](http://www.kohala.com/start/)

https://zhuanlan.zhihu.com/p/180556309

http://c.biancheng.net/cpp/html/3045.html

https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html

https://cloud.tencent.com/developer/article/1722240

Socket是Linux提供的系统调用，Socket调用了TCP/IP协议栈，TCP/IP、Socket都是Linux操作系统提供的用于网络通信服务的程序。

不同的语言的库函数对Socket系统调用进行了封装，Socket的实现在Linux内核中，包括TCP/IP的实现。高级语言的库函数封装了Socket系统调用，从而可以通过使用高级语言的Socket库函数调用Socket系统调用。

同一主机上的进程通信方式有管道（有名管道和无名管道）、信号、共享内存、消息队列、信号量等；不同主机通信使用Socket套接字。Socket编程使用传输层传递的协议（TCP、UDP）+端口，网络层的IP地址这三元组唯一标记网络中的一个进程。

创建一个Socket连接会返回一个Socket描述符，这是在进程文件描述符表的一个索引，这个索引指向系统进程文件数据结构的地址。文件描述符是Linux系统中每个进程的文件描述符表的索引；文件指针式C语言的一个指向FILE数据结构的指针，FILE数据结构包括一个缓冲区和一个文件描述符。

**网络字节序和主机字节序**

字节序指的是整数保存在内存中的字节的顺序，包括小端字节序和大端字节序。小端字节序是整数的低位存放在低地址，高位存放到高地址；大端字节序是整数的高位存放在低地址，低位存放在高地址。比如一个4字节32位的int数值01020304，在文件中保存为01020304，左边是低地址，右边是高地址；在socket中保存为04030201，最低地址是04，一个字节可以保存两个十六进制数，04是一个字节的十六进制表示。

### Socket C语言

![](https://pic1.zhimg.com/80/v2-d37fb0d929b6a8e7b68d82c2ac4f9abc_720w.jpg)

**C语言库函数中的Socket编程相关的库函数**

> **int  socket(int protofamily, int type, int protocol);//返回sockfd **
> 用于创建一个Socket描述符，他唯一标记一个Socket。protofamily表示协议族，包括AF_INET(IPV4)、AF_INET6(IPV6)等，他决定了Socket的网络地址类型；type，Socket类型，包括SOCK_TREAM、SOCK_DGRAM等；protocol，传输层协议，包括IPPROTO_TCP（TCP协议）、IIPROTO_UDP（UDP协议）等。当创建一个Socket描述符的时候，创建Socket描述符的时候返回的Socket描述符没有绑定IP和端口，可以使用bind函数绑定IP+端口，如果不使用bind绑定，在使用connect和listen等函数的时候会被自动分配IP+端口；这个机制使得服务端需要使用bind来绑定端口而客户端不用，因为客户端在使用connect和listen的时候会使用自动分配的端口。

> **int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);**
>
> 给文件描述符绑定IP地址和端口，其中sockaddr数据结构对不同的协议族定义不一样，在IPV4中，sockaddr定义如下
>
> ```text
> struct sockaddr_in {
>     sa_family_t    sin_family; /* address family: AF_INET */
>     in_port_t      sin_port;   /* port in network byte order */
>     struct in_addr sin_addr;   /* internet address */
> };
>  
> /* Internet address. */
> struct in_addr {
>     uint32_t       s_addr;     /* address in network byte order */
> };
> ```

> ```> 
> int listen(int sockfd, int backlog);
> int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
> sockfd是要监听或者使用的socket描述符，backlog是服务端允许排队的最大连接个数，addrlen是地址长度,调用listen后套接字编程监听套机字
> ```

> ```text
> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); //返回连接connect_fd
> ```
>
> accept接收listen传递的监听套接字，转换成连接套接字

> read/write函数，进行网络IO函数
>
> ```text
> #include <unistd.h>
> #include <sys/types.h>
> #include <sys/socket.h>
>  
> ssize_t read(int fd, void *buf, size_t count);
> ssize_t write(int fd, const void *buf, size_t count);
>  
> ssize_t send(int sockfd, const void *buf, size_t len, int flags);
> ssize_t recv(int sockfd, void *buf, size_t len, int flags);
> 
> ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
> const struct sockaddr *dest_addr, socklen_t addrlen);
> 
> ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
> struct sockaddr *src_addr, socklen_t *addrlen);
>  
> ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
> ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
> ```

> ```text
> int close(int fd);
> ```
>
> 关闭套接字，这个套接字的引用计数变成0，这个套接字不能继续作为read/write函数的第一个参数

**C语言 Socket 编程实现不同主机进程通信**

https://zhuanlan.zhihu.com/p/180556309

```c
/* File Name: client.c */
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
 
#define MAXLINE 4096
 
int main(int argc, char** argv){
 	int    sockfd, n,rec_len;
 	char    recvline[4096], sendline[4096] = "abcd";
 	char    buf[MAXLINE];
 	struct sockaddr_in servaddr;
 
 
 	if( argc != 2){
 		printf("usage: ./client <ipaddress>\n");
 		exit(0);
    	}
 
 
 	if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
 		printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);
 		exit(0);
    	}
 
 	memset(&servaddr, 0, sizeof(servaddr));
    	servaddr.sin_family = AF_INET;
    	servaddr.sin_port = htons(8000);
 	if( inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0){
 		printf("inet_pton error for %s\n",argv[1]);
 		exit(0);
    	}
 
 
 	if( connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){
 		printf("connect error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 
 	printf("send msg to server: \n");
    	//fgets(sendline, 4096, stdin);
 	if( send(sockfd, sendline, strlen(sendline), 0) < 0){
 		printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);
 		exit(0);
    	}
 	if((rec_len = recv(sockfd, buf, MAXLINE,0)) == -1) {
       		perror("recv error");
 		exit(1);
    	}
    	buf[rec_len]  = '\0';
 	printf("Received : %s ",buf);
    	close(sockfd);
 	exit(0);
}

```

```c
/* File Name: server.c */
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#define DEFAULT_PORT 8000
#define MAXLINE 4096


int main(int argc, char** argv){
	int    socket_fd, connect_fd;
 	struct sockaddr_in servaddr;
 	char    buff[4096];
 	int     n;
 	//初始化Socket
 	if( (socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){
 		printf("create socket error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 	//初始化
 	memset(&servaddr, 0, sizeof(servaddr));
    	servaddr.sin_family = AF_INET;
    	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。
    	servaddr.sin_port = htons(DEFAULT_PORT);//设置的端口为DEFAULT_PORT
 
	//将本地地址绑定到所创建的套接字上
 	if( bind(socket_fd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1){
 		printf("bind socket error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 	//开始监听是否有客户端连接
 	if( listen(socket_fd, 10) == -1){
 		printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);
 		exit(0);
    	}
 	printf("======waiting for client's request======\n");
 	while(1){
	//阻塞直到有客户端连接，不然多浪费CPU资源。
 		if( (connect_fd = accept(socket_fd, (struct sockaddr*)NULL, NULL)) == -1){
	 		printf("accept socket error: %s(errno: %d)",strerror(errno),errno);
	 		continue;
    		}
		//接受客户端传过来的数据
	    	n = recv(connect_fd, buff, MAXLINE, 0);
		//向客户端发送回应数据
	 	if(!fork()){ /*紫禁城*/
	 		if(send(connect_fd, "Hello,you are connected!\n", 26,0) == -1)
				perror("send error");
			close(connect_fd);
	 		exit(0);
	    	}
	    	buff[n] = '\0';
	 	printf("recv msg from client: %s\n", buff);
	    	close(connect_fd);
    	}
    	close(socket_fd);
}
```

### Socket Python

https://www.runoob.com/python/python-socket.html

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名：client.py
 
import socket               # 导入 socket 模块
 
s = socket.socket()         # 创建 socket 对象
host = socket.gethostname() # 获取本地主机名
port = 12345                # 设置端口号
 
s.connect((host, port))
print(s.recv(1024) )
s.close()
```

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名：server.py
 
import socket               # 导入 socket 模块
 
s = socket.socket()         # 创建 socket 对象
host = socket.gethostname() # 获取本地主机名
port = 12345                # 设置端口
s.bind((host, port))        # 绑定端口
 
s.listen(5)                 # 等待客户端连接
while True:
    c,addr = s.accept()     # 建立客户端连接
    print('连接地址：', addr)
    mystring = "Hello"
    c.send(mystring.encode())
    c.close()                # 关闭连接
```



### Socket Java

https://www.liaoxuefeng.com/wiki/1252599548343744/1319099802058785

```c
//Client.java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class Client {
	public static void main(String[] args) throws IOException {
		Socket sock = new Socket("localhost", 6666); // 连接指定服务器和端口
		try (InputStream input = sock.getInputStream()) {
			try (OutputStream output = sock.getOutputStream()) {
				handle(input, output);
			}
		}
		sock.close();
		System.out.println("disconnected.");
	}

	private static void handle(InputStream input, OutputStream output) throws IOException {
		var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
		var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
		Scanner scanner = new Scanner(System.in);
		System.out.println("[server] " + reader.readLine());
		for (;;) {
			System.out.print(">>> "); // 打印提示
			String s = scanner.nextLine();
			writer.write(s);
			writer.newLine();
			writer.flush();
			String resp = reader.readLine();
			System.out.println("<<< " + resp);
			if (resp.equals("bye")) {
				break;
			}
		}
	}
}

```

```java
//Server.java

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.charset.StandardCharsets;

/**
 * Learn Java from https://www.liaoxuefeng.com/
 * 
 * @author liaoxuefeng
 */
public class Server {
	public static void main(String[] args) throws IOException {
		ServerSocket ss = new ServerSocket(6666); // 监听指定端口
		System.out.println("server is running...");
		for (;;) {
			Socket sock = ss.accept();
			System.out.println("connected from " + sock.getRemoteSocketAddress());
			Thread t = new Handler(sock);
			t.start();
		}
	}
}

class Handler extends Thread {
	Socket sock;

	public Handler(Socket sock) {
		this.sock = sock;
	}

	@Override
	public void run() {
		try (InputStream input = this.sock.getInputStream()) {
			try (OutputStream output = this.sock.getOutputStream()) {
				handle(input, output);
			}
		} catch (Exception e) {
			try {
				this.sock.close();
			} catch (IOException ioe) {
			}
			System.out.println("client disconnected.");
		}
	}

	private void handle(InputStream input, OutputStream output) throws IOException {
		var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
		var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
		writer.write("hello\n");
		writer.flush();
		for (;;) {
			String s = reader.readLine();
			if (s.equals("bye")) {
				writer.write("bye\n");
				writer.flush();
				break;
			}
			writer.write("ok: " + s + "\n");
			writer.flush();
		}
	}
}

```

### Socket Go

http://c.biancheng.net/view/4513.html

```go
//Client.go
package main
import (
    "log"
    "net"
    "os"
)
func main() {
    if len(os.Args) != 2 {
        log.Fatalf("Usage: %s host:port", os.Args[0])
    }
    service := os.Args[1]
    tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
    if err != nil {
        log.Fatal(err)
    }
    conn, err := net.DialTCP("tcp4", nil, tcpAddr)
    if err != nil {
        log.Fatal(err)
    }
    n, err := conn.Write([]byte("HEAD / HTTP/1.1\r\n\r\n"))
    if err != nil {
        log.Fatal(err)
    }
    log.Fatal(n)
}
```

```go
//Server.go

package main
import (
    "fmt"
    "log"
    "net"
    "time"
)
func echo(conn *net.TCPConn) {
    tick := time.Tick(5 * time.Second) // 五秒的心跳间隔
    for now := range tick {
        n, err := conn.Write([]byte(now.String()))
        if err != nil {
            log.Println(err)
            conn.Close()
            return
        }
        fmt.Printf("send %d bytes to %s\n", n, conn.RemoteAddr())
    }
}
func main() {
    address := net.TCPAddr{
        IP:   net.ParseIP("127.0.0.1"), // 把字符串IP地址转换为net.IP类型
        Port: 8000,
    }
    listener, err := net.ListenTCP("tcp4", &address) // 创建TCP4服务器端监听器
    if err != nil {
        log.Fatal(err) // Println + os.Exit(1)
    }
    for {
        conn, err := listener.AcceptTCP()
        if err != nil {
            log.Fatal(err) // 错误直接退出
        }
        fmt.Println("remote address:", conn.RemoteAddr())
        go echo(conn)
    }
}
```

## Java单例模式

**private构造函数的作用**

https://wenku.baidu.com/view/c1ba14df971ea76e58fafab069dc5022aaea463b.html

private构造函数作用是防止private构造函数的类被其他类实例化，也就是private构造函数的类不能被其他类实例化。private构造函数的类的成员函数只能是静态函数，因为他不能被实例化，那么他的方法都是类相关的方法而不是跟实例相关的方法。private构造函数的类不能被外部函数创建但是可以被内部函数创建。

**Java单例模式实现方法**

- 饱汉模式（静态方法）

  ```java
  public class Singleton{
  	private static Singleton INSTANCE = null ;				  //因为单例模式不能被实例化，那么必须使用static
  	private Singleton() { }									  //private构造函数的类不能被外部类实例化，但是可以																 //被内部函数实例化
  	public synchronized static final Singleton getInstance() {//synchronized保证线程安全，因为不能被实例化所以															   //方法使用static，final可有可无，final方法防止类															  //被继承时改写方法
  		if( INSTANCE == null )
  			INSTANCE = new Singleton() ;
  		return INSTANCE ;
  	}
  	
  	public static void main(String[] args) {
  		Singleton s1 = Singleton.getInstance() ;
  		Singleton s2 = Singleton.getInstance() ;
  		
  		System.out.println( System.identityHashCode(s1) ) ;
  		System.out.println( System.identityHashCode(s2) );
  	}
  }
  ```

- 饱汉模式（静态代码块）

  ```java
  public class Singleton{
  	private static Singleton INSTANCE = null ;				  //因为单例模式不能被实例化，那么必须使用static
  	private Singleton() { }									  //private构造函数的类不能被外部类实例化，但是可以																 //被内部函数实例化
  	public static final Singleton getInstance() {//synchronized保证线程安全，因为不能被实例化所以															   //方法使用static，final可有可无，final方法防止类															  //被继承时改写方法
  		if( INSTANCE == null ) {
  			synchronized( Singleton.class ) {
  				INSTANCE = new Singleton() ;
  			}
  		}
  		return INSTANCE ;
  	}
  	
  	public static void main(String[] args) {
  		Singleton s1 = Singleton.getInstance() ;
  		Singleton s2 = Singleton.getInstance() ;
  		
  		System.out.println( System.identityHashCode(s1) ) ;
  		System.out.println( System.identityHashCode(s2) );
  	}
  }
  ```

- 饱汉模式（静态内部类）

  https://blog.csdn.net/czh500/article/details/83876425

  **Java静态类一定是静态内部类，他和普通内部类的区别在于**

  - 静态内部类可以创建静态和非静态成员（函数或变量），而普通内部类不能创建静态成员（函数或者变量）

  - 静态内部类只能访问外部类的静态成员（函数或变量），而普通内部类可以访问任意城公园（函数或变量）

  - 静态内部类可以单独使用 **new 外部类.内部类()**的方式创建，而创建内部类实例必须先实例化外部类，在实例化内部类

    ```
    outer = new Outer() ;
    inner = outer.Inner() ;
    ```

  **静态内部类实现饱汉模式单例模式**

  ```java
  public class Singleton{
  	private Singleton() {} ;
  	
  	public static Singleton getInstance() {
  		return SingletonOnce.INSTANCE ;
  	}
  	private static class SingletonOnce{
  		private static final Singleton INSTANCE = new Singleton() ;//外部类可以访问内部类的私有成员，
  																   //内部类也可以访问外部类的私有成员
  	}
  	
  	public static void main(String[] args) {
  		Singleton s1 = Singleton.getInstance() ;
  		Singleton s2 = Singleton.getInstance() ;
  		
  		System.out.println( System.identityHashCode(s1) ) ;		   //使用identityHashCode打印内存地址
  		System.out.println( System.identityHashCode(s2) );
  	}
  }
  ```

  

- 饿汉模式（静态变量类加载时实例化）

  ```java
  public class Singleton{
  	private static Singleton INSTANCE = new Singleton() ; 		//类加载时初始化
  	private Singleton() {} ;
  	public static Singleton getInstance() {
  		return INSTANCE ;
  	}
  	
  	public static void main(String[] args) {
  		Singleton s1 = Singleton.getInstance() ;
  		Singleton s2 = Singleton.getInstance() ;
  		
  		System.out.println( System.identityHashCode(s1) ) ;
  		System.out.println( System.identityHashCode(s2) );
  	}
  }
  ```

# 算法和数据结构相关

1. 说下[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)和B树的区别和各自优缺点?(没答好，B树效率高且适合数据多的情况，节点[二分查找](https://www.nowcoder.com/jump/super-jump/word?word=二分查找)，磁盘块读取，[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)适合数据量少的直接全部加载到内存去读)

2. HasnMap和ConcurrentHashMap的区别

3. [红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)有了解吗，聊聊b树和b+树，b树和[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)比较下优缺点

4. 讲一下稳定的排序算法和不稳定的排序算法

5. 讲一下快速排序的思想

6. ArrayList和LinkedList区别

7. 冒泡时间复杂度

8. 说一说**[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)**？选一种熟悉的说具体[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)？

   答：快排，堆排，归并。

## 手撕算法

1. 链表的公共节点
2. 旋转数组的二分查找
3. 快排
4. 栈如何实现队列

## 排序

排序的稳定性：排序时相同元素的相对位置不发生改变就是稳定的排序算法

稳定的排序算法有：冒泡排序，插入排序，归并排序，计数排序，基数排序，桶排序

不稳定的排序算法：选择排序，快速排序，堆排序，希尔排序

![](https://s7.51cto.com/images/blog/202107/02/683f8e7c222a81533a3dd448e0c49a5b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)

[快排，堆排，归并排，选择排，插入排，冒泡排实现](https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=117&tqId=37851&companyId=139&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F139&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)



1. [二叉树层序遍历-链式二叉树的层序遍历](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=117&tqId=37723&companyId=139&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F139&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)
2. [二叉树-二叉树的最近公共祖先](https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=190&tqId=35225&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)
3. [位运算异或-求只出现一次的数](https://leetcode-cn.com/problems/single-number/)
4. [二叉树DFS-二叉树路径和](https://leetcode-cn.com/problems/path-sum-ii/)

## 数据结构

### 数组和矩阵

1. [数组中重复的数字-对于n长的元素大小在0到n-1之间的数组可以将第i个元素放到arr[i]的位置处理](https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&tqId=11203&tab=answerKey&from=cyc_github)

### 树

1. [二叉树层序遍历-链式二叉树的层序遍历](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=117&tqId=37723&companyId=139&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F139&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)
2. [二叉树-二叉树的最近公共祖先](https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=190&tqId=35225&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)
3. [二叉树DFS-二叉树路径和](https://leetcode-cn.com/problems/path-sum-ii/)

### 链式哈希表

1. [链式哈希表-LRU缓存结构-LinkedHashmap](https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=117&tqId=37804&companyId=139&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F139&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

### 优先队列

1. [优先队列-合并K个有序表](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=190&tqId=35193&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

### 栈

1. [栈-链表反转，链表相加，链表从后往前每K个分一组](https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=190&tqId=35219&rp=1&ru=%2Fta%2Fjob-code-high-rd&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)
2. [栈-括号匹配]( https://www.nowcoder.com/practice/37548e94a270412c8b9fb85643c8ccc2?tpId=117&tqId=37749&companyId=139&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F139&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey )

## 动态规划

1. [斐波拉契数列](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=117&tqId=37764&companyId=139&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F139&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)
2. [最长递增子序列]()

## 技巧

### 双指针 快慢指针

1. [快慢指针-判断链表是否有环和求环节点](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=117&tqId=37714&companyId=139&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F139&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)
2. [求增量要先减A再加B，就可求B-A增量-使数组唯一的最小增量](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)

3. [双向双指针-接雨水问题](https://www.nowcoder.com/practice/31c1aed01b394f0b8b7734de0324e00f?tpId=188&&tqId=38549&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)
4. [双指针/栈-合并区间](https://leetcode-cn.com/company/mi-history/custom/SW50ZXJ2aWV3Q3VzdG9tU2Vzc2lvbk5vZGU6NTUzNjk4/merge-intervals/)

### 找规律

1. [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

2. 交换两个变量的值

   ```
   使用额外变量
   c = a;
   a = b ;
   b = c ;
   
   使用位运算
   a = a^b ;
   b = a^b ;
   a = a^b ;
   
   使用加减法
   a = a+b ;
   b = a-b ;
   a = a-b ;
   
   使用乘除法
   a = a*b ;
   b = a/b ;
   a = a/b ;
   
   上面的算法都只能处理整数，而且加减法和乘除法可能溢出，不能处理小数
   ```


# 其他

高级语言（C++，Java，Python）、框架（Connections框架，Spring框架）、软件工程、设计模式

数据库设计（MySQL，Redis，Mybatis，Hibernate）

中间件（RabbitMQ）

编译原理、机器语言

操作系统

计算机网络

计算机组成原理

脉冲电路与数字逻辑

大学物理、高等数学、线性代数、概率论

# 有什么想问的

有什么问的?(什么部门的, 主要业务)

1. 怎么管理项目成员
2. 当意见不一致时，如何沟通并说服开发成员，并举个例子
3. 怎么保证项目的进度
4. 技术选型，一个新技术和一个稳定的旧技术，你会怎么选择，选择的考虑有哪些
5. 说你印象最深的美团点评技术团队的三篇博客
6. 最近在学什么新技术
7. 你是怎么去接触一门新技术的
8. 会看哪些书
9. 怎么选择要看的书

你还有什么亮点吗——听到这个问题我就差不多意识到了这次面试凉了

问了问部门业务，框架（springcloud）等等。

看过哪些书？框架学习打算？

答：本以为要结束了就说了说不熟悉的SSM，没想到接着问了。

反问：问了问部门业务（做数据迁移），框架（springboot）等等。



部门内实习生会干些什么工作 

 有没有学习建议（自己总结吧，感觉你学习的深度还不错） 

 问面试结果（听提前批招聘群里的阿里招聘人员说可以直接问面试结果，然后面试官说还有再综合评估一下，晚点群里有人会通知你， 

 听其他人说面完就会直接告诉结果的，我感觉自己凉了，还是太菜了，而且还是二本学历，呜呜呜。



转正实习

[腾讯]()福利和工作环境是真的很不错，实习体验很好👍转正答辩是10分钟的PPT汇报+提问，主要就是说实习做了什么，收获了什么，以及对自己的规划之类的。答辩组一般5人，1（部门总监）+4（其他部门总监）。转正结果在9月初就出来了，基本组长都会提前通通气😸全程相对比较顺利。

阿里工作强度略大于[腾讯]()，不过阿里的平台基础设施和中间件感觉很不错，开发过程可专注项目搭建，开发流程清晰。阿里的业务属性要重一些，有好有坏吧，看个人选择啦。转正答辩全程1h左右，30分钟PPT汇报（小组业务+实习项目+中间件学习+感悟总结）30分钟问答，答辩组两P9（一个部门大老板，一个其他部门大老板）+hrg。相对来说阿里的答辩比较严格，前前后后准备了2周，部门模拟答辩都进行了好几次😵，不过期间收获还是很多滴，师兄们倾囊相助，超级nice。

信息真的很重要，可以添加一些秋招群大家一起共享信息，还有就是[牛客]()之类的信息平台、各司招聘微信公众号、学校的招聘公众号等等。就因为这些，字节秋招就没笔试，直接进面试👏 

选择很重要，但选择有时候选择是也盲目的，尤其在信息不对称的时候。差距不大的情况下还是想想自己的初衷和本心吧（不忘初心），永远相信自己选的就是最好的，是金子在哪里都可以发光！ 

心态也很重要，求职过程一定会遇到疲惫期，那就给自己一些放纵的时间，不要总是盯着[牛客]()[脉脉]()，负能量太多会很累的。





作者：HappY131c
链接：https://www.nowcoder.com/discuss/683433?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
来源：牛客网



1.自我介绍
2.八股文、基础（问的比较杂，但是很基础）
（1）java的特性（面向对象理解、三大特性）
（2）抽象类与接口、抽象类中可以有具体方法？
（3）为什么要有自动装箱、拆箱？为什么要有包装类？（我说是为了处理基本数据类型和引用数据类型，我知道是错的）
（4）基本数据类型有哪些，各占多大字节？（我惊了，问这个会不会太基础了点，一时懵逼）
（5）创建线程的方式（3种：Runnable、Thread、Callable）
（6）进程间通信的方式（4种：管道、消息队列、共享内存、套接字）
（7）java中死锁怎么产生的？
（8）jdk是1.8版本的，有什么新特性？（HashMap、ConcurrentHashMap从1.7~1.8）
（补充说labuda**什么，我没学过...）
（9）进程和线程
（10）Mysql索引（哈希、B+树：聚簇索引、非聚簇索引）
（11）Http协议、tcp协议（http通信过程、tcp的特点）
3.项目
（1）项目中遇到的问题、怎么解决的，通过什么方式？
（2）有没有遇到很难解决的问题和时候？
感觉更多的是从你的项目中了解到你个人的开发风格和性格等等，偏技术的比较少。
4.其他
（1）工作地有要求？（菜鸟不敢有，国内都可以，如果不是英语差，国外也行，不行，国外疫情太乱了）
（2）最近看神马书？（深入理解Java虚拟机、Redis深度历险、Mysql技术内幕...太多了记不起来，就说了三）
（3）有没有考研的想法？（没有没有，我觉得无论是考研还是工作其实我们都在一直往上走，加油就对了）
（4）个人规划？（孩子们，阿里的面试官粑粑建议我们要有个人规划哦！）
5.反问：您对我学习或者其他方面有什么建议吗？（感动！！贼有帮助！！！此生不愧面阿里）
总体觉得其实阿里面试感觉很轻快，虽然会给人一种很随便的感觉，但是真真切切的感觉到的是很轻松的感觉。
而且贼准时，说19:00真就19:00来电话。
都说一面简单基础，二面压力就上来了，我觉得我也得遭受这样的压力，毕竟我次次挂二面。

# 二面

8月10日 原本是视频面 后来因为特殊原因转成电话面
时长：30min
时间线拉的有点长
中间安排了一次笔试，隔了很久，然后才催了几次才安排了本次面试。
1.自我介绍
2.八股文、基础
java自动内存管理机制这块整个大概的都说了一下
3.实习项目
大概问了一下我的整个收获啊、经历、自己的一些感觉，自己的理论知识有什么帮助之类的。
4.个人经历
简历是旧的，问了我之前院会部长的荣誉和经历等。
5.如何看待八卦？
仅代表个人意见。
互联网的时代，会把一件事情的热度扩大到相对火热，但不太关心八卦的我，只想搞技术。

我觉得，阿里从某些方面上讲，还是会引发我们的一些技术和个人规划方向的思考吧。
真心建议简历不要造假，但凡卡住就很尴尬。

-- 世界都有黑白，哪管那么多。





自我介绍 

 你现在后端研发的主要技能是你自学的吗 

 synchronized方法的作用 

 synchronized和lock的区别（回答的不好） 

 countDownLatch和CyclicBarrier的介绍 

 ClassLoader双亲委派机制 

 为什么有了双亲委派这种机制？还要破坏这种机制，一般什么场景会那么做？（再熟悉一下） 

 ClassLoader里面loadclass()和findclass()区别（再熟悉一下） 

 java内存管理的垃圾回收器有哪些 

 GMS垃圾回收器的[算法]()介绍 

 spring的好处（总结一下） 

 spring的依赖注入 

 bean的生命周期 

 beanFactory和FactoryBean的区别 

 mysql分页查询的关键字 

 union all和union的区别 

 mysql的sql调优分几个步骤 

 Innodb插入和删除为什么比mysaim快 

 因为mysaim只支持表锁，innodb支持表锁和行锁 

 mysql主备同步 

 binlog的模式 

 一般来说binlog是逻辑日志，即记录的是sql语句。 

 binlog有三种模式一个是statement ，基于sql语句的日志 一个是row基于行的复制，不记录sql语句和上下文信息，只记录哪条数据被修改了 mixed两个都用，主要为statement，如果statement处理不了用row 

 消息队列作用 

 Kafka作为消息中间件具备**系统解耦**、冗余存储、**流量削峰**、缓冲、**异步通信**、扩展性、可恢复性等特点。 

 还学过其他消息队列吗？ 

 kafka顺序消息 

 kafka在发送一条消息的时候，可以指定 topic partition和key三个参数。partition和key是可选的。如果指定了partition，那就是所有消息都被发送到一个partition，就是有序的，或者你指定一个key，具有同一个key的消息会被发送到同一个partition，也是有序的。在消费端，kafka保证，1个partition只能被一个consumer消费。 

 [字节跳动]()实习的情况 

 ebay的[销售]()预测的方法项目 

 你在ebay的实习中一直在迭代这个[销售]()预测的方法吗 

 讲一下秒杀的设计 

 你这个项目是练手的还是给别人用的 

 最近在看哪些技术？平时会看哪些博客？ 

 之后想往哪个方向发展，未来1-3年的规划 

 论文接收了嘛？



作者：louis_code
链接：https://www.nowcoder.com/discuss/717557?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
来源：牛客网



\1. 自我介绍 

  问项目问了20分钟，后面就是一些常规问题 

1.  之前你现在考虑做研发，[算法]()你为什么不去搞了 
2.  java1.8跟7或者11有什么不一样的 
3.  用流式编程计算一个string的list里面有多少元素是以s结尾的 
4.  1.8里面默认的垃圾回收[算法]()是哪个 
5.  CMS和G1具体的区别 
6.  G1求解的目标函数的目标 
7.  G1的目标和CMS目标有什么区别 
8.  Concurrent HashMap的数据结构？底层是怎么实现的？ 
9.  Concurrent HashMap hashcode的原理（是不是数据结构内部实现的）和塞到[链表]()里面怎么做的 
10.  为什么hashmap里面用了[红黑树]()，[红黑树]()怎么保证并发 
11.  [redis]()部署方式有几种 
12.  讲一下主从、哨兵和集群的区别 
13.  [redis]()选主[算法]()是怎么做的 
14.  [redis]()怎么实现分布式锁 
15.  论文发在哪里 
16.  现在还在实习嘛？你现在还有其他的offer吗？为什么之前没有留下来？ 
17.  哪里人？多大了？ 
18.  阿里最近很火的问题？怎么看？ 
19.  其他offer的待遇大概是多少？ 
20.  本科和研究生成绩大概是多少？ 

 反问：认为基础知识怎么样？ 

   学习能力不错，建议多总结归纳，分布式实践比较少，建议多总结



作者：阿拉蕾与葫芦娃
链接：https://www.nowcoder.com/discuss/656345?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
来源：牛客网



你是做啥的，你未来做什么？不是[算法]()吧？ 

 你的项目用了SpringCloud,介绍一下怎么用的？Eeruka说一下怎么使用的，我用的[阿里巴巴]()的Nacos。说了Feign。一个服务器上线和下线怎么使用？ 

 说说MySQL的B+Tree索引。为啥用B+Tree？ 

 树高为啥是3？ 

 了解过MySQL的5.2以上版本的新特性吗？ 

 说说JVM 的内存模型？ 

 说说HashMap？HashMap怎么解决Hash冲突？ 

 HashMap怎么扩容的？什么时候扩容？ 

 三次握手和四次握手为什么四次和三次？ 

 说说死锁。 

 怎么预防死锁？ 

 说说你做的实验室项目的？挫折。 

 做道[算法题]()。两个有序数组和为一个有序数组。 

  一周内 HR会给你结果，什么时候来，现在已经有的实习生来了。



作者：stevess
链接：https://www.nowcoder.com/discuss/633796?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
来源：牛客网



上来先是自我介绍，然后没让我介绍项目，直接开问

 主要是围绕项目中的一些实现细节问了差不多20分钟

 项目外的问题：

1. netty高效在哪里 
2. 高可用的限流问题，给个场景，问如何解决（考察限流策略） 
3. 单线程[redis]()缓存高效的原因 
4. 讲下[redis]()线程模型底层实现细节 
5. 互斥锁和自旋锁 
6. 平时怎么学习java 
7. 在实验室里是什么角色，代码实现者还是设计者 
8. 你和别人的优势在哪里 

​      


#  二面（技术主管面1h20min）4.2 

 面完一面约的第二天晚上 但下午就打电话面试了

 还是没让介绍项目，直接开问

1. RPC和http的区别，为什么不用http实现远程调用 
2. http在哪层，应用层还有哪些协议 
3. [redis]()和mysql相比的优势 
4. 讲下数据库连接池 
5. [redis]()集群模型，如何传递消息，哨兵挂了如何处理 
6. [redis]()4.0建议几台机器做主从，从的数据是否一致    
7. netty的容错性 
8. 讲下Dubbo源码以及Dubbo调用失败的应对策略 
9. JUC包常用类 
10. 垃圾回收[算法]()在1.8，1.9的具体实现，默认哪些GC 
11. 详细讲下垃圾回收[算法]()，清除[算法]()的缺点 
12. 讲一下cms和G1 
13. JVM调优参数 
14. 发生内存溢出如何排查，什么原因 
15. 中间件了解哪些，zoo[keep]()er如何实现分布式锁 
16. Spring框架了解过没 
17. 对未来技术发展方向的规划 

#  三面（总监面30min）4.2 

  二面当天就约了晚上三面 

 上来先介绍了部分，然后让我简单做个自我介绍

1. 研究生做[算法]()为什么面开发 
2. 是不是保研，为什么跨考 
3. 操作系统的内存管理讲讲 
4. 讲下进程、线程、协程、纤程 
5. 场景题关于线程的通信的具体实现，口述 
6. 讲下CNN的整个实现过程，原理 
7. 讲下激活函数原理，用过哪些 
8. 池化层的作用，讲下感受野 
9. 听说过bert模型嘛，讲一下（NLP） 
10. 什么时候毕业，什么时候可以来实习 
11. 有什么想问的 

#  HR面（30min）4.6 

  节后第一天晚上9点过突击面试，正在健身房，赶紧找个角落接电话 

1. 是不是本硕连读 
2. 为什么选择考研 
3. 跨考原因 
4. 通过读研你学到了什么 
5. 最有成就感的事情 
6. 最让你有挫败感的事情 
7. 面试了几家拿了哪些offer 
8. 为什么选择[阿里巴巴]() 
9. 了解我们事业部嘛 
10. 说说自身优缺点 
11. 有什么想问的 

#  总结 

  整体的面试体验还是非常好的，听面试官说集团要求加快校招进度，所以面试流程很快 

 基本两天就面完三面，节后第一时间就面HR，面试官人都很好很和蔼，有很好的互动，

 在面试过程中你有不懂得问题，也会为你讲解，学到不少东西。

 目前已拿offer 





作者：G2的kkennys本人
链接：https://www.nowcoder.com/discuss/860668?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack
来源：牛客网



1. **项目简单介绍一下**
   
2.  **Java
   ** jdk和jvm是什么？
    类的加载过程？
    常用的数据类型？
    装箱和拆箱？
    线程池优点？
    怎么创建线程池？ 
3.  **Redis
   ** 缓存穿透？怎么解决
    怎样降低布隆过滤器的hash冲突？
    缓存雪崩？怎么解决
    [redis]()数据结构都有什么？常用在哪举个例子？
    zset结构？
    [redis]()怎么实现分布式锁？（不了解） 
4.  **MySQL
   ** acid？
    隔离级别？
    怎么实现隔离性的？
    mvcc讲一下？
    怎么实现乐观锁和悲观锁？
   
5.  rpc了解吗？（不了解） 
6.  简单说一下单点登录？（不了解） 
7.  **计网
   ** http请求头有什么？
    cookies和sessions？ 
8.  **反问
   ** 在哪个方面需要提升自己？（数据库和java基础不错，一些简单的概念需要深入了解一下）
    贵组业务？（巴拉巴拉） 

 





作者：Steve_ZhuKW
链接：https://www.nowcoder.com/discuss/686564?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack
来源：牛客网



\0. 介绍我研究生方向，选什么课？      

   ---->针对性，为以后当程序员做准备。课程：计算机基础四大课程， 分布式系统， 软件架构  

   \1. Java中hashmap底层实现原理？  

   ---->array + 拉[链表]()（长度大于8转[红黑树]()）  

   追问：如何put一个key-value呢？    

   --->位置上没别的key-value：直接放在array的那个位置上；有别的, 长度小于8: 插入到[链表]()； 长度大于8：插入进[红黑树]()。  

   \2. JVM了解吗？    

   --->  了解得不多，只知道这是java实现跨平台（跨操作系统）的原理。  

   \3. 数组和[链表]()有什么区别？    

   --->  数组有索引，[链表]()无索引；数组物理地址连续，[链表]()物理地址不一定连续；因为有索引，数组查询比[链表]()快；[链表]()插入删除节点比数组开销小；  

   \4. 说下MySQL索引？    

   --->  详细介绍聚簇，非聚簇；B+索引hash索引；主键，非主键；单值索引，联合索引；索引的适用场景和不适用场景。  

   \5. 四种隔离级别？  

   未提交读（Read Uncommited）：啥都不做  

   （一级封锁协议 ----> 解决丢失修改）  

   提交读（Read Commited）：二级封锁协议 ----> 解决脏读  

   可重复读（Repeatable Read）: 三级封锁协议 ----> 解决不可重复读  

   可串行化（Serializable）：两段锁协议强制事务串行执行 ----> 解决幻读问题  

   （其中提交读和可重复读也可以由MVCC实现）  

   \6. 五层网络协议？    

   ---->物理层，链路层，网络层，传输层， 应用层  

   \7. TCP包的结构（TCPs首部）？   

​    ---->源端口，目的端口，序号（保证有序，快重传），确认号，窗口（顺便讲了 发送窗口 = min（拥塞窗口，接收窗口）），校验和，（SYN, FIN）这些。  

   \8. 介绍一下TCP？    

   ---->可靠，有连接，不一定实时，三次握手，四次挥手，超时重传，快重传，以及与UDP的区别  

   \9. 了解设计模式吗？    

   ---->不了解但准备学  

   \10. 了解面向对象编程吗，了解定义属性五大原则吗？    

   --->  不了解  

   \11. 做过网络编程吗？    

   --->  不是这个方向  

   \12. 发过技术文章，或者开源项目贡献代码吗？    

   ---->技术文章github总结过代码场考题，开源项目没贡献过  

   \13. 学习方法？    

   ---->先保证知识广度，利用[google]()，github, stack overflow， 哪里不会学哪个，享受技术提升的过程。再保证基础的扎实程度，通过名校的公开课来系统学习计算机基础知识，让知识更加成体系。再往深度挖深，比如光学会某个[算法]()不够，要思考有哪些方向可以优化。  

   --------------根据我的意愿分到上海/杭州部门的面试了，业务是：淘系全球交易------------  

##      2021.3.23 二面（通过）   

   \0. 自我介绍  

   \1. 为什么选择上海，杭州base可以吗?  

   --->喜欢上海，杭州可以接受  

   \2. 愿意系统学习Java吗？  

   --->愿意  

   \3. 面试官详细地介绍了业务，并称我的一面答得挺好，不用问重复的问题了，直接约了leader面。  

​            2021.3.26 三面 大老板面 （通过）                     0. 自我介绍                        1. 研究生入学了没？                            --->  没                        2. 空档期一年学了哪些知识？怎么学的？                            --->  计算机基础四大课程，原本看视频，后面看书。                        3. 为何快毕业了才决定转码呢？                            --->  居家学习让我停下来思考我真正想要做什么                        4. 问个操作系统，信号量是干什么的？                          --->  进程间通信同步（位于共享内存和信号之后），线程间同步                        5. 信号量还有哪些其他应用场景？                          --->  不知道了，猜了一个系统性能监控                        6. 输入一个网址到返回界面的过程？                        发送http请求--->看本地缓存--->DNS解析出域名对应的IP地址--->TCP/IP五层协议--->可能会有代理（正向代理反向代理）--->TCP连接三次握手 / https认证，加密，解密                        --->找到端口号--->nignx定位到应用--->mvc框架下从views找到路由--->验证权限--->解析url参数--->看服务器中的缓存--->代码逻辑中获取数据并返回html模板                        --->服务端发送http响应--->浏览器渲染页面                        7. 这里面HTTP层做了什么？                          ---> 解析get和post请求, 比如代码里http库有些api可以解析get请求，取出传入的参数。(我忘记提HTTPS了)